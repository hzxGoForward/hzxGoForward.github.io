<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.6.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.6.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '6.6.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false,"padding":18},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="萌虎下山">
<meta property="og:url" content="https://hzxgoforward.github.io/index.html">
<meta property="og:site_name" content="萌虎下山">
<meta property="og:locale">
<meta property="article:author" content="hzx">
<meta name="twitter:card" content="summary">






  <link rel="canonical" href="https://hzxgoforward.github.io/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>萌虎下山</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">萌虎下山</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">与其感慨路难行，不如马上出发!</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hzxgoforward.github.io/2023/03/03/hexo%20%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌虎下山">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2023/03/03/hexo%20%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="https://hzxgoforward.github.io/index.html">hexo 使用</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建于：2023-03-03 16:01:04" itemprop="dateCreated datePublished" datetime="2023-03-03T16:01:04+08:00">2023-03-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="更新于：2023-03-05 19:55:38" itemprop="dateModified" datetime="2023-03-05T19:55:38+08:00">2023-03-05</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E4%B8%AA%E4%BA%BA%E7%BD%91%E9%A1%B5/" itemprop="url" rel="index"><span itemprop="name">个人网页</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          


          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="撰写博客"><a class="markdownIt-Anchor" href="#撰写博客"></a> 撰写博客：</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. hexo clean # 清理缓存</span><br><span class="line">2. hexo g # 生成静态网页</span><br><span class="line">3. hexo d # 开始部署</span><br><span class="line">4. hexo s # 执行hexo s本地产看NexT主题效果</span><br></pre></td></tr></table></figure>
<h3 id="删除文章"><a class="markdownIt-Anchor" href="#删除文章"></a> 删除文章</h3>
<ol>
<li>删除文件夹source/_posts下目标文章markdown文件</li>
<li>删除.deploy_git文件夹</li>
<li>执行hexo clean后，再执行hexo g，hexo g 即可。</li>
</ol>
<h3 id="hexo-命令介绍"><a class="markdownIt-Anchor" href="#hexo-命令介绍"></a> hexo 命令介绍</h3>
<ol>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000002632530">https://segmentfault.com/a/1190000002632530</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/wsmrzx/article/details/81478103">https://blog.csdn.net/wsmrzx/article/details/81478103</a></li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hzxgoforward.github.io/2019/05/28/%E5%8C%BF%E5%90%8D%E5%B8%81%E5%8C%BF%E5%90%8D%E6%80%A7%E6%AF%94%E8%BE%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌虎下山">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/28/%E5%8C%BF%E5%90%8D%E5%B8%81%E5%8C%BF%E5%90%8D%E6%80%A7%E6%AF%94%E8%BE%83/" class="post-title-link" itemprop="https://hzxgoforward.github.io/index.html">匿名币匿名性比较</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建于：2019-05-28 09:38:07" itemprop="dateCreated datePublished" datetime="2019-05-28T09:38:07+08:00">2019-05-28</time>
            

            
          </span>

          

          
            
          

          
          

          

          


          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hzxgoforward.github.io/2019/04/15/Dash-%E7%A0%94%E7%A9%B6%E8%B5%84%E6%96%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌虎下山">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/15/Dash-%E7%A0%94%E7%A9%B6%E8%B5%84%E6%96%99/" class="post-title-link" itemprop="https://hzxgoforward.github.io/index.html">Dash 研究资料</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建于：2019-04-15 09:17:30" itemprop="dateCreated datePublished" datetime="2019-04-15T09:17:30+08:00">2019-04-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="更新于：2019-11-08 14:57:54" itemprop="dateModified" datetime="2019-11-08T14:57:54+08:00">2019-11-08</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/" itemprop="url" rel="index"><span itemprop="name">区块链技术研究</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          


          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="dash学习资料"><a class="markdownIt-Anchor" href="#dash学习资料"></a> Dash学习资料</h2>
<ul>
<li>
<p><a target="_blank" rel="noopener" href="https://github.com/dashpay/dash/wiki/Whitepaper_zh_cn">github-达世币白皮书</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://github.com/dashpay/dash/wiki/Whitepaper">Dash英文白皮书</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://docs.dash.org/zh_CN/latest/introduction/about.html">达世币-中文帮助文档</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://docs.dash.org/zh_CN/stable/introduction/features.html#privatesend">privateSend(匿名支付)</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://github.com/dashpay/dash">Dash github 源代码</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://dashpay.atlassian.net/wiki/spaces/DOC/pages/1146924/PrivateSend">PrivateSend</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://www.reddit.com/r/dashpay/wiki/index">reddit 上dash的介绍</a></p>
</li>
</ul>
<h2 id="dash-匿名性分析"><a class="markdownIt-Anchor" href="#dash-匿名性分析"></a> Dash 匿名性分析</h2>
<ul>
<li>
<p><a target="_blank" rel="noopener" href="https://bitcoinmagazine.com/articles/battle-privacycoins-why-dash-not-really-private/">Battle of the Privacycoins: Why Dash Is Not Really That Private</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://www.comparitech.com/crypto/anonymous-cryptocurrency-monerto-zcash/">Monero vs Zcash vs Dash: which is the most anonymous cryptocurrency?</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://np.reddit.com/r/dashpay/comments/71rmrc/an_indepth_analysis_of_dash_cryptocurrency_steemit/dneqolr/?context=10000">An in-depth analysis of Dash Cryptocurrency</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://www.reddit.com/r/dashpay/comments/65fz68/dashs_privacy_feature_has_never_been_broken_turns/">privacy-Dash VS Monero</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://www.dash.org/forum/threads/dash-pages-tools-docs-block-explorers-masternodes.8261/">Dash Forum</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://www.reddit.com/r/dashpay/comments/7bu7fn/how_good_is_dashs_privacy_features_compared_to/">Dash VS Monero</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1709.02489.pdf">BlockSCI attack Dash</a></p>
</li>
</ul>
<h2 id="dash的主要特征"><a class="markdownIt-Anchor" href="#dash的主要特征"></a> Dash的主要特征</h2>
<ul>
<li>
<p><strong><a target="_blank" rel="noopener" href="https://www.dash.org/forum/threads/the-birth-of-darkcoin.162/">Launch:</a></strong> Dash was fairly launched under the name “XCoin”, very shortly after renamed “Darkcoin” on Janury 18th, 2014. It rebranded to “Dash” which stands for “Digital Cash” in March of 2015.</p>
</li>
<li>
<p><strong>Limited Supply:</strong> Maximum coin supply of Dash will be somewhere around 18.4 and 19.7 million. It can’t be known for certain because it’s impossible to know how much Dash will be requested from the Treasury each month (more on the “Treasury” below). You can view one possible <a target="_blank" rel="noopener" href="https://docs.google.com/spreadsheets/d/1RpLd87PTs65sz8USrrXwGRoVGVbzaC-nunErEtGSJoE/edit#gid=0">inflation schedule here</a>. Here is a <a target="_blank" rel="noopener" href="https://repl.it/FDPd/8">script developed by a Dash Core Team developer</a> showing inflation until the year 2225. Click “Run” to see it in action.</p>
</li>
<li>
<p><strong>Open Source:</strong> You can read the source code yourself <a target="_blank" rel="noopener" href="https://github.com/dashpay/dash">here</a>.</p>
</li>
<li>
<p><strong>Masternodes:</strong>  Pioneered by Dash. While anyone is able to run a full node and thus support the Dash network, anyone with at least 1,000 Dash (akin to a collateral but impossible to lose during or after operation) is also able to run a Masternode, which offers additional services to the network and earn 45% of the block reward. The Masternode count over time is shown in <a target="_blank" rel="noopener" href="http://178.254.23.111/~pub/masternode_count.png">this graph</a>. Masternode operators are also granted one vote per node (see below).</p>
</li>
<li>
<p><strong>Decentralized Governance by Blockchain:</strong> Dash pioneered a blockchain governance system that is utilized for quick decision making in the project. Dash settled <a target="_blank" rel="noopener" href="https://www.dashcentral.org/p/2mb-blocksize">a debate on the size of its blocks</a> in less than 24 hours. The same debate that has been going on in Bitcoin for several years. Dash is the first project that invented, developed and actively uses a blockchain based governance directed by “shareholders” with “skin in the game” (Masternode operators) looking out for their own and thus the network’s best interests.</p>
</li>
<li>
<p><strong>The Dash Treasury &amp; proposal grants:</strong> Each month Masternode operators <a target="_blank" rel="noopener" href="https://dashcentral.org/">vote on budget proposals</a> that aim to produce value for Dash as a whole. <a target="_blank" rel="noopener" href="http://dashvotetracker.com/">Anyone can make a proposal, ask the Masternode electorate for a grant in Dash and receive funding directly from the Dash blockchain.</a></p>
</li>
<li>
<p><strong>Self-sustainable development:</strong> The current Dash development team is <a target="_blank" rel="noopener" href="https://www.dashcentral.org/p/core-team">paid directly from the blockchain</a>, a novel approach that was pioneered by Evan Duffield, the creator of Dash, and has since then been copied by dozens of other projects in one way or another. Note that the Core Team could theoretically be voted out of a funding anytime, maintaining decentralization of the project unlike in other cryptocurrency projects.</p>
</li>
<li>
<p><strong>InstantSend:</strong> Another first invented by Dash. This technology allows Dash to be used in point-of-sale situations where a locked payment is sent in about 1 second, while not being exposed to double spends that other cryptos are susceptible to. For many this is Dash’s “killer feature” because InstantSend makes Dash the first cryptocurrency fully suitable for use in brick and mortar businesses.</p>
</li>
<li>
<p><strong>PrivateSend</strong> is the feature that gives Dash users the ability to erase the transactional history of received coins and thus send funds anonymously. Originally based on the CoinJoin-principle by Gregory Maxwell but heavily modified with mixing ahead of the spending transaction and other major improvements, avoiding the well known &amp; fatal flaws of CoinJoin.</p>
</li>
<li>
<p><strong>Fungibility</strong> is the result of offering PrivateSend mixing on the network. Erasing the history of each Dash transaction before you spend it makes your Dash just as valuable as freshly minted coins. No more tainted funds.</p>
</li>
<li>
<p><strong>Dash-Evolution:</strong> This is the <a target="_blank" rel="noopener" href="https://www.dash.org/evolution/">next generation of Dash.</a> It will make Dash the most user-friendly cryptocurrency in the world. So user-friendly that even your grandmother could use it! <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=7J4m04Tkfb4">Check out the Demo!</a></p>
</li>
<li>
<p>A very clear vision of the future via on-chain scaling: The <a target="_blank" rel="noopener" href="https://github.com/dashpay/dash-roadmap/blob/master/README.md">current Dash roadmap</a> details the path to Evolution. Founder Evan Duffield also put out two manifesto articles elaborating on <a target="_blank" rel="noopener" href="https://hackernoon.com/hong-kong-research-and-planning-4206e065aa9c">what Dash wants to achieve</a> and <a target="_blank" rel="noopener" href="https://medium.com/@eduffield222/how-to-enabling-on-chain-scaling-2ffab5997f8b">how to get there</a>.</p>
</li>
</ul>
<h2 id="dash-blaock-explorers"><a class="markdownIt-Anchor" href="#dash-blaock-explorers"></a> Dash Blaock Explorers</h2>
<ul>
<li>
<p><a target="_blank" rel="noopener" href="http://explorer.dash.org/">Official Dash.org Block Explorer</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://chainz.cryptoid.info/dash/">Block Explorer by Cryptoid</a></p>
</li>
<li></li>
</ul>
<h2 id="dashs-network"><a class="markdownIt-Anchor" href="#dashs-network"></a> Dash’s network</h2>
<p>There are two main tiers in Dash, the miners and the master nodes. The Miners carry out similar functions to those in the bitcoin network. <strong>The master nodes are responsible for governance functions and for carrying out special transactions- InstantSend and PrivateSend.</strong></p>
<p><strong>InstantSend</strong> enables near-instantaneous transactions and is claimed to prevent double-spending, a potential problem with other cryptocurrencies. Regular block times are two and a half minutes whereas InstantSend transactions can be processed in under a second.</p>
<p>Decentralized Governance by Blockchain(DGBB), Dash attempt to solve two problems: governance and funding.</p>
<ul>
<li>
<p><strong>Governance</strong></p>
</li>
<li>
<p>The DGBB system allows each masternode to vote once for each proposal. This is a bit like block producer(BP) in EOS. If a proposal passes, it can then be implemented by Dash’s developers.</p>
</li>
<li>
<p><strong>Funding</strong></p>
</li>
<li>
<p>DGBB provides a means for Dash to fund its own development.<br />
The network funds itself by reserving 10% of the block reward for budget projects.</p>
</li>
</ul>
<h2 id="masternode"><a class="markdownIt-Anchor" href="#masternode"></a> MasterNode</h2>
<ul>
<li>
<p><a target="_blank" rel="noopener" href="http://178.254.23.111/~pub/Darkcoin/masternode_ISPs.html">Distribution of 4765 Dash Masternodes (Summary by ISP)</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="http://178.254.23.111/~pub/Darkcoin/masternode_locations_stats.html">Distribution of 4765 Dash Masternodes V3<br />
(Summary by Country)</a></p>
</li>
</ul>
<p>Masternodes are dedicated servers on the internet that enable instant transactions and perform the trustless anonymization of users’ funds. Further they’re the backbone of Dash’s governance model and the foundation of coming features in “Dash Evolution”. Masternodes require 1,000 Dash as “collateral” (you can’t lose the Dash, only its value), a secured server, a full-time Internet connection, and periodic updates. In return they receive 45% of the block reward which at current rates and number of nodes amounts to 1.8 Dash every 6-7 days.</p>
<h3 id="random-choose-masternode"><a class="markdownIt-Anchor" href="#random-choose-masternode"></a> Random Choose Masternode</h3>
<p>A special deterministic algorithm is used to create a pseudo-random ordering of the masternodes. The pseudocode of selecting a masternode:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">auto</span>&amp; masternode : masternodes)&#123;</span><br><span class="line">    current_score = masternode.<span class="built_in">CalculateScore</span>();</span><br><span class="line">    wining_node = masternode;</span><br><span class="line">&#125;</span><br><span class="line">CMasterNode::<span class="built_in">CalculateScore</span>()&#123;</span><br><span class="line">  pow_hash = <span class="built_in">GetProofOfWorkHash</span>(nBlockHeight);<span class="comment">// get the hash of this block</span></span><br><span class="line">  pow_hash_hash = <span class="built_in">hash</span>(pow_hash);<span class="comment">// hash the POW hash to increase the entropy</span></span><br><span class="line">  difference = <span class="built_in">abs</span>(pow_hash_hash - masternode_vin);</span><br><span class="line">  <span class="keyword">return</span> difference;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="function-of-masternode"><a class="markdownIt-Anchor" href="#function-of-masternode"></a> Function of Masternode</h2>
<h3 id="1-trustless-quorums"><a class="markdownIt-Anchor" href="#1-trustless-quorums"></a> 1. Trustless Quorums</h3>
<p>With the addition of the masternode network and the collateral requirements, we can use this secondary network to do highly sensitive tasks in a trustless way, where no single entity can control the outcome. By selecting N pseudo random masternodes from the total pool to perform the same task, these nodes can act as an oracle, without having the whole network do the task.</p>
<p>As an example, implementation of a trustless quorum , which uses quorums to approve transactions and lock the inputs or the proof-of-service implementation.</p>
<p>Another example use for trustless quorums can include utilizing the masternode network as a decentralized oracle for financial markets, making secure decentralized contracts a possibility.</p>
<h3 id="2-proo-of-service"><a class="markdownIt-Anchor" href="#2-proo-of-service"></a> 2. Proo-Of-Service</h3>
<p>To reduce the possibility of people using the system to their advantage nodes must ping the rest of the network to ensure they remain active. This work is done by the masternode network by selecting 2 quorums per block. Quorum A checks the service of Quorum B each block. Quorum A are the closest nodes to the current block hash, while Quorum B are the furthest nodes from said hash.</p>
<h2 id="block-reward"><a class="markdownIt-Anchor" href="#block-reward"></a> Block-Reward</h2>
<ul>
<li>
<p>45% of block rewards go to miners.</p>
</li>
<li>
<p>45% of block rewards go to masternodes.</p>
</li>
<li>
<p>10% of block rewards go to the Decentralized Governance Budget.</p>
</li>
</ul>
<h2 id="masternodes-vs-mining"><a class="markdownIt-Anchor" href="#masternodes-vs-mining"></a> Masternodes vs mining</h2>
<ul>
<li>
<p><strong>masternodes</strong> powers the second tier, which enable financial privacy(PrivateSend), instant transactions(instantSend), and the decentralized governance and budget system. Since the masternodes carry out a great function, 45% of block reward goes to masternodes.</p>
</li>
<li>
<p><strong>masternodes</strong> have the power to reject improperly formed blocks from miners, if a miner tried to take the entire block reward for themselves or tried to run an old version of the Dash software, the masternode network would orphan that block.</p>
</li>
<li>
<p><strong>masternodes</strong> do not mine. each masternode is “secured” by 1000 DASH. Those Dash remain under the sole control of their owner at all times, and can still be freely spent. the funds are not locked in any way. <strong>if the funds are moved or spent, the associated masternode will go offline and stop receiving rewards.</strong></p>
</li>
<li>
<p><strong>Miners</strong> powers the first tier, which is the basic sending and receiving of funds and prevention of doublespending.</p>
</li>
<li>
<p><strong>Miners</strong> do not serve as masternodes.</p>
</li>
</ul>
<h2 id="privatesend"><a class="markdownIt-Anchor" href="#privatesend"></a> PrivateSend</h2>
<p>PrivateSend is an implementation of <strong>CoinJoin</strong>. The privacy solution first proposed for Bitcoin by <a target="_blank" rel="noopener" href="https://bitcoincore.org/">Bitcoin Core</a> developer Gregory Maxwell. In PrivateSend, three users add their coins together in one big transaction, that sends the coins to freshly generated addresses belonging to the same three users. As such, the coins are effectively mixed between the three participants, breaking the blockchain trail of ownership between them. This process can be automatically repeated up to 16 times, with different mixing participants, for extra privacy.</p>
<p>PrivateSend is done by <strong>masternodes</strong>.</p>
<p>The step of PrivateSend is following:</p>
<ol>
<li>
<p>Breakingdown a user’s transaction input into discrete denominations, with these denominations being: 0.01 DASH, 0.1 DASH, 1 DASH and 10 DASH.</p>
</li>
<li>
<p>A user’s Dash wallet will initiate a request to a Dash masternode, the masternode made aware that a user would like to mix a certain denomination of Dash coins. No identifiable information is sent to the masternodes, so they do not know who you are.</p>
</li>
<li>
<p>The masternode then issue a message to the network indicating that is ready to mix a denomination, and there is a users waiting.</p>
</li>
<li>
<p>Two other individuals who also wish to mix the same denomination of Dash coins can connect to the masternode that is hosting the other user’s transaction.</p>
</li>
<li>
<p>Start a mixing session, the masternode mixes up the inputs and instructs all three users’ wallets to pay the now-mixed input back to themselves.</p>
</li>
<li>
<p>A user’s wallet must repeat this mixing session multiple times(each time is called a round) to ensure that fund origins are fully anonymized.</p>
</li>
</ol>
<ul>
<li>
<p><strong>NOTE 1:</strong> Funds involved in the mixing process never leaves a user’s wallet, ensuring the entire process can remain trustless and secure.</p>
</li>
<li>
<p><strong>NOTE 2:</strong> Your wallet only contains 1000 of these “change addresses”. Every time a mixing event happens, one of your addresses is used up. Once enough of themn are used, your wallet must create more addresses. It can only do this, however, if you have automatic backups enabled. Consequently, users who have backups disabled will also have PrivateSend disabled.</p>
</li>
<li>
<p><strong>NOTE 3:</strong> To address DOS attacks, Dash developers propose all user submit a transaction as collateral to the pool when joining. When a user submits a request to the mixing pool, they must provide collateral at the beginging of this exchange. if at any point any user fails to cooperate, by refusing to sign for example, the collateral transaction will be broadcast automatically. This will make it expensive to carry out a sustained attack on the privacy network.</p>
</li>
<li>
<p><strong>NOTE 4</strong>: As of April 2019, PrivateSend is  available in Desktop(Dash Core, Dash Electrum)/Mobile(Dash Electurm)/Web(MyDashWallet) wallets.</p>
</li>
</ul>
<p>An example of <a target="_blank" rel="noopener" href="https://chainz.cryptoid.info/dash/tx.dws?4679460.htm">PrivateSend</a></p>
<h3 id="privatesend-security-considerations"><a class="markdownIt-Anchor" href="#privatesend-security-considerations"></a> PrivateSend Security Considerations</h3>
<p>as transactions are merged, masternodes can possibly “snoop” on users funds as they pass through. This is not considered a serious limitation due to the requirement for masternode’s to hold 1000 DASH, on the other hand, users utilize random masternodes to host their joins, so the probability of following a transaction throughout a chaining event can be calculated as follows:</p>
<table>
<thead>
<tr>
<th>Attacker Controlled Masternodes / Total Masternodes</th>
<th>Depth Of The Chain</th>
<th>Probability of success <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mi>t</mi><msup><mo stretchy="false">)</mo><mi>r</mi></msup></mrow><annotation encoding="application/x-tex">(n/t)^r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord">/</span><span class="mord mathnormal">t</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span></span></span></span></th>
<th>DASH Required</th>
</tr>
</thead>
<tbody>
<tr>
<td>10/1010</td>
<td>2</td>
<td>9.80e-05</td>
<td>10,000DASH</td>
</tr>
<tr>
<td>10/1010</td>
<td>4</td>
<td>9.60e-09</td>
<td>10,000DASH</td>
</tr>
<tr>
<td>10/1010</td>
<td>8</td>
<td>9.51e-11</td>
<td>10,000DASH</td>
</tr>
<tr>
<td>100/1100</td>
<td>2</td>
<td>8.26e-03</td>
<td>100,000DASH</td>
</tr>
<tr>
<td>100/1100</td>
<td>4</td>
<td>6.83e-05</td>
<td>100,000DASH</td>
</tr>
<tr>
<td>100/1100</td>
<td>8</td>
<td>4.66e-09</td>
<td>100,000DASH</td>
</tr>
<tr>
<td>1000/2000</td>
<td>2</td>
<td>25%</td>
<td>1,000,000DASH</td>
</tr>
<tr>
<td>1000/2000</td>
<td>4</td>
<td>6.25%</td>
<td>1,000,000DASH</td>
</tr>
<tr>
<td>1000/2000</td>
<td>8</td>
<td>0.39%</td>
<td>1,000,000DASH</td>
</tr>
<tr>
<td>2000/3000</td>
<td>2</td>
<td>44.4%</td>
<td>2,000,000DASH</td>
</tr>
<tr>
<td>2000/3000</td>
<td>4</td>
<td>19.75%</td>
<td>2,000,000DASH</td>
</tr>
<tr>
<td>2000/3000</td>
<td>8</td>
<td>3.90%</td>
<td>2,000,000DASH</td>
</tr>
</tbody>
</table>
<p>Where:</p>
<ul>
<li>
<p>n is the total number of nodes controlled by the attacker.</p>
</li>
<li>
<p>t is the total number of masternodes in the network.</p>
</li>
<li>
<p>r is the depth of the chain.</p>
</li>
</ul>
<h3 id="blinding-masternodes"><a class="markdownIt-Anchor" href="#blinding-masternodes"></a> Blinding Masternodes</h3>
<p>Alough the probability of masternodes to snoop the user’s join is low, but the security problems still exists. This potential danger can be addressed by blinding masternodes so they cannot see which inputs/outputs belong to which users.</p>
<ul>
<li>
<p><strong>relay system</strong></p>
<p>Dash uses relay system to protect user’s identity. Instead of a user submitting the inputs and outputs directly into the pool, they will pick a random masternode from the network and request that it relays the inputs/outpus/signatures to the target masternode. This means that the masternode will receive N sets of inputs/outputs/ and N sets of signatures. Each set belong to one of the users, but the masternode can’t know which belongs to which.</p>
</li>
</ul>
<h2 id="dash-wallet"><a class="markdownIt-Anchor" href="#dash-wallet"></a> Dash Wallet</h2>
<p>There are many wallet that support dash, details are in <a target="_blank" rel="noopener" href="https://www.dash.org/downloads/">here.</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hzxgoforward.github.io/2019/04/10/An%20Empirical%20Analysis%20of%20Traceability%20in%20the%20Monero%20Blockchain/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌虎下山">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/10/An%20Empirical%20Analysis%20of%20Traceability%20in%20the%20Monero%20Blockchain/" class="post-title-link" itemprop="https://hzxgoforward.github.io/index.html">An Empirical Analysis of Traceability in the Monero Blockchain</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建于：2019-04-10 18:56:14" itemprop="dateCreated datePublished" datetime="2019-04-10T18:56:14+08:00">2019-04-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="更新于：2019-11-08 14:56:52" itemprop="dateModified" datetime="2019-11-08T14:56:52+08:00">2019-11-08</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/" itemprop="url" rel="index"><span itemprop="name">区块链技术研究</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          


          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="abstract"><a class="markdownIt-Anchor" href="#abstract"></a> Abstract</h2>
<p>This paper empirically evaluate <strong>two weakness</strong> in Monero’s mixin sampling strategy.</p>
<ul>
<li>About 62% of transaction inputs with one or more mixins are vulnerable to cascade effect so that the real input can be duduced by elimination</li>
<li>Monero mixins are sampled in a way that mixins can be easily distinguished form the real input by their age distribution. Since the real input is always the newest input.</li>
</ul>
<p>The author use the 2th weakness to guess real input with a 80% accuracy over all transactions with one or more mixins.</p>
<p>Besides, the author study the importance of mining pools and the former anonymous marketplace AlphaBay on the transaction volume. After removing mining pool activity, there remains a largte amount of potentially privacy-sensitive transactions that are affected by these weakness.</p>
<p>To improve the anonymity of Monero, the author gives two contermeasures.</p>
<ul>
<li>A new mixins sampling method with two-parameter model (gama distribution)is proposed which can well approximate the user’s ‘spend-time’ distribution.</li>
<li>Sampling mixins in ‘bins’, this method regardless of sampling distribution.</li>
</ul>
<h2 id="deducible-monero-transactions"><a class="markdownIt-Anchor" href="#deducible-monero-transactions"></a> Deducible Monero Transactions</h2>
<p>A significant number of Monero transactions do not contain any mixins at all, but instead explicityly identify the real TXO being spent. Since users are allowed to create zero-mixins transactions at the begining of Monero. These zero-mixins transaction present a hazard of deanonymization of transactions include them as mixins.</p>
<p>At the time of April 15, 2017, a total of 12158814 transaction inputs have zero mixins.Figure 5 presents the fraction of transactions containing zero-mixin inputs over time.<br />
<img src="https://img-blog.csdnimg.cn/2019041009332043.png" alt="在这里插入图片描述" /></p>
<h3 id="implemention"><a class="markdownIt-Anchor" href="#implemention"></a> implemention</h3>
<p>The author extract Monero blackchain up to block 128774(April 15, 2017) and<br />
stored it in a Neo4j graph database (11.5GB of data in total). the algorithm is the same as cascade effect(Amrit Kumar, Clément Fischer, Shruti Tople, and Prateek Saxena. A traceability analysis of Monero’s blockchain. In Simon N. Foley, Dieter Gollmann, and Einar Snekkenes, editors, Computer Security – ESORICS 2017: 22nd European Symposium on Research in Computer Security, Oslo, Norway, September 11-15, 2017, Proceedings, Part II, pages 153–173. Springer International Publishing, 2017.)</p>
<h3 id="results-on-deducible-transactions"><a class="markdownIt-Anchor" href="#results-on-deducible-transactions"></a> Results on Deducible Transactions</h3>
<p>Table 2 presents the results, totaly there are about 63% Monero transaction inputs with more than one mixins were deduced.</p>
<p><img src="https://img-blog.csdnimg.cn/20190410094354625.png" alt="在这里插入图片描述" /><br />
Figure 6 show the amount of vulnerable Monero transactions with the number of mixins, and it also shows transaction is less likely to be deducible with more mixins.<br />
<img src="https://img-blog.csdnimg.cn/20190410094947234.png" alt="在这里插入图片描述" /></p>
<h2 id="tracing-with-temporal-analysis"><a class="markdownIt-Anchor" href="#tracing-with-temporal-analysis"></a> Tracing With Temporal Analysis</h2>
<h3 id="effective-untracebility"><a class="markdownIt-Anchor" href="#effective-untracebility"></a> Effective-Untracebility</h3>
<p>To quantify the untraceability of a transaction input, the authors used <strong>guessing entropy</strong> to represent the expected number of gusses before guessing the real spent among a inputs. The transaction input’s guessing entropy is defined as</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mi mathvariant="normal">G</mi><mi mathvariant="normal">e</mi></mrow><mo>=</mo><munder><mo>∑</mo><mrow><mn>0</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>M</mi></mrow></munder><mi>i</mi><mo>⋅</mo><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\mathrm{Ge}=\sum_{0 \leq i \leq M} i \cdot p_{i}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathrm">G</span><span class="mord mathrm">e</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.43952em;vertical-align:-1.389515em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8556639999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mrel mtight">≤</span><span class="mord mathnormal mtight">i</span><span class="mrel mtight">≤</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.389515em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>where Ge is guessing entropy,  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><msub><mi>p</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>p</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>p</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">p = p_0, p_1, . . . , p_M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> are probabilities, sorted highest to lowest, that a <strong>referenced output</strong> is the real spend of a transaction input.</p>
<p>The authors define <strong>effective-untraceability</strong> as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mn>2</mn><mi>G</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">1+2Ge</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathnormal">G</span><span class="mord mathnormal">e</span></span></span></span>.  if all referenced outputs of a transaction input are equally likely to be the real sepend, the effective-untraceabilty for that inputs is M+1.</p>
<h2 id="the-guess-newest-heuristic"><a class="markdownIt-Anchor" href="#the-guess-newest-heuristic"></a> The Guess-Newest Heuristic</h2>
<p>The author proposed a heustric that among all the prior outpus referenced by a Monero transaction input, the real spend is usually the newest one. That point view came from the Figure 2.<br />
<img src="https://img-blog.csdnimg.cn/2019041010321024.png" alt="在这里插入图片描述" /><br />
The conclusion came from zero-mixin inputs and inputs deduced from zero-mixin inputs. The mixin’s spending time is quite different with the real input.This is because users spend coins soon after receiving them while the mixin’s sampling method do not take account of user’s spending behaviours.</p>
<p>The authors found the 92% of the deducible inputs coule be gussed correctly in that way. The result is in Table 3.<br />
<img src="https://img-blog.csdnimg.cn/20190410110645176.png" alt="在这里插入图片描述" /></p>
<h2 id="countermeasures"><a class="markdownIt-Anchor" href="#countermeasures"></a> Countermeasures</h2>
<ol>
<li><strong>Improve the mixin-sampling procedure to match the real spend-time of MOnero users.</strong></li>
<li><strong>introduce a countermeasure called binned mixin sampling which modifies the current mixin sampling procedure.</strong></li>
</ol>
<h3 id="estimating-the-spend-time-distribution"><a class="markdownIt-Anchor" href="#estimating-the-spend-time-distribution"></a> Estimating the spend-time distribution</h3>
<p>Following Figure shows the CDF of Bitcoin blockchain and Monero blockchain.<br />
<img src="https://img-blog.csdnimg.cn/20190410162056147.png" alt="在这里插入图片描述" /><br />
The Bitcoin spend-time have a somewhat similar shape with Monero spend-time.The authors use R’s fitdistr function to fit a gama distribution(shape parameter19.28, rate parameter 1.61)</p>
<h3 id="sampling-mixins-using-the-spend-time-distribution"><a class="markdownIt-Anchor" href="#sampling-mixins-using-the-spend-time-distribution"></a> Sampling mixins using the spend-time distribution</h3>
<p>using the distribution above to sample mixins to matches the ideal spend-time. The author’s method is:</p>
<pre><code>1. sample a target timestamp directly from the distribution
2. Find the nearest block containing at least one RingCT output.
3. sample uniformly among the transaction outputs in that block
</code></pre>
<p>A more detail Algorithm is following<br />
<img src="https://img-blog.csdnimg.cn/20190410162826490.png" alt="在这里插入图片描述" /></p>
<h3 id="monte-carlo-simulation"><a class="markdownIt-Anchor" href="#monte-carlo-simulation"></a> Monte Carlo Simulation</h3>
<p>Following Figure shows the effective untraceability set under the current regime and the author’s proposed mixin sampling routine, the effective-untraceability set has significant increased.method performs slightly worse than ideal at 6 and 12 months out, although still much better than the current method, and stays within 75% of the ideal<br />
<img src="https://img-blog.csdnimg.cn/20190410163723319.png" alt="在这里插入图片描述" /></p>
<ul>
<li>Preserve some untraceability even in the face of a highly compromised mixin sampling distribution.</li>
</ul>
<h3 id="binned-mixin-sampling"><a class="markdownIt-Anchor" href="#binned-mixin-sampling"></a> Binned mixin sampling</h3>
<p>Group outputs in the Monero blockchain into sets of some fixed size called bins such that ecah output in a bin is confirmed in the same block or a neighboring block as Figure 13.</p>
<p><img src="https://img-blog.csdnimg.cn/20190410164656232.png" alt="在这里插入图片描述" /><br />
Any transaction input referencing a transaction output in a bin, either as a mixin or spend, must also reference all other outputs in that bin. Thus, a real spend cannot be distinguished by age from the other mixin outputs in the bin. Additionally, binned mixin sampling ensures that all the outputs in a bin cannot be deduced as spent until the last unspent output in the bin is spent, preventing deduction attacks from reducing the effectiveuntraceability of an output to less than the bin size.</p>
<p>Sample Algorithm is showed in Algorithm 2.<br />
<img src="https://img-blog.csdnimg.cn/20190410184941659.png" alt="在这里插入图片描述" /></p>
<h2 id="recommendations"><a class="markdownIt-Anchor" href="#recommendations"></a> Recommendations</h2>
<ul>
<li>The mixing sampling distribution should be modified to closer match the real distribution.</li>
<li>Avoid including publicly deanonymized transaction outputs as mixins</li>
<li>Monero users should be warned that their prior transactions are likely vulnerable to tracing analysis<br />
The aothor launched a block explorer(<a target="_blank" rel="noopener" href="https://monerolink.com">https://monerolink.com</a>), which displays the linkages between transactions infered using our techniques, they recommend additionally developing a wallet tool that users can run locally to determine wheter their previous transactions are vulnerable.</li>
</ul>
<h2 id="thinking"><a class="markdownIt-Anchor" href="#thinking"></a> Thinking</h2>
<p>There is some points in this paper:</p>
<ul>
<li>
<p>Since zero-mixins result in a short transaction and spend less fees, so the user choose to choose zero-mixins, but the author ignores if it is because there are not enough same denominations?  But the paper [A Traceability Analysis of Monero’s Blockchain] (<a target="_blank" rel="noopener" href="https://blog.csdn.net/t46414704152abc/article/details/89175204">https://blog.csdn.net/t46414704152abc/article/details/89175204</a>) presents a rigorious analysis.</p>
</li>
<li>
<p>The author said new transactions are immune is not because of the RingCT mechanism itself, rater because RingCTs was deployed after the mandatory 2-mixin was enforced. I came up with a doublt, why? but the author didn’t tell us the analysis support.</p>
</li>
<li>
<p>May be next time, we should analyse the untraceability of RingCTs.</p>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hzxgoforward.github.io/2019/04/08/A%20Traceability%20Analysis%20of%20Monero%E2%80%99s%20Blockchain/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌虎下山">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/08/A%20Traceability%20Analysis%20of%20Monero%E2%80%99s%20Blockchain/" class="post-title-link" itemprop="https://hzxgoforward.github.io/index.html">A Traceability Analysis of Monero’s Blockchain</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建于：2019-04-08 22:30:00" itemprop="dateCreated datePublished" datetime="2019-04-08T22:30:00+08:00">2019-04-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="更新于：2023-03-03 15:29:47" itemprop="dateModified" datetime="2023-03-03T15:29:47+08:00">2023-03-03</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/" itemprop="url" rel="index"><span itemprop="name">区块链技术研究</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          


          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="abstract"><a class="markdownIt-Anchor" href="#abstract"></a> Abstract</h2>
<p>Monero 以相比于Bitcoin而言更加具有匿名性，在本文中作者使用了3中启发式的方法对Monero 区块链中的交易进行分析，虽然Monero中使用了mix-in方式，实际上其中87%的交易地址仍然是可以被追踪的；再新的Monero版本中采用了RingCTs，但是启发式方法仍然有效。在这些可以被追踪的交易中，其中98%的交易中使用的mix-in地址都是最近新产生的output地址，作者使用了Monero用户的消费习惯并对交易分析，实际分析结果表明Monero中以triangle distribution选择mix-in输入的方法对提升交易追踪难度作用不大。<br />
在对Monero进行分析之前，首先对Monero区块链进行了分析，其中发现如下3个重要信息：</p>
<ul>
<li>超过65%的交易输出，没有采用mix-in，也就是说这些交易本身是可追踪的。Monero中将可追踪的交易做mix-in，顺藤摸瓜可以追踪其他交易，作者以此65%为基础，顺藤摸瓜追踪到了另外22%的交易地址。</li>
<li>启发式方法二：一些minx-in中使用了某笔交易中的多个输出，这多个输出很有可能来自于同一人。以non-RingCTs的Monero区块链中87%的交易地址验证该启发式方法，真阳率为95%，鉴于此，推断出该方法仍然适用于RingCTs中的地址。</li>
<li>启发式方法三：Monero区块链中的UTXO，存在的时间越久，被花费的概率越大。仍然以non-RingCTs的Monero区块链中87%的交易地址验证该启发式方法，真阳率为98.5%，推断出该方法仍然适用于RingCTs区块链中。</li>
</ul>
<h2 id="monero"><a class="markdownIt-Anchor" href="#monero"></a> Monero</h2>
<p>Monero(XMR) 于2014年4月18日上线，当前出块时间为120秒，使用CryptoNote进行挖矿，每个区块奖励不定，，目前Monero价格为67美元。<br />
Monero提升用户匿名性上，使用了autonomous和spontaneous的协议，在Monero中用户在交易过程中可以自发的进行混币，混币本身并不增加额外的时间延迟。Monero主要解决了两个问题：</p>
<ul>
<li>（1）	Unlinkability，对于任意两笔交易，无法证明这两笔交易是转发给同一个人。</li>
<li>（2）	Untraceability，对于一笔交易中的输入，对应的赎回output应该隐藏在多个output中。</li>
</ul>
<p>对于Unlinkability，Monero中使用了one-time random address。每次进行交易时，发送方为接收方产生一个一次性的随机接收地址，而只有接收方才能花费接收地址中数字货币。这样的前提是每次产生接收地址时都有一个好的随机源，同时每个接收地址只使用一次。这就是Monero中的 <strong>Ring Signature</strong>。发送者（也是签名者）代表一组其他用户匿名签署交易（消息）。被赎回的实际输出在属于其他用户的选定输出集合中保持匿名。<br />
2015年~2016年期间，Monero币价涨了将近27倍，到了2017年，Monero又采用了Ring Confidential Transaction(RingCTs)以提升其隐私性（隐藏交易真正的输出地址）。在RingCTs中隐藏了交易额。</p>
<h3 id="monero-system-parameter"><a class="markdownIt-Anchor" href="#monero-system-parameter"></a> Monero System Parameter</h3>
<p>Monero中采用了Ed25519 椭圆加密算法,在该加密算法中。Monero中的每个用户都有一个长期的公钥对和私钥对，记为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>p</mi><msubsup><mi>k</mi><mrow><mi>L</mi><mi>T</mi></mrow><mrow><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi></mrow></msubsup><mo separator="true">,</mo><mi>s</mi><msubsup><mi>k</mi><mrow><mi>L</mi><mi>T</mi></mrow><mrow><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi></mrow></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(pk_{ LT }^{ user }, sk_{ LT }^{ user })</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.025331em;vertical-align:-0.275331em;"></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.424669em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.275331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">s</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.424669em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.275331em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中公钥对是可以公开的，公钥对用于接收转账，私钥对用于发送转账，它们关系如下：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><msubsup><mi>k</mi><mrow><mi>L</mi><mi>T</mi></mrow><mrow><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi></mrow></msubsup><mo>=</mo><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">sk_{ LT }^{ user } = (a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9697709999999999em;vertical-align:-0.275331em;"></span><span class="mord mathnormal">s</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.424669em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.275331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>， 范围是[1, L-1], L是椭圆曲线上某个点G的素数阶。</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><msubsup><mi>k</mi><mrow><mi>L</mi><mi>T</mi></mrow><mrow><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi></mrow></msubsup><mo>=</mo><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">pk_{ LT }^{ user } = (A, B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9697709999999999em;vertical-align:-0.275331em;"></span><span class="mord mathnormal">p</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.424669em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.275331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span>, 其中A = aG， B= bG，其中<strong>G是标准的Ed25519基点</strong>。</li>
</ul>
<h3 id="ensuring-unlinkability"><a class="markdownIt-Anchor" href="#ensuring-unlinkability"></a> Ensuring Unlinkability</h3>
<p>Monero中发送方用接收方的公钥对随机产生一个一次性地址，然后将XMR发送至这个一次性地址，而只有接收方能够花费一次性地址中的XMR。假定发送方是Alice，接收方是Bob，Alice产生一次性地址的过程如下：</p>
<ul>
<li>获取Bob的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><msubsup><mi>k</mi><mrow><mi>L</mi><mi>T</mi></mrow><mrow><mi>B</mi><mi>o</mi><mi>b</mi></mrow></msubsup><mo>=</mo><mtext>（</mtext><mi>A</mi><mtext>，</mtext><mi>B</mi><mtext>）</mtext></mrow><annotation encoding="application/x-tex">pk_{ LT }^{ Bob } = （A， B）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.124439em;vertical-align:-0.275331em;"></span><span class="mord mathnormal">p</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.424669em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.275331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">（</span><span class="mord mathnormal">A</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord cjk_fallback">）</span></span></span></span></li>
<li>随机产生一个r，r∈[1, L-1]</li>
<li>令R = rG， P = hash(rA)G+B</li>
<li>Bob的接收地址是P<br />
由于P = hash(rA)G+B, 根据B的公钥对和私钥对的关系(A = aG, B = bG),同时R =rG，替换P的表达式，得到：</li>
<li><strong>P= hash(raG)G+bG = G(hash(aR)+b) = sG</strong><br />
而Alice转账给Bob的地址，Bob通过自己私钥中的(a, b)和R计算，因此只有Bob知道Alice环形签名中众多地址中真正转账给Bob的地址。<strong>在这笔转账中，除了Alice和Bob之外，没有人能知道真正转账给Bob的地址，这保证了Monero中交易的Unlinkability。</strong><br />
如果需要多个output，可以随机出多个接收转账的地址，每个交易的输出只能被相应的一次性随即地址识别出来。在Monero中，每次转账的输出地址是一次性的公钥，记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><msub><mi>k</mi><mrow><mi>O</mi><mi>T</mi></mrow></msub></mrow><annotation encoding="application/x-tex">pk_{ OT }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。对应的私钥记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><msub><mi>k</mi><mi>O</mi></msub><mi>T</mi></mrow><annotation encoding="application/x-tex">{ sk_OT }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span></span>，它们的关系记为P = sG。</li>
</ul>
<h3 id="ensuring-untraceability"><a class="markdownIt-Anchor" href="#ensuring-untraceability"></a> Ensuring Untraceability</h3>
<p>Monero中的不可追踪性是通过ring signatures(环形签名)实现的。环形签名使得用户可以在若干名用户形成的环上对消息进行签名。签名的用户只需要知道自己的私钥，签名后用户将其他用户的公钥放到环上。对于矿工或者接收方来说，他们只知道真正的签名者是环中的一员，但是无法确认是哪一个，发送方通过环签名的方法实现匿名。仍然以Alice 发送给Bob10 XMR为例说明环形签名的过程。</p>
<ul>
<li>Bob的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><msubsup><mi>k</mi><mrow><mi>L</mi><mi>T</mi></mrow><mrow><mi>B</mi><mi>o</mi><mi>b</mi></mrow></msubsup><mo>=</mo><mtext>（</mtext><mi>A</mi><mtext>，</mtext><mi>B</mi><mtext>）</mtext></mrow><annotation encoding="application/x-tex">pk_{ LT }^{ Bob } = （A， B）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.124439em;vertical-align:-0.275331em;"></span><span class="mord mathnormal">p</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.424669em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.275331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">（</span><span class="mord mathnormal">A</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord cjk_fallback">）</span></span></span></span>，然后随机产生发送地址P_Bob</li>
<li>Alice选取Monero链上其他一些价值为10 XMR的output$(P_1，P_2,…))</li>
<li>令<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 25: …1，P_2，…P_m\ }  }̲'>S={ \{ P_1，P_2，…P_m\ }  }</span>,其中包括Alice自己的input <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>t</mi></msub><mo>=</mo><msub><mi>s</mi><mi>t</mi></msub><mi>G</mi></mrow><annotation encoding="application/x-tex">P_t = s_t G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">G</span></span></span></span><br />
Alice的input混合在其他价值为10的output中达到匿名的目的，而S称之为匿名集。Alcie使用自己的私钥s_t对消息进行签名。对于矿工和Bob来说，他们无法判断Alice这笔转账的支出来源地址，这就使得这笔转账的input具有了匿名性。S中其他用户的公钥称之为mix-ins，mix-ins越大，匿名性越好。</li>
</ul>
<h3 id="resist-double-spending"><a class="markdownIt-Anchor" href="#resist-double-spending"></a> Resist Double Spending</h3>
<p>上述Alice给Bob的转账中，既然无法确定Alice具体转账的input地址，对于矿工来说，无法知道Alice是否会进行double spending。为了解决该问题，Monero中引入了key image（ζ）机制，即Alice的交易中需要提供一个key image，即:</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ζ</mi><mo>=</mo><msub><mi>s</mi><mi>t</mi></msub><mi>H</mi><mi>a</mi><mi>s</mi><msub><mi>h</mi><mi>p</mi></msub><mo stretchy="false">(</mo><msub><mi>P</mi><mi>t</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ζ = s_tHash_p (P_t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.07378em;">ζ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ul>
<p>上述哈希函数中会得到椭圆曲线中一个点，这有区别于Hash函数。key image 是对转账的input的一个可识别的标记，矿工会对每个区块中每笔交易的key image进行记录，Alice进行双花时，矿工检测到生成的key image已经存在就能发现双花攻击。<br />
<strong>注意</strong>：Monero中具体进行交易检验的细节内容，暂时没有深入的了解，待后续调研。</p>
<p>下图介绍了一个具体的Monero的交易信息，其中有多个输入，每个输入都会添加mix-ins，总共2个input和 3个output，每个input都有1个key image。第一个input使用了2个mix-in，第二个input使用了1个mix-ins。与Bitcoin一样，所有的input交易额之和应该等于所有的output交易额之和。<br />
<img src="https://img-blog.csdnimg.cn/20190408221604164.png" alt="在这里插入图片描述" /></p>
<h3 id="ringcts"><a class="markdownIt-Anchor" href="#ringcts"></a> RingCTs</h3>
<p>2017年1月10日，Monero中上线了一种新的交易类型，称之为ring confidential transaction(RingCTs). 在一个RingCTs中，不仅隐藏了交易的真正input，同时也隐藏了交易额，在RingCTs中，每个output的交易额都标记为0,验证inputs和outputs的交易额相等的方法称之为commitment scheme，这里不再具体涉及。使用RingCTs的好处就是，转账进行mix-ins时，不用找相同价值的output，而是其他任意output都可以作为mix-ins。</p>
<h2 id="monero-network-statics"><a class="markdownIt-Anchor" href="#monero-network-statics"></a> Monero Network Statics</h2>
<p>Monero区块链提供了Remote Procedure Calls(RPC)的方法，该论文通过RPC获取Monero区块链数据，RPC接口提供两个方法：getheight和getransactions，返回的JSON形式的文本。<br />
该论文分析的Monero区块链，截止时间为2017年1月10日，高度1240503，其中总共961463笔非coinbase交易，总共1339733个output，最大一笔输出为500000 XMR，其中85%的output的金额小于0.01 XMR。Monero区块链中output中XMR的分布图如下。</p>
<p><img src="https://img-blog.csdnimg.cn/20190408221652783.png" alt="在这里插入图片描述" /><br />
在Monero中，规定output金额应该是A×10B的形式，其中1&lt;=A&lt;=9, B&gt;=-12。实际分析发现其中99.98%的output的金额并不符合Monero中output格式，同时其中92.8%的output金额在Monero中是唯一的，这些output总和是12231.27 XMR。Output金额不符合要求，是因为Monero中交易费用会根据交易大小而变化，交易的大小受mix-ins数量的影响，最终导致output值的不符合其规定。</p>
<h3 id="number-of-mix-ins"><a class="markdownIt-Anchor" href="#number-of-mix-ins"></a> Number of MIx-ins</h3>
<p>Min-ins的使用，各个input有所不同，最小的mix-ins是0，最大的mix-ins为851。但是其中[0,4]范围的mix-ins占比96%。不同mix-ins的使用的累积分布图如下：<br />
<img src="https://img-blog.csdnimg.cn/20190408221722424.png" alt="在这里插入图片描述" /><br />
这里面作者猜想大部分交易都是用数量较低的mix-ins的原因有两个，一方面有可能找不到足够多的等价值的output作为mix-ins，另外一方面，mix-ins的数量越多，意味着交易越大，交易越大则交易费越高。为了进一步对这两个原因进行分析，作者统计了mix-ins在0～11范围内所有对应交易中可以使用更高数量mix-ins的比例，其结果如Table 2所示，其中最后一列表示相应数量的mix-ins中，可以使用更高mix-ins的交易所占的比例，例如在mix-ins为2的交易总共2908304笔，但是其中2902246笔可以使用大于2的mix-ins，<strong>这说明Monero中大量交易使用较低的mix-ins不是因为没有足够的mix-ins，而是为了避免高额的手续费</strong>。<br />
<img src="https://img-blog.csdnimg.cn/20190408221747981.png" alt="在这里插入图片描述" /></p>
<h3 id="number-of-inputs-and-outputs"><a class="markdownIt-Anchor" href="#number-of-inputs-and-outputs"></a> Number of Inputs and Outputs</h3>
<p>在Monero区块链中input和output数量的变化情况如图4的统计所示。在Monero上线初期转账的时候，为了将output凑成A×10B的形式，因此会有很多输入和输出。Monero上线第一周，input和output的平均值分别为19和17，到第4周时input达到104，最后1周时下降到3，这是因为RingCTs技术的采用。<br />
<img src="https://img-blog.csdnimg.cn/2019040822182085.png" alt="在这里插入图片描述" /><br />
在采用RingCTs后，Monero中的output数量大幅下降，其平均值为2～4，然而input数量的变化却没有固定规律，主要是因为有很多input凑在一起支付的原因。在使用RingCTs后intput和output的情况如图5所示。<br />
<img src="https://img-blog.csdnimg.cn/20190408221839913.png" alt="在这里插入图片描述" /></p>
<h3 id="summary"><a class="markdownIt-Anchor" href="#summary"></a> Summary</h3>
<p>对Monero区块链的统计分析情况，使用表3进行一个比较全面的总结。<br />
<img src="https://img-blog.csdnimg.cn/201904082219019.png" alt="在这里插入图片描述" /></p>
<h2 id="traceability-attacking"><a class="markdownIt-Anchor" href="#traceability-attacking"></a> Traceability Attacking</h2>
<h3 id="heuristic-i"><a class="markdownIt-Anchor" href="#heuristic-i"></a> Heuristic I</h3>
<p>前文经过分析，作者发现了在Monero中，有65%的交易没有采用mix-ins技术，这就意味着这些交易中的所有input，都非常明确他们作为output是何时被花费出去的。因此，如果其他交易中使用了这些交易中的input作为mix-ins，那么就可以确定其他交易中真正被花销出去的output是哪一个，在文中作者称之为Cascade Effect，其效果如图6所示。<br />
<img src="https://img-blog.csdnimg.cn/20190408221932254.png" alt="在这里插入图片描述" /><br />
作者使用这种分析方法，逐渐减小一些交易中的匿名集合，直到匿名集合数量为1，于是就能确定真正被花销出去的output，最后根据这种方法追踪到了额外22%的交易。作者的追踪算法详细内容如下：<br />
<img src="https://img-blog.csdnimg.cn/20190408221948776.png" alt="在这里插入图片描述" /><br />
图7展示了交易追踪算法分别迭代1、3、5次之后追踪到的结果。在Figure 7a中，分别表示在mix-ins为0～10中，迭代1次、3次、5次能够追踪到的交易的比例。Figure 7b表示不同数量的mix-ins，迭代次数分别为1、3、5次时追踪到的交易的比例变化情况；Figure 7c表示随着时间（Week为单位）增长，不同迭代次数追踪到的交易比例，随着Monero中采用了RingCTs技术之后，Heuristic I已经无法追踪其中的inputs。</p>
<p><img src="https://img-blog.csdnimg.cn/20190408222003971.png" alt="在这里插入图片描述" /><br />
即使使用了Heuristic I，仍然有一些交易的input是无法追踪的，论文统计了mix-ins在-～1-范围内的情况，随着mix-ins数量增多，能准确追踪的input数量越来越少，针对mix-ins为10的input，其中24%的交易，其匿名集可以减少为2个input。统计情况如图8所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20190408222021708.png" alt="在这里插入图片描述" /></p>
<h3 id="heuristic-ii"><a class="markdownIt-Anchor" href="#heuristic-ii"></a> Heuristic II</h3>
<p>Heuristic I的方法针对于没有使用RingCTs技术的Monero区块链分析有用，但是后续使用RingCTs的Monero区块链无能为力，于是作者使用了启发式方法II，该方法假设如果在交易Tx-a中，有2个input，其中一个input作为mix-ins，同时有2个输出O1和O2；如果在另外一笔交易Tx-b中，如果同时使用O1和O2作为input，那么则认为O1和O2隶属于同一个人；启发式方法2认为一笔交易中的inputs全部来自之前一笔交易的output的概率很低，如果出现这种情况，则认为这些input都会在这笔交易中被花出去。为了方便叙述，将Tx-a称之为source transaction，将Tx-b称之为 dest transaction，dest transaction的input中至少使用了source transaction中不少于2个的output。作者的假设可以参见图9。</p>
<p><img src="https://img-blog.csdnimg.cn/20190408222049979.png" alt="在这里插入图片描述" /><br />
由于启发式方法2是基于假设，因此基于假设的结果未必会有结论，同时还会又一些错误，论文作者也承认这一点，但是还是基于此不太靠谱的假设强行展开了分析并设计了算法，求解Monero使用RingCTs后的交易中是否存在一些dest transaction 使用了至少2个其他交易中的output，算法如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20190408222105116.png" alt="在这里插入图片描述" /><br />
Algorithm 2 的运行情况有4种：</p>
<p><img src="https://img-blog.csdnimg.cn/20190408222123639.png" alt="在这里插入图片描述" /><br />
<strong>注意：我对这里面S2和S3的分类没有很明白有什么区别？找到several dest trx不是表明有给定的source，其output出现在多个dest 的input中吗？这和S3不就是一个意思吗？</strong></p>
<p>其中S1说明方法没有奏效，S2说明方法在transaction level中存在false positive；S3情况说明方法在input level 存在false positive；S4才是真正说明source 的outputs在dest中确实被花费了。<br />
为了评价方法的效果，分别统计4种情况出现的比例，同时以Heuristic I中获得的87%的数据作为真实数据，应用Heuristic II方法。首先经过统计总共找到410237种source trx，这些占比所有trx的43%， 其中包括636 笔包含RingCTs的trx，这只占RingCTs交易数的1%。将Heuristic II方法应用到不包含RingCTs的409601笔 trx中，其中60%的source trx 有1个对应的dest trx，其中1笔source trx能找到的dest trx的最大数目为146，对一个给定的dest trx，寻找对应的dest trx，dest trx数量增多，对应的source trx的比例逐步下降，如图Figure 10a所示。<br />
<img src="https://img-blog.csdnimg.cn/2019040822215451.png" alt="在这里插入图片描述" /></p>
<p>Figure 10b中是将Heuristic II 的方法应用到 636笔RingCTs trx中，发现其中95.1%的source trx 仅仅对应1个dest trx。Figure 10c表示对应于non-RingCTs的交易，Heuristic II方法验证中，TP占有87.3%，而对于用户来说，Monero区块链采用RingCTs前后消费习惯没有多大变化，因此Heuristic II在RingCTs中的分析TP应该也占大部分的比例。</p>
<p><img src="https://img-blog.csdnimg.cn/20190408222222748.png" alt="在这里插入图片描述" /></p>
<p>为了进一步说明在non-RingCTs中的结果比较可信，作者按照mix-ins的数量变化对Heuristic II方法的结果进行了统计，结果如图11所示，因为mix-ins数量增加，Heuristic I中可以追踪的交易数量大幅下降，因此针对Heuristic II中的结果，有一大部分是无法检测结果的正确性，但是即使如此，其中明确的False Positive几乎为0。</p>
<h3 id="heuristic-iii"><a class="markdownIt-Anchor" href="#heuristic-iii"></a> Heuristic III</h3>
<p>启发式方法3的中，作者认为一个UTXO，随着时间的增长，其被花费的概率会越来越大，因此作者认为，在一个环形签名的公钥中，真正的转账地址应该是所在区块高度最高的那个地址（听起来有几分道理，如果有几个地址高度相同呢？），作者抱着试一试的想法，将这个启发式方法应用到non-RingCTs中的交易中，发现作者的方法，精确率能达到98.1%（看起来虽然是个扯淡的猜想，但是居然make sense！）为了规避这个问题，Monero developer在2015年4月5号将原本的mix-ins采样算法从正态分布换成了triangle distribution，这种采样中，对一个input，会挑选最近的output作为其mix-ins以解决这个问题。为了验证这种Monero developer采用的新的采样方式的效果，作者对2015年4月5号以后的交易进行了Heuristic III的分析，与之前的正态分布的采样下的结果比对，结果如表5所示，表5的情况说明采用新的采样方法之后，对于Heuristic III方法的影响不大。</p>
<p><img src="https://img-blog.csdnimg.cn/20190408222254166.png" alt="在这里插入图片描述" /></p>
<p>为了对Heuristic III的方法的假设进行进一步的验证，对Heuristic I中确定的87%的交易进行了统计，分别统计这些UTXO在输出之后分别在什么时候被花销出去，作者对用户消费习惯进行如下分类，其中占比分别为：</p>
<ul>
<li>在[0,9]个区块内被花费的UTXO占比0.17%</li>
<li>在[10，100]范围内被花费的UTXO占比9.16%</li>
<li>在[101, 1000]范围内被花费的UTXo占比28.4%</li>
<li>[1000， +∞]范围内被花费的UTXO占比62.27%</li>
</ul>
<p>据此，分别计算得到一个概率密度图，如图12所示，作者建议依据此概率选择mix-ins更加合理。</p>
<p><img src="https://img-blog.csdnimg.cn/20190408222348303.png" alt="在这里插入图片描述" /></p>
<h2 id="releated-work-conclusion"><a class="markdownIt-Anchor" href="#releated-work-conclusion"></a> Releated Work &amp;&amp; Conclusion</h2>
<p>本文的工作基于Menero Lab的两篇公开的文献MRL-001和MRL-002MRL-004。其中Heuristic I来自于MRL-001。本文的Heuristic II和Heuristic III分别来自于Monero-004。<br />
本文最重要的贡献在于利用Heuristic I方法能够追踪到Monero 区块链中87%的交易，同时对于Monero Lab中对Monero做的一些改进进行了验证，Heuristic II和Heuristic III分别指出了改进方法的不足，同时给出建议，Monero Developer在进行mix-ins采样时可以考虑用户花费UTXO的习惯以提升匿名性。</p>
<h2 id="thinking"><a class="markdownIt-Anchor" href="#thinking"></a> Thinking</h2>
<ul>
<li>相比于ZCash这篇论文，这篇文章中的作者为什么不在Monero中自己注册多个账号，然后多次进行转账，如果RingCTs中某个用户也恰恰使用1个mix-ins并且选中了作者的账号，那么就可以同样适用Heuristic I的方法，我就后续进行一些调研以验证我的想法，如果可以的话，就可以根据这篇文章的不足继续推进一些分析工作，例如可以分析Monero在采用了RingCTs技术之后匿名性/可追踪行到底如何？</li>
<li>本文的工作就量和质上与ZCash的那篇文章确有不及，这方面也令我看出发表一篇顶会，不仅需要原创、有效并且非常合理的想法，而且也需要有相当数量的分析工作，两者兼具，才能发到A类会议中。</li>
<li>对于RingCTs的使用方法、以及Monero中是如何防止双花的细节，我比较好奇，后续会进行一些调研。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hzxgoforward.github.io/2019/04/08/New%20Empirical%20Traceability%20Analysis%20of%20CryptoNote-Style%20Blockchains/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌虎下山">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/08/New%20Empirical%20Traceability%20Analysis%20of%20CryptoNote-Style%20Blockchains/" class="post-title-link" itemprop="https://hzxgoforward.github.io/index.html">New Empirical Traceability Analysis of CryptoNote-Style Blockchains</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建于：2019-04-08 17:00:14" itemprop="dateCreated datePublished" datetime="2019-04-08T17:00:14+08:00">2019-04-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="更新于：2023-03-03 15:21:44" itemprop="dateModified" datetime="2023-03-03T15:21:44+08:00">2023-03-03</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/" itemprop="url" rel="index"><span itemprop="name">区块链技术研究</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          


          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>发表于Financial Cryptography and Data Security 2019的一篇文章。<br />
文章链接：<a target="_blank" rel="noopener" href="http://fc19.ifca.ai/preproceedings/69-preproceedings.pdf">http://fc19.ifca.ai/preproceedings/69-preproceedings.pdf</a></p>
<h2 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h2>
<p>在（PETS’18）会议提出对Monero 不可追踪性的cascade effect 攻击已被开发者使用两个方法规避，其中之一是增加币环形签名(Ring Signature)中mix-ins的个数，从 0.9.0版本中的3个增加到了0.12.0版本中的7个，同时增加了ring confidential transactions(ringCTs)以提升隐私性。然而，目前并没有人对Monero当前应对的策略的匿名性进行分析。 改论文提出一种统计学分析，对所有CryptoNote类型的加密货币进行closed set attack.随后对Monero、Bytecoin以及DigitalNOte进行这种攻击，实验表明，结合了cascade attack之后的closed set attack能够识别出Monero中70.52%的input、Bytecoin中74.25%的inputs以及DigitalNote中91.56%的input。<br />
随后对该种攻击成功的概率进行理论分析，发现成功概率为 2^19，closed set attack近似于statiscal attacks，据此，文中分析认为Monero当前的系统设置可以抵御statiscal attacks，另外文章分析说明了mix-ins不是越大越好，而是其中未被花费的input比例越高越好。</p>
<h2 id="intruductioon"><a class="markdownIt-Anchor" href="#intruductioon"></a> Intruductioon</h2>
<p>目前加密货币中用户的匿名性和隐私性都逐渐受到重视，因此出现了很多致力于保护用户隐私的加密货币，例如Monero、Bytecoin、Dash、DigitalNote、Boolberry等货币，这些货币都使用了CryptoNote 协议。在这些货币中，使用了ring signature(环形签名)技术，即在一笔交易的输入中，支付方会将自己的input地址和区块链中其他output地址混合起来形成一个环，这样做的目的是不让外界知道真正的input具体是哪一个，其他没有被花费的input称之为mix-ins。</p>
<p>然而实际上Monero区块链中有65%的用户在花销的时候，使用的mix-ins为0，而这些交易很容易被确定真正的input，随后其他一些用户使用了这些被追踪的input作为mix-ins之后也面临着被追踪的危险，也确实有文章进行了相关分析，经过分析后发现其中87%的input都能被追踪到。随后Monero开发团队也对其进行了升级，其中引入了RingCTs技术，RingCTs技术中即使是不同数目的输入也可以作为mix-ins，同时将mix-ins的数量从2提升到了6（2019年3月29日的0.12.0版本）。但是实际上这些货币匿名性如何呢？</p>
<p>本文中作者引入了closed set attack方式，简而言之就是如果有X个inputs的集合，其中恰好又有X个不同的地址，那么说明在这X个inputs中，不同的X个地址都已经被花销出去，因为每个inputs至少要消费一个地址。假若其他inputs中包含了这X中的地址，那么其他inputs的匿名集就可以减小，如果减小到1，就能够追踪到其中的交易。</p>
<h2 id="preliminary"><a class="markdownIt-Anchor" href="#preliminary"></a> Preliminary</h2>
<h3 id="cryptonote-protocol"><a class="markdownIt-Anchor" href="#cryptonote-protocol"></a> CryptoNote protocol</h3>
<p>CryptoNote协议致力于做两件事情：</p>
<ul>
<li><strong>Untraceability：</strong> 对于任何交易，真正被花费的地址应该是在一系列outputs中匿名的作为inputs</li>
<li><strong>Unlinkability：</strong> 对于任意两个交易，不可能证明这两笔交易是发送给同一个用户的。</li>
</ul>
<p>为了实现unlinkability，CryptoNote中每次转账时使用一个一次性地址，而这个一次性地址来源于接受者的公钥和发送者生成的一个随机数。 为了实现untraceability，CryptoNote中使用了环形签名。</p>
<h2 id="closed-set-attack"><a class="markdownIt-Anchor" href="#closed-set-attack"></a> Closed Set Attack</h2>
<p>为了说明攻击方法，用txi.in表示每笔交易的输入，假设当前有4笔交易，每笔交易中的inputs分别是：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://tx1.in">tx1.in</a> = { pk1, pk2, pk3 }</li>
<li><a target="_blank" rel="noopener" href="http://tx2.in">tx2.in</a> = { pk2, pk3 }</li>
<li><a target="_blank" rel="noopener" href="http://tx3.in">tx3.in</a> = { pk1, pk3 }</li>
<li><a target="_blank" rel="noopener" href="http://tx4.in">tx4.in</a> = { pk1, pk2, pk3, pk4 }<br />
其中pk表示public key， 即公钥。在tx1、tx2以及tx3中分别用到了pk1、pk2和pk3，而每个tx中都会花费一个pk，因此前3个交易必然是吧pk1、pk2和pk3已经花费掉了，在tx4中，很明显可以推出pk4是真正的花费地址。<br />
应用理论分析应该是，在一系列交易中，所有的inputs的数量之和恰好等于这些inputs中不同地址的数目，那么其他应用这些不同地址作为mix-ins的交易，其匿名集中可以除去这些地址以减少其匿名集，如果匿名集和数量为1，那么这笔交易就成为可追踪交易了。</li>
</ul>
<h3 id="definition-of-cluster"><a class="markdownIt-Anchor" href="#definition-of-cluster"></a> Definition of Cluster</h3>
<p>那么这种攻击是如何进行的呢？文中定义一个Clus记为一个inputs的集合，Clus = { R1， R2，…, Rn }，每一个Clusetr中所有不同地址的集合，称之为PK_Clus，一个inputs我们使用R代表。假设已经存在一个Clus，那么一个inputs和Clus之间的差集定义为</p>
<ul>
<li>Dist(R, Clus)  = Dist(R, PK_Clus) = |R| - |PK_Clus∩R|<br />
举例说明之，假设Clus = { { pk1, pk2 } ,  { pk1, pk3 }, { pk2, pk4 } }, 那么PK_Clus = { pk1, pk2, pk3, pk4 }，假设某个R = { pk1, pk3, pk5 },  那么Dist(R, Clus) = 3-2 =1.</li>
</ul>
<h3 id="closed-set-attack-algorithm"><a class="markdownIt-Anchor" href="#closed-set-attack-algorithm"></a> closed set Attack Algorithm</h3>
<p>为了进行closed set Attack，文中使用了一种聚类的方法，这种聚类的方法由两个算法构成，其中第二个算法调用了第1个算法。算法首先对所有的inputs应用Cascade-Effect攻击以减少其匿名集，随后对剩余的inputs集合输入到算法2中，Algorithm 2如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: Let DataSet be all transaction inputs in the blockchain.</span><br><span class="line"><span class="number">1.</span> Cascade-<span class="built_in">Effect</span>(Dataset)</span><br><span class="line"><span class="number">2.</span> Flag = <span class="literal">true</span></span><br><span class="line"><span class="number">3.</span> <span class="keyword">while</span> Flag == <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line"><span class="number">4.</span>     Flag = <span class="literal">false</span></span><br><span class="line"><span class="number">5.</span>     <span class="keyword">for</span> each R ∈ DataSet <span class="keyword">do</span></span><br><span class="line"><span class="number">6.</span>     <span class="built_in">Clus_Form</span>(R) -&gt; Clus		<span class="comment">// 调用了Algorithm 1</span></span><br><span class="line"><span class="number">7.</span>     <span class="keyword">if</span> Clus is a closed set then</span><br><span class="line"><span class="number">8.</span>        <span class="built_in">Remove</span>(Clus) -&gt;Flag  <span class="comment">// 删除Dataset中的Clus集合</span></span><br><span class="line"><span class="number">9.</span>        <span class="keyword">if</span> Flag == <span class="literal">true</span> then</span><br><span class="line"><span class="number">10.</span>           find traceable inputs</span><br><span class="line"><span class="number">11.</span>           check whether rings inside Clus are traceable     </span><br></pre></td></tr></table></figure>
<p>Algorithm 1算法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>  Start with an input R, <span class="keyword">and</span> define the cluster as Clus = &#123; R &#125;</span><br><span class="line"><span class="number">2.</span> Let DataSet be all transaction inputs in the blockchain</span><br><span class="line"><span class="number">3.</span> <span class="keyword">for</span> each <span class="built_in">R1</span>(≠ R) <span class="number">2</span> DataSet <span class="keyword">do</span></span><br><span class="line"><span class="number">4.</span>     <span class="keyword">if</span> <span class="built_in">Dist</span>(R1， Clus) ≤ <span class="number">1</span> then</span><br><span class="line"><span class="number">5.</span>         Clus = Clus ∪ &#123; R1 &#125;</span><br><span class="line"><span class="number">6.</span> <span class="keyword">return</span> Clus </span><br></pre></td></tr></table></figure>
<p>对于Dataset中的所有inputs，迭代使用Algorithm 2，假设所有inputs个数为N，而每个R的长度为L，那么总的算法复杂度为θ(LN²) 。</p>
<h2 id="experiment"><a class="markdownIt-Anchor" href="#experiment"></a> Experiment</h2>
<h3 id="dataset"><a class="markdownIt-Anchor" href="#dataset"></a> Dataset</h3>
<p>本文收集了从Monero区块链创世块(2014年4月18日)到2018年3月30日的区块，总共1541236个区块，工2612070笔非coinbase 交易。</p>
<h3 id="experiment-result"><a class="markdownIt-Anchor" href="#experiment-result"></a> Experiment Result</h3>
<p>将本文方法应用于Monero区块链分析，首先应用Cascade effect attack，发现其中16334967笔交易可追踪，而closed set总工追踪到了5752笔交易，因此总共追踪到70.52%的inputs。追踪结果如下表所示。总共找到3017个closed set，大小从2到55不等，总共包含了7478个public_keys，这些public keys已经被花销了，如果其他输入使用这些inputs作为mix-ins，那么是无效的。</p>
<table>
<thead>
<tr>
<th>mix-insg个数</th>
<th>inputs数</th>
<th>共可追踪inputs数</th>
<th>Cascade Effect</th>
<th>Closed set</th>
<th>百分比</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>12209675</td>
<td>12209675</td>
<td>12209675</td>
<td>0</td>
<td>100</td>
</tr>
<tr>
<td>1</td>
<td>707786</td>
<td>625641</td>
<td>625264</td>
<td>377</td>
<td>88.39</td>
</tr>
<tr>
<td>2</td>
<td>4496490</td>
<td>1779134</td>
<td>1776192</td>
<td>2942</td>
<td>39.57</td>
</tr>
<tr>
<td>3</td>
<td>1486593</td>
<td>952855</td>
<td>951984</td>
<td>871</td>
<td>64.10</td>
</tr>
<tr>
<td>4</td>
<td>3242625</td>
<td>451959</td>
<td>451230</td>
<td>729</td>
<td>13.94</td>
</tr>
<tr>
<td>5</td>
<td>319352</td>
<td>74186</td>
<td>73980</td>
<td>206</td>
<td>23.23</td>
</tr>
<tr>
<td>6</td>
<td>432875</td>
<td>202360</td>
<td>202100</td>
<td>260</td>
<td>46.75</td>
</tr>
<tr>
<td>7</td>
<td>21528</td>
<td>4296</td>
<td>4282</td>
<td>14</td>
<td>19.96</td>
</tr>
<tr>
<td>8</td>
<td>30067</td>
<td>3506</td>
<td>3490</td>
<td>16</td>
<td>11.66</td>
</tr>
<tr>
<td>9</td>
<td>17724</td>
<td>2178</td>
<td>2162</td>
<td>16</td>
<td>12.29</td>
</tr>
<tr>
<td>Total</td>
<td>≥10</td>
<td>200030</td>
<td>29177</td>
<td>28856</td>
<td>321</td>
</tr>
</tbody>
</table>
<p>最后还剩余6829778笔inputs仍然不可追踪，但是这些交易的匿名集已经大大减少，减少情况如下图所示。可以看到，很多之前inputs中地址很多，但是经过closed set分析之后币有多都可以识别，其中inputs你们集合是1的，当下有超过100万，想办法进一步进行分析，或许可以有更多收获。不过作者并没有进一步分析。</p>
<p><img src="https://img-blog.csdnimg.cn/20190408163804418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<p>此外，作者分别对Bytecoin和DigitalNote进行了同样的分析，分析的结果没有过多需要介绍的，因此这里略过。</p>
<h2 id="observations-and-recommendations"><a class="markdownIt-Anchor" href="#observations-and-recommendations"></a> Observations and Recommendations</h2>
<ul>
<li><strong>Obervation 1：</strong> 区块链中outputs的使用率是匿名性中一个非常重要的因素，因为每个outputs毕竟只能被redeem 1次，因此低的使用量能提升匿名性。</li>
<li><strong>Obervation 2：</strong> Closed sets与intpus的匿名性息息相关，找到Closed sets有助于减少匿名集和找到real spent，虽然其数量不多，但是仍然会威胁到匿名集。</li>
<li><strong>Recommendation 1：</strong> 为了减少outputs的使用率，应该增加更多的outputs，建议用户增加一些价值为0 的输出。(PS:输出越多，花费的交易费越多，用户愿意吗？)</li>
<li><strong>Recommendation 2：</strong> 不用使用无效的mix-ins。PS：如果用户知道的话，用户当然不会使用了。</li>
</ul>
<h2 id="thinking"><a class="markdownIt-Anchor" href="#thinking"></a> Thinking</h2>
<p>这篇文章就提出了1种攻击方式，相比于其他文章来说，在内容和分析展示情况上都显示出比较单一，个人觉得提出的方法很好，但是并没有很好地挖掘这种方法之后的结果，这种方法已经将匿名集降低到1了，此时如果在坚持一下，或者在想想别的分析方法，那么就不是简单的发表在FC上了，可以冲击一下B类会议。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hzxgoforward.github.io/2019/03/28/EOS%E4%B8%ADplugin%E4%B9%8Bnet-plugin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌虎下山">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/28/EOS%E4%B8%ADplugin%E4%B9%8Bnet-plugin/" class="post-title-link" itemprop="https://hzxgoforward.github.io/index.html">EOS中plugin之net_plugin</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建于：2019-03-28 14:15:24" itemprop="dateCreated datePublished" datetime="2019-03-28T14:15:24+08:00">2019-03-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="更新于：2019-11-08 14:58:43" itemprop="dateModified" datetime="2019-11-08T14:58:43+08:00">2019-11-08</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/" itemprop="url" rel="index"><span itemprop="name">区块链技术研究</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          


          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这部分重点介绍EOS中的服务器端部分nodeos启动之后开启的另外一个重要的插件——net_plugin，这个插件主要负责服务器在网络中的接入、同步区块信息、断开等功能。对于这个插件，首先从其类的定义开始了解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">net_plugin</span> : <span class="keyword">public</span> appbase::plugin&lt;net_plugin&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">net_plugin</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">net_plugin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">APPBASE_PLUGIN_REQUIRES</span>((chain_plugin))    <span class="comment">// net_plugin这个插件的启动，依赖chain_plugin插件</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">set_program_options</span><span class="params">(options_description&amp; cli, options_description&amp; cfg)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">plugin_initialize</span><span class="params">(<span class="type">const</span> variables_map&amp; options)</span></span>;  <span class="comment">// 插件初始化</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">plugin_startup</span><span class="params">()</span></span>;                                 <span class="comment">// 插件的启动</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">plugin_shutdown</span><span class="params">()</span></span>;                                <span class="comment">// 插件关闭</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span>   <span class="title">broadcast_block</span><span class="params">(<span class="type">const</span> chain::signed_block &amp;sb)</span></span>; <span class="comment">// 广播区块</span></span><br><span class="line"></span><br><span class="line">    <span class="function">string                       <span class="title">connect</span><span class="params">( <span class="type">const</span> string&amp; endpoint )</span></span>; <span class="comment">// 连接其他端点</span></span><br><span class="line">    <span class="function">string                       <span class="title">disconnect</span><span class="params">( <span class="type">const</span> string&amp; endpoint )</span></span>; <span class="comment">// 断开连接</span></span><br><span class="line">    <span class="function">optional&lt;connection_status&gt;  <span class="title">status</span><span class="params">( <span class="type">const</span> string&amp; endpoint )</span><span class="type">const</span></span>;   <span class="comment">// 查看与某个端点的链接状态</span></span><br><span class="line">    <span class="function">vector&lt;connection_status&gt;    <span class="title">connections</span><span class="params">()</span><span class="type">const</span></span>;                   <span class="comment">// 查看连接状态</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">num_peers</span><span class="params">()</span> <span class="type">const</span></span>;                                          <span class="comment">// 查看建立连接的端点个数</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;<span class="keyword">class</span> <span class="title class_">net_plugin_impl</span>&gt; my;   <span class="comment">// 和producer_plugin_imple一样，这个插件负责网络中的具体操作</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>net_plugin插件的代码还是比较容易理解的，net_plugin的初始化函数非常简单，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net_plugin::<span class="built_in">net_plugin</span>()</span><br><span class="line">    :<span class="built_in">my</span>( <span class="keyword">new</span> net_plugin_impl ) &#123;</span><br><span class="line">    my_impl = my.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化函数中生成了一阁net_plugin_impl的实例，随后将my的指针赋值给了net_plugin_impl类中的定义的静态指针,这个静态指针的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> net_plugin_impl *my_impl;</span><br></pre></td></tr></table></figure>
<p>再nodeos的main函数中，net_plugin首先会初始化，随后调用其plugin_initialize函数和<a href="https://hzxgoforward.github.io/2019/03/20/EOS%E4%B8%ADplugin%E7%9A%84%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84/">EOS中lugin之producer_plugin</a>的介绍的procuder_plugin类初始化方式时一样的，先寻找这个插件依赖的插件，然后初始化依赖的插件、一些启动参数，设置心跳计时器等。</p>
<p>nodeos中初始化完毕，随后调用net_plugin的plugin_startup函数，该函数代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">net_plugin::plugin_startup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    my-&gt;producer_plug = <span class="built_in">app</span>().<span class="built_in">find_plugin</span>&lt;producer_plugin&gt;();</span><br><span class="line">    <span class="keyword">if</span>( my-&gt;acceptor ) &#123;</span><br><span class="line">        <span class="comment">// 常见的网络服务操作,打开监听服务,设置选项,绑定地址,启动监听</span></span><br><span class="line">        my-&gt;acceptor-&gt;<span class="built_in">open</span>(my-&gt;listen_endpoint.<span class="built_in">protocol</span>());</span><br><span class="line">        my-&gt;acceptor-&gt;<span class="built_in">set_option</span>(tcp::acceptor::<span class="built_in">reuse_address</span>(<span class="literal">true</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// acceptor 来自于boost::asio::ip::tcp，即tcp::acceptor</span></span><br><span class="line">        my-&gt;acceptor-&gt;<span class="built_in">bind</span>(my-&gt;listen_endpoint);</span><br><span class="line">        &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        <span class="built_in">ilog</span>(<span class="string">&quot;net_plugin::plugin_startup failed to bind to port $&#123;port&#125;&quot;</span>,</span><br><span class="line">            (<span class="string">&quot;port&quot;</span>, my-&gt;listen_endpoint.<span class="built_in">port</span>()));</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        my-&gt;acceptor-&gt;<span class="built_in">listen</span>();</span><br><span class="line">        <span class="built_in">ilog</span>(<span class="string">&quot;starting listener, max clients is $&#123;mc&#125;&quot;</span>,(<span class="string">&quot;mc&quot;</span>,my-&gt;max_client_count));</span><br><span class="line">        my-&gt;<span class="built_in">start_listen_loop</span>();   <span class="comment">// 循环监听函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    chain::controller&amp;cc = my-&gt;chain_plug-&gt;<span class="built_in">chain</span>();</span><br><span class="line">    &#123;</span><br><span class="line">        cc.accepted_block.<span class="built_in">connect</span>(  boost::<span class="built_in">bind</span>(&amp;net_plugin_impl::accepted_block, my.<span class="built_in">get</span>(), _1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    my-&gt;incoming_transaction_ack_subscription = <span class="built_in">app</span>().<span class="built_in">get_channel</span>&lt;channels::transaction_ack&gt;().<span class="built_in">subscribe</span>(boost::<span class="built_in">bind</span>(&amp;net_plugin_impl::transaction_ack, my.<span class="built_in">get</span>(), _1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( cc.<span class="built_in">get_read_mode</span>() == chain::db_read_mode::READ_ONLY ) &#123;</span><br><span class="line">        my-&gt;max_nodes_per_host = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">ilog</span>( <span class="string">&quot;node in read-only mode setting max_nodes_per_host to 0 to prevent connections&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动连接和交易到期的监视</span></span><br><span class="line">    my-&gt;<span class="built_in">start_monitors</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">auto</span> seed_node : my-&gt;supplied_peers ) &#123;</span><br><span class="line">        <span class="built_in">connect</span>( seed_node );<span class="comment">// 连接种子节点,接入p2p网络</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fc::<span class="built_in">get_logger_map</span>().<span class="built_in">find</span>(logger_name) != fc::<span class="built_in">get_logger_map</span>().<span class="built_in">end</span>())</span><br><span class="line">        logger = fc::<span class="built_in">get_logger_map</span>()[logger_name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先打开监听的端口号，设置相关协议，随后绑定端口号，然后开始监听网络中的信息，同时让本端点连接到网络中的种子节点，以此连接EOS中的p2p网络。这里面最重要的2个函数是 my-&gt;start_listen_loop()以及my-&gt;start_monitors()函数,my-&gt;start_listen_loop，通过函数名称可以断定主要用来不断地从网络中监听网络中发送的信息，my-&gt;start_monitors()应该是进行监听，但是到底监听什么，我们还不得而知。</p>
<p>这里暂时先不对net_plugin_impl进行具体解析，因为这并不影响我们对这两个函数的分析，另外一方面，net_plugin_impl的介绍对于这两个函数的分析，帮助不大。<br />
因此，我们直接进入start_listen_loop函数一探究竟。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 该函数循环监听信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">net_plugin_impl::start_listen_loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> socket = std::<span class="built_in">make_shared</span>&lt;tcp::socket&gt;( std::<span class="built_in">ref</span>( <span class="built_in">app</span>().<span class="built_in">get_io_service</span>() ) );</span><br><span class="line">    acceptor-&gt;<span class="built_in">async_accept</span>( *socket, [socket,<span class="keyword">this</span>]( boost::system::error_code ec ) &#123;</span><br><span class="line">        <span class="keyword">if</span>( !ec ) &#123;</span><br><span class="line">            <span class="type">uint32_t</span> visitors = <span class="number">0</span>;</span><br><span class="line">            <span class="type">uint32_t</span> from_addr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">auto</span> paddr = socket-&gt;<span class="built_in">remote_endpoint</span>(ec).<span class="built_in">address</span>();</span><br><span class="line">            <span class="keyword">if</span> (ec) &#123;</span><br><span class="line">                <span class="built_in">fc_elog</span>(logger,<span class="string">&quot;Error getting remote endpoint: $&#123;m&#125;&quot;</span>,(<span class="string">&quot;m&quot;</span>, ec.<span class="built_in">message</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;conn : connections) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(conn-&gt;socket-&gt;<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (conn-&gt;peer_addr.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                        visitors++;</span><br><span class="line">                        boost::system::error_code ec;</span><br><span class="line">                        <span class="keyword">if</span> (paddr == conn-&gt;socket-&gt;<span class="built_in">remote_endpoint</span>(ec).<span class="built_in">address</span>()) &#123;</span><br><span class="line">                            from_addr++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (num_clients != visitors) &#123;</span><br><span class="line">                    <span class="built_in">ilog</span>(<span class="string">&quot;checking max client, visitors = $&#123;v&#125; num clients $&#123;n&#125;&quot;</span>,(<span class="string">&quot;v&quot;</span>,visitors)(<span class="string">&quot;n&quot;</span>,num_clients));</span><br><span class="line">                    num_clients = visitors;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>( from_addr &lt; max_nodes_per_host &amp;&amp; (max_client_count == <span class="number">0</span> || num_clients &lt; max_client_count )) &#123;</span><br><span class="line">                    ++num_clients;</span><br><span class="line">                    connection_ptr c = std::<span class="built_in">make_shared</span>&lt;connection&gt;( socket );</span><br><span class="line">                    connections.<span class="built_in">insert</span>( c );</span><br><span class="line">                    <span class="built_in">start_session</span>( c );</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (from_addr &gt;= max_nodes_per_host) &#123;</span><br><span class="line">                    <span class="built_in">fc_elog</span>(logger, <span class="string">&quot;Number of connections ($&#123;n&#125;) from $&#123;ra&#125; exceeds limit&quot;</span>,</span><br><span class="line">                            (<span class="string">&quot;n&quot;</span>, from_addr+<span class="number">1</span>)(<span class="string">&quot;ra&quot;</span>,paddr.<span class="built_in">to_string</span>()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">fc_elog</span>(logger, <span class="string">&quot;Error max_client_count $&#123;m&#125; exceeded&quot;</span>,</span><br><span class="line">                            ( <span class="string">&quot;m&quot;</span>, max_client_count) );</span><br><span class="line">                    &#125;</span><br><span class="line">                    socket-&gt;<span class="built_in">close</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">elog</span>( <span class="string">&quot;Error accepting connection: $&#123;m&#125;&quot;</span>,( <span class="string">&quot;m&quot;</span>, ec.<span class="built_in">message</span>() ) );</span><br><span class="line">            <span class="comment">// For the listed error codes below, recall start_listen_loop()</span></span><br><span class="line">            <span class="keyword">switch</span> (ec.<span class="built_in">value</span>()) &#123;</span><br><span class="line">                <span class="keyword">case</span> ECONNABORTED:</span><br><span class="line">                <span class="keyword">case</span> EMFILE:</span><br><span class="line">                <span class="keyword">case</span> ENFILE:</span><br><span class="line">                <span class="keyword">case</span> ENOBUFS:</span><br><span class="line">                <span class="keyword">case</span> ENOMEM:</span><br><span class="line">                <span class="keyword">case</span> EPROTO:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">start_listen_loop</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>start_listen_loop()函数中最重要的一个函数是，监听到消息之后的start_session()函数，表示监听到了新的链接，于是开始会话。start_session()函数内容如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">net_plugin_impl::start_session</span><span class="params">(<span class="type">const</span> connection_ptr&amp; con)</span> </span>&#123;</span><br><span class="line">    boost::asio::ip::<span class="function">tcp::no_delay <span class="title">nodelay</span><span class="params">( <span class="literal">true</span> )</span></span>;</span><br><span class="line">    boost::system::error_code ec;</span><br><span class="line">    con-&gt;socket-&gt;<span class="built_in">set_option</span>( nodelay, ec );</span><br><span class="line">    <span class="keyword">if</span> (ec) &#123;</span><br><span class="line">        <span class="comment">// 如果接受数据出错， 直接关闭连接，写日志</span></span><br><span class="line">        <span class="built_in">elog</span>( <span class="string">&quot;connection failed to $&#123;peer&#125;: $&#123;error&#125;&quot;</span>,</span><br><span class="line">            ( <span class="string">&quot;peer&quot;</span>, con-&gt;<span class="built_in">peer_name</span>())(<span class="string">&quot;error&quot;</span>,ec.<span class="built_in">message</span>()));</span><br><span class="line">        con-&gt;connecting = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">close</span>(con);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 读取数据，已经开启的session+1</span></span><br><span class="line">        <span class="built_in">start_read_message</span>( con );</span><br><span class="line">        ++started_sessions;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// for now, we can just use the application main loop.</span></span><br><span class="line">        <span class="comment">//     con-&gt;readloop_complete  = bf::async( [=]()&#123; read_loop( con ); &#125; );</span></span><br><span class="line">        <span class="comment">//     con-&gt;writeloop_complete = bf::async( [=]()&#123; write_loop con ); &#125; );</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中重要的是start_read_message，即回话过程中读取数据，即start_read_message()函数，其具体内容如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">net_plugin_impl::start_read_message</span><span class="params">(<span class="type">const</span> connection_ptr&amp; conn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!conn-&gt;socket) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        connection_wptr weak_conn = conn;</span><br><span class="line"></span><br><span class="line">        std::<span class="type">size_t</span> minimum_read = conn-&gt;outstanding_read_bytes ? *conn-&gt;outstanding_read_bytes : message_header_size;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认为false，在plugin_initialized中使用</span></span><br><span class="line">        <span class="keyword">if</span> (use_socket_read_watermark) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">size_t</span> max_socket_read_watermark = <span class="number">4096</span>;</span><br><span class="line">        std::<span class="type">size_t</span> socket_read_watermark = std::<span class="built_in">min</span>&lt;std::<span class="type">size_t</span>&gt;(minimum_read, max_socket_read_watermark);</span><br><span class="line">        boost::asio::<span class="function">socket_base::receive_low_watermark <span class="title">read_watermark_opt</span><span class="params">(socket_read_watermark)</span></span>;</span><br><span class="line">        conn-&gt;socket-&gt;<span class="built_in">set_option</span>(read_watermark_opt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> completion_handler = [minimum_read](boost::system::error_code ec, std::<span class="type">size_t</span> bytes_transferred) -&gt; std::<span class="type">size_t</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ec || bytes_transferred &gt;= minimum_read ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> minimum_read - bytes_transferred;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从stream中异步读取固定大小的数据</span></span><br><span class="line">        <span class="comment">/* async_read(AsyncReadStream &amp;S, const MutableBufferSequence&amp; buffers, ReadHandler&amp;&amp; handler, )</span></span><br><span class="line"><span class="comment">        从*conn-&gt;socket中读取data，读到buffers中去，buffers的大小告诉系统读取多少</span></span><br><span class="line"><span class="comment">        handler是读取数据完毕之后调用的函数 */</span></span><br><span class="line">        boost::asio::<span class="built_in">async_read</span>(*conn-&gt;socket,</span><br><span class="line">        conn-&gt;pending_message_buffer.<span class="built_in">get_buffer_sequence_for_boost_async_read</span>(), </span><br><span class="line">        completion_handler,</span><br><span class="line">        [<span class="keyword">this</span>,weak_conn]( boost::system::error_code ec, std::<span class="type">size_t</span> bytes_transferred ) &#123;</span><br><span class="line">            <span class="keyword">auto</span> conn = weak_conn.<span class="built_in">lock</span>();</span><br><span class="line">            <span class="keyword">if</span> (!conn) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            conn-&gt;outstanding_read_bytes.<span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>( !ec ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (bytes_transferred &gt; conn-&gt;pending_message_buffer.<span class="built_in">bytes_to_write</span>()) &#123;</span><br><span class="line">                    <span class="built_in">elog</span>(<span class="string">&quot;async_read_some callback: bytes_transfered = $&#123;bt&#125;, buffer.bytes_to_write = $&#123;btw&#125;&quot;</span>,</span><br><span class="line">                            (<span class="string">&quot;bt&quot;</span>,bytes_transferred)(<span class="string">&quot;btw&quot;</span>,conn-&gt;pending_message_buffer.<span class="built_in">bytes_to_write</span>()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">EOS_ASSERT</span>(bytes_transferred &lt;= conn-&gt;pending_message_buffer.<span class="built_in">bytes_to_write</span>(), plugin_exception, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                    conn-&gt;pending_message_buffer.<span class="built_in">advance_write_ptr</span>(bytes_transferred);</span><br><span class="line">                    <span class="keyword">while</span> (conn-&gt;pending_message_buffer.<span class="built_in">bytes_to_read</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">uint32_t</span> bytes_in_buffer = conn-&gt;pending_message_buffer.<span class="built_in">bytes_to_read</span>();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (bytes_in_buffer &lt; message_header_size) &#123;</span><br><span class="line">                        conn-&gt;outstanding_read_bytes.<span class="built_in">emplace</span>(message_header_size - bytes_in_buffer);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="type">uint32_t</span> message_length;</span><br><span class="line">                        <span class="keyword">auto</span> index = conn-&gt;pending_message_buffer.<span class="built_in">read_index</span>();</span><br><span class="line">                        conn-&gt;pending_message_buffer.<span class="built_in">peek</span>(&amp;message_length, <span class="built_in">sizeof</span>(message_length), index);</span><br><span class="line">                        <span class="keyword">if</span>(message_length &gt; def_send_buffer_size*<span class="number">2</span> || message_length == <span class="number">0</span>) &#123;</span><br><span class="line">                            boost::system::error_code ec;</span><br><span class="line">                            <span class="built_in">elog</span>(<span class="string">&quot;incoming message length unexpected ($&#123;i&#125;), from $&#123;p&#125;&quot;</span>,</span><br><span class="line">                                (<span class="string">&quot;i&quot;</span>, message_length)(<span class="string">&quot;p&quot;</span>,boost::<span class="built_in">lexical_cast</span>&lt;std::string&gt;(conn-&gt;socket-&gt;<span class="built_in">remote_endpoint</span>(ec))));</span><br><span class="line">                            <span class="built_in">close</span>(conn);</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">auto</span> total_message_bytes = message_length + message_header_size;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (bytes_in_buffer &gt;= total_message_bytes) &#123;</span><br><span class="line">                            conn-&gt;pending_message_buffer.<span class="built_in">advance_read_ptr</span>(message_header_size);</span><br><span class="line">                            <span class="comment">// 这一部分是网络通信的内容，对于其中细节不甚了解</span></span><br><span class="line">                            <span class="comment">// 接收的数据传递到pending_message_buffer中，</span></span><br><span class="line">                            <span class="comment">// process_next_message中进行处理从pending_message_buffer中处理数据</span></span><br><span class="line">                            <span class="keyword">if</span> (!conn-&gt;<span class="built_in">process_next_message</span>(*<span class="keyword">this</span>, message_length)) &#123;</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">auto</span> outstanding_message_bytes = total_message_bytes - bytes_in_buffer;</span><br><span class="line">                            <span class="keyword">auto</span> available_buffer_bytes = conn-&gt;pending_message_buffer.<span class="built_in">bytes_to_write</span>();</span><br><span class="line">                            <span class="keyword">if</span> (outstanding_message_bytes &gt; available_buffer_bytes) &#123;</span><br><span class="line">                                conn-&gt;pending_message_buffer.<span class="built_in">add_space</span>( outstanding_message_bytes - available_buffer_bytes );</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            conn-&gt;outstanding_read_bytes.<span class="built_in">emplace</span>(outstanding_message_bytes);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">start_read_message</span>(conn);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">auto</span> pname = conn-&gt;<span class="built_in">peer_name</span>();</span><br><span class="line">                    <span class="keyword">if</span> (ec.<span class="built_in">value</span>() != boost::asio::error::eof) &#123;</span><br><span class="line">                    <span class="built_in">elog</span>( <span class="string">&quot;Error reading message from $&#123;p&#125;: $&#123;m&#125;&quot;</span>,(<span class="string">&quot;p&quot;</span>,pname)( <span class="string">&quot;m&quot;</span>, ec.<span class="built_in">message</span>() ) );</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">ilog</span>( <span class="string">&quot;Peer $&#123;p&#125; closed connection&quot;</span>,(<span class="string">&quot;p&quot;</span>,pname) );</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">close</span>( conn );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">catch</span>(<span class="type">const</span> std::exception &amp;ex) &#123;</span><br><span class="line">                string pname = conn ? conn-&gt;<span class="built_in">peer_name</span>() : <span class="string">&quot;no connection name&quot;</span>;</span><br><span class="line">                <span class="built_in">elog</span>(<span class="string">&quot;Exception in handling read data from $&#123;p&#125; $&#123;s&#125;&quot;</span>,(<span class="string">&quot;p&quot;</span>,pname)(<span class="string">&quot;s&quot;</span>,ex.<span class="built_in">what</span>()));</span><br><span class="line">                <span class="built_in">close</span>( conn );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">catch</span>(<span class="type">const</span> fc::exception &amp;ex) &#123;</span><br><span class="line">                string pname = conn ? conn-&gt;<span class="built_in">peer_name</span>() : <span class="string">&quot;no connection name&quot;</span>;</span><br><span class="line">                <span class="built_in">elog</span>(<span class="string">&quot;Exception in handling read data $&#123;s&#125;&quot;</span>, (<span class="string">&quot;p&quot;</span>,pname)(<span class="string">&quot;s&quot;</span>,ex.<span class="built_in">to_string</span>()));</span><br><span class="line">                <span class="built_in">close</span>( conn );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">                string pname = conn ? conn-&gt;<span class="built_in">peer_name</span>() : <span class="string">&quot;no connection name&quot;</span>;</span><br><span class="line">                <span class="built_in">elog</span>( <span class="string">&quot;Undefined exception hanlding the read data from connection $&#123;p&#125;&quot;</span>,( <span class="string">&quot;p&quot;</span>,pname));</span><br><span class="line">                <span class="built_in">close</span>( conn );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; );</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        string pname = conn ? conn-&gt;<span class="built_in">peer_name</span>() : <span class="string">&quot;no connection name&quot;</span>;</span><br><span class="line">        <span class="built_in">elog</span>( <span class="string">&quot;Undefined exception handling reading $&#123;p&#125;&quot;</span>,(<span class="string">&quot;p&quot;</span>,pname) );</span><br><span class="line">        <span class="built_in">close</span>( conn );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抛去其中try catch语句，我们重点看到conn-&gt;process_next_message函数，这个函数正如注释所说，从接受到的pending_message_buffer中处理数据，我们继续追踪这个处理函数，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该函数用于数据同步,使用中心消息处理系统处理数据</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">connection::process_next_message</span><span class="params">(net_plugin_impl&amp; impl, <span class="type">uint32_t</span> message_length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> ds = pending_message_buffer.<span class="built_in">create_datastream</span>();</span><br><span class="line">        net_message msg;</span><br><span class="line">        fc::raw::<span class="built_in">unpack</span>(ds, msg);  <span class="comment">// 将解压的ds信息放入msg中</span></span><br><span class="line">        <span class="function">msg_handler <span class="title">m</span><span class="params">(impl, shared_from_this() )</span></span>;</span><br><span class="line">        <span class="comment">// 判断msg的类型，msg可以是带签名的区块或者打包后的交易</span></span><br><span class="line">        <span class="comment">// 如果是区块，获取signed_block后放入m中</span></span><br><span class="line">        <span class="comment">// 如果是trx，则获取packed_trx后放入m中</span></span><br><span class="line">        <span class="keyword">if</span>( msg.<span class="built_in">contains</span>&lt;signed_block&gt;() ) &#123;</span><br><span class="line">        <span class="built_in">m</span>( std::<span class="built_in">move</span>( msg.<span class="built_in">get</span>&lt;signed_block&gt;() ) );</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>( msg.<span class="built_in">contains</span>&lt;packed_transaction&gt;() ) &#123;</span><br><span class="line">        <span class="built_in">m</span>( std::<span class="built_in">move</span>( msg.<span class="built_in">get</span>&lt;packed_transaction&gt;() ) );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        msg.<span class="built_in">visit</span>( m );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span>(  <span class="type">const</span> fc::exception&amp; e ) &#123;</span><br><span class="line">        <span class="built_in">edump</span>((e.<span class="built_in">to_detail_string</span>() ));</span><br><span class="line">        impl.<span class="built_in">close</span>( <span class="built_in">shared_from_this</span>() );</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中重要的是msg_handler类型，这里面分别针对消息不同的类型做不同的处理，首先查看针对如果msg中包含了signed_block，则进入处理block函数；如果msg中包含packed_transaction，则进入处理trx的函数。首先查看msg_handler是如何处理signed_block的，处理区块的函数如下。收到区块之后验证区块，验证通过则接受区块，验证失败则拒绝区块。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果从网络中收到一个区块，执行相应的处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">net_plugin_impl::handle_message</span><span class="params">(<span class="type">const</span> connection_ptr&amp; c, <span class="type">const</span> signed_block_ptr&amp; msg)</span> </span>&#123;</span><br><span class="line">   controller &amp;cc = chain_plug-&gt;<span class="built_in">chain</span>();</span><br><span class="line">   block_id_type blk_id = msg-&gt;<span class="built_in">id</span>();</span><br><span class="line">   <span class="type">uint32_t</span> blk_num = msg-&gt;<span class="built_in">block_num</span>();</span><br><span class="line">   <span class="built_in">fc_dlog</span>(logger, <span class="string">&quot;canceling wait on $&#123;p&#125;&quot;</span>, (<span class="string">&quot;p&quot;</span>,c-&gt;<span class="built_in">peer_name</span>()));</span><br><span class="line">   c-&gt;<span class="built_in">cancel_wait</span>();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>( cc.<span class="built_in">fetch_block_by_id</span>(blk_id)) &#123;</span><br><span class="line">         <span class="comment">// recv_block函数具体含义为止，同步区块数据？不应该是检查在先？</span></span><br><span class="line">         sync_master-&gt;<span class="built_in">recv_block</span>(c, blk_id, blk_num);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="built_in">catch</span>( ...) &#123;</span><br><span class="line">      <span class="comment">// should this even be caught?</span></span><br><span class="line">      <span class="built_in">elog</span>(<span class="string">&quot;Caught an unknown exception trying to recall blockID&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   dispatcher-&gt;<span class="built_in">recv_block</span>(c, blk_id, blk_num);  <span class="comment">// 进行报告，我已经从连接c收到一个编号blk_id和blk_num的区块？</span></span><br><span class="line">   <span class="function">fc::microseconds <span class="title">age</span><span class="params">( fc::time_point::now() - msg-&gt;timestamp)</span></span>;</span><br><span class="line">   <span class="built_in">peer_ilog</span>(c, <span class="string">&quot;received signed_block : #$&#123;n&#125; block age in secs = $&#123;age&#125;&quot;</span>,</span><br><span class="line">           (<span class="string">&quot;n&quot;</span>,blk_num)(<span class="string">&quot;age&quot;</span>,age.<span class="built_in">to_seconds</span>()));</span><br><span class="line"></span><br><span class="line">   go_away_reason reason = fatal_other;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 在chain_plug中再检查其具体含义，看catch中的内容，应该是使用chain_plug对区块进行检查</span></span><br><span class="line">      <span class="comment">// 如果检查无错误，reason的值应该是no_reason</span></span><br><span class="line">      chain_plug-&gt;<span class="built_in">accept_block</span>(msg); <span class="comment">//, sync_master-&gt;is_active(c));</span></span><br><span class="line">      reason = no_reason;</span><br><span class="line">   &#125; <span class="built_in">catch</span>( <span class="type">const</span> unlinkable_block_exception &amp;ex) &#123;</span><br><span class="line">      <span class="built_in">peer_elog</span>(c, <span class="string">&quot;bad signed_block : $&#123;m&#125;&quot;</span>, (<span class="string">&quot;m&quot;</span>,ex.<span class="built_in">what</span>()));</span><br><span class="line">      reason = unlinkable;</span><br><span class="line">   &#125; <span class="built_in">catch</span>( <span class="type">const</span> block_validate_exception &amp;ex) &#123;</span><br><span class="line">      <span class="built_in">peer_elog</span>(c, <span class="string">&quot;bad signed_block : $&#123;m&#125;&quot;</span>, (<span class="string">&quot;m&quot;</span>,ex.<span class="built_in">what</span>()));</span><br><span class="line">      <span class="built_in">elog</span>( <span class="string">&quot;block_validate_exception accept block #$&#123;n&#125; syncing from $&#123;p&#125;&quot;</span>,(<span class="string">&quot;n&quot;</span>,blk_num)(<span class="string">&quot;p&quot;</span>,c-&gt;<span class="built_in">peer_name</span>()));</span><br><span class="line">      reason = validation;</span><br><span class="line">   &#125; <span class="built_in">catch</span>( <span class="type">const</span> assert_exception &amp;ex) &#123;</span><br><span class="line">      <span class="built_in">peer_elog</span>(c, <span class="string">&quot;bad signed_block : $&#123;m&#125;&quot;</span>, (<span class="string">&quot;m&quot;</span>,ex.<span class="built_in">what</span>()));</span><br><span class="line">      <span class="built_in">elog</span>( <span class="string">&quot;unable to accept block on assert exception $&#123;n&#125; from $&#123;p&#125;&quot;</span>,(<span class="string">&quot;n&quot;</span>,ex.<span class="built_in">to_string</span>())(<span class="string">&quot;p&quot;</span>,c-&gt;<span class="built_in">peer_name</span>()));</span><br><span class="line">   &#125; <span class="built_in">catch</span>( <span class="type">const</span> fc::exception &amp;ex) &#123;</span><br><span class="line">      <span class="built_in">peer_elog</span>(c, <span class="string">&quot;bad signed_block : $&#123;m&#125;&quot;</span>, (<span class="string">&quot;m&quot;</span>,ex.<span class="built_in">what</span>()));</span><br><span class="line">      <span class="built_in">elog</span>( <span class="string">&quot;accept_block threw a non-assert exception $&#123;x&#125; from $&#123;p&#125;&quot;</span>,( <span class="string">&quot;x&quot;</span>,ex.<span class="built_in">to_string</span>())(<span class="string">&quot;p&quot;</span>,c-&gt;<span class="built_in">peer_name</span>()));</span><br><span class="line">      reason = no_reason;</span><br><span class="line">   &#125; <span class="built_in">catch</span>( ...) &#123;</span><br><span class="line">      <span class="built_in">peer_elog</span>(c, <span class="string">&quot;bad signed_block : unknown exception&quot;</span>);</span><br><span class="line">      <span class="built_in">elog</span>( <span class="string">&quot;handle sync block caught something else from $&#123;p&#125;&quot;</span>,(<span class="string">&quot;num&quot;</span>,blk_num)(<span class="string">&quot;p&quot;</span>,c-&gt;<span class="built_in">peer_name</span>()));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function">update_block_num <span class="title">ubn</span><span class="params">(blk_num)</span></span>;</span><br><span class="line">   <span class="keyword">if</span>( reason == no_reason ) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;recpt : msg-&gt;transactions) &#123;</span><br><span class="line">         <span class="keyword">auto</span> id = (recpt.trx.<span class="built_in">which</span>() == <span class="number">0</span>) ? recpt.trx.<span class="built_in">get</span>&lt;transaction_id_type&gt;() : recpt.trx.<span class="built_in">get</span>&lt;packed_transaction&gt;().<span class="built_in">id</span>();</span><br><span class="line">         <span class="keyword">auto</span> ltx = local_txns.<span class="built_in">get</span>&lt;by_id&gt;().<span class="built_in">find</span>(id);</span><br><span class="line">         <span class="keyword">if</span>( ltx != local_txns.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            local_txns.<span class="built_in">modify</span>( ltx, ubn );</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">auto</span> ctx = c-&gt;trx_state.<span class="built_in">get</span>&lt;by_id&gt;().<span class="built_in">find</span>(id);</span><br><span class="line">         <span class="keyword">if</span>( ctx != c-&gt;trx_state.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            c-&gt;trx_state.<span class="built_in">modify</span>( ctx, ubn );</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 这里再次进行recv_block，不明白其含义</span></span><br><span class="line">      sync_master-&gt;<span class="built_in">recv_block</span>(c, blk_id, blk_num);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 验证区块过程中出现错误，直接拒绝这个区块</span></span><br><span class="line">      sync_master-&gt;<span class="built_in">rejected_block</span>(c, blk_num);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对交易的验证与对区块的处理方式相同，验证交易，如果本地存在此交易，则丢弃，否则开始验证交易，若验证通过则接受交易并广播交易，否则拒绝交易。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">net_plugin_impl::handle_message</span><span class="params">(<span class="type">const</span> connection_ptr&amp; c, <span class="type">const</span> packed_transaction_ptr&amp; trx)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fc_dlog</span>(logger, <span class="string">&quot;got a packed transaction, cancel wait&quot;</span>);</span><br><span class="line">    <span class="built_in">peer_ilog</span>(c, <span class="string">&quot;received packed_transaction&quot;</span>);</span><br><span class="line">    controller&amp; cc = my_impl-&gt;chain_plug-&gt;<span class="built_in">chain</span>();</span><br><span class="line">    <span class="keyword">if</span>( cc.<span class="built_in">get_read_mode</span>() == eosio::db_read_mode::READ_ONLY ) &#123;</span><br><span class="line">        <span class="built_in">fc_dlog</span>(logger, <span class="string">&quot;got a txn in read-only mode - dropping&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( sync_master-&gt;<span class="built_in">is_active</span>(c) ) &#123;</span><br><span class="line">        <span class="built_in">fc_dlog</span>(logger, <span class="string">&quot;got a txn during sync - dropping&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ptrx = std::<span class="built_in">make_shared</span>&lt;transaction_metadata&gt;( trx );</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; tid = ptrx-&gt;id;</span><br><span class="line"></span><br><span class="line">    c-&gt;<span class="built_in">cancel_wait</span>();</span><br><span class="line">    <span class="keyword">if</span>(local_txns.<span class="built_in">get</span>&lt;by_id&gt;().<span class="built_in">find</span>(tid) != local_txns.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="built_in">fc_dlog</span>(logger, <span class="string">&quot;got a duplicate transaction - dropping&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dispatcher-&gt;<span class="built_in">recv_transaction</span>(c, tid);</span><br><span class="line">    <span class="comment">// 验证交易</span></span><br><span class="line">    chain_plug-&gt;<span class="built_in">accept_transaction</span>(ptrx, [c, <span class="keyword">this</span>, ptrx](<span class="type">const</span> static_variant&lt;fc::exception_ptr, transaction_trace_ptr&gt;&amp; result) &#123;</span><br><span class="line">        <span class="keyword">if</span> (result.<span class="built_in">contains</span>&lt;fc::exception_ptr&gt;()) &#123;</span><br><span class="line">        <span class="built_in">peer_dlog</span>(c, <span class="string">&quot;bad packed_transaction : $&#123;m&#125;&quot;</span>, (<span class="string">&quot;m&quot;</span>,result.<span class="built_in">get</span>&lt;fc::exception_ptr&gt;()-&gt;<span class="built_in">what</span>()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> trace = result.<span class="built_in">get</span>&lt;transaction_trace_ptr&gt;();</span><br><span class="line">        <span class="keyword">if</span> (!trace-&gt;except) &#123;</span><br><span class="line">            <span class="built_in">fc_dlog</span>(logger, <span class="string">&quot;chain accepted transaction&quot;</span>);</span><br><span class="line">            <span class="comment">// 广播交易</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;dispatcher-&gt;<span class="built_in">bcast_transaction</span>(ptrx);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">peer_elog</span>(c, <span class="string">&quot;bad packed_transaction : $&#123;m&#125;&quot;</span>, (<span class="string">&quot;m&quot;</span>,trace-&gt;except-&gt;<span class="built_in">what</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 拒绝交易</span></span><br><span class="line">        dispatcher-&gt;<span class="built_in">rejected_transaction</span>(ptrx-&gt;id);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>至此，net_plugin以及net_plugin_impl插件中的比较重要的函数已经分析完毕，由于其中细节错综复杂，因此在分析过程中抓住主要脉络进行分析，对于其他细节内容并没有深究。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hzxgoforward.github.io/2019/03/20/EOS%E4%B8%ADplugin%E4%B9%8Bproducer_plugin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌虎下山">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/20/EOS%E4%B8%ADplugin%E4%B9%8Bproducer_plugin/" class="post-title-link" itemprop="https://hzxgoforward.github.io/index.html">EOS中plugin之producer_plugin</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建于：2019-03-20 18:29:54" itemprop="dateCreated datePublished" datetime="2019-03-20T18:29:54+08:00">2019-03-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="更新于：2019-11-08 14:59:28" itemprop="dateModified" datetime="2019-11-08T14:59:28+08:00">2019-11-08</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/" itemprop="url" rel="index"><span itemprop="name">区块链技术研究</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          


          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="eos中plugin之producer_plugin"><a class="markdownIt-Anchor" href="#eos中plugin之producer_plugin"></a> EOS中plugin之producer_plugin</h1>
<p>EOS中的插件是非常重要的工具，其中大大小小总共有26个插件，其中比较重要的插件有chain_plugin、producer_plugin、http_plugin、net_plugin等四个插件。这四个插件在EOS服务器端启动后也开始启动进行工作。</p>
<h2 id="abstract_plugin"><a class="markdownIt-Anchor" href="#abstract_plugin"></a> abstract_plugin</h2>
<p>EOS中所有插件继承于plugin类，而plugin类又继承于abstract_plugin类。<br />
abstract_plugin中规定了每个插件的4个状态，这4个状态依次如下。</p>
<ul>
<li>registered，表示插件已经注册， 每个插件初始化后就是注册的状态。</li>
<li>initialized，表示插件已经初始化，插件之后注册之后才能初始化。</li>
<li>started， 表示插件正在运行中。</li>
<li>stopped，表示插件停止运行。</li>
</ul>
<p>下面是abstract_plugin的源代码，由于是个抽象类，abstract_plugin定义在appbase\appbase\plugin.hpp中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">abstract_plugin</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 插件的4个状态。</span></span><br><span class="line">        <span class="keyword">enum</span> <span class="title class_">state</span> &#123;</span><br><span class="line">        registered, <span class="comment">///&lt; the plugin is constructed but doesn&#x27;t do anything</span></span><br><span class="line">        initialized, <span class="comment">///&lt; the plugin has initialized any state required but is idle</span></span><br><span class="line">        started, <span class="comment">///&lt; the plugin is actively running</span></span><br><span class="line">        stopped <span class="comment">///&lt; the plugin is no longer running</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">abstract_plugin</span>()&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> state <span class="title">get_state</span><span class="params">()</span><span class="type">const</span> </span>= <span class="number">0</span>; <span class="comment">// 查询插件当前的状态</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> std::string&amp; <span class="title">name</span><span class="params">()</span><span class="type">const</span>  </span>= <span class="number">0</span>;    <span class="comment">// 获取插件名称</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">set_program_options</span><span class="params">( options_description&amp; cli, options_description&amp; cfg )</span> </span>= <span class="number">0</span>;                 <span class="comment">// 设置插件参数</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">initialize</span><span class="params">(<span class="type">const</span> variables_map&amp; options)</span> </span>= <span class="number">0</span>;<span class="comment">//初始化插件</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handle_sighup</span><span class="params">()</span> </span>= <span class="number">0</span>;               <span class="comment">// 这个干嘛用的不清楚</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">startup</span><span class="params">()</span> </span>= <span class="number">0</span>;                     <span class="comment">// 启动插件</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>= <span class="number">0</span>;                    <span class="comment">// 关闭插件</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="plugin"><a class="markdownIt-Anchor" href="#plugin"></a> plugin</h2>
<p>plugin这个类继承了abstract_plugin，plugin的代码在appbase\apppbase\apllication.hpp中，这里比较奇怪的是，为什么plugin的定义不再plugin.hpp文件中，而plugin.hpp中定义了abstract_plugin类。</p>
<p>plugin是一个模板类，在plugin中，除去handle_sighup函数之外，已经实现了abstract_plugin中的全部纯虚函数。handle_sighup函数的含义，目前我不太清楚。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Impl&gt;</span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">plugin</span> : <span class="keyword">public</span> abstract_plugin &#123;</span><br><span class="line">      <span class="keyword">public</span>:</span><br><span class="line">         <span class="built_in">plugin</span>():_name(boost::core::<span class="built_in">demangle</span>(<span class="built_in">typeid</span>(Impl).<span class="built_in">name</span>()))&#123;&#125;</span><br><span class="line">         <span class="keyword">virtual</span> ~<span class="built_in">plugin</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">virtual</span> state <span class="title">get_state</span><span class="params">()</span><span class="type">const</span> <span class="keyword">override</span>         </span>&#123; <span class="keyword">return</span> _state; &#125;</span><br><span class="line">         <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> std::string&amp; <span class="title">name</span><span class="params">()</span><span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> _name; &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">register_dependencies</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">static_cast</span>&lt;Impl*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">plugin_requires</span>([&amp;](<span class="keyword">auto</span>&amp; plug)&#123;&#125;);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">initialize</span><span class="params">(<span class="type">const</span> variables_map&amp; options)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(_state == registered) &#123;</span><br><span class="line">               _state = initialized;</span><br><span class="line">               <span class="built_in">static_cast</span>&lt;Impl*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">plugin_requires</span>([&amp;](<span class="keyword">auto</span>&amp; plug)&#123; plug.<span class="built_in">initialize</span>(options); &#125;);</span><br><span class="line">               <span class="built_in">static_cast</span>&lt;Impl*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">plugin_initialize</span>(options);</span><br><span class="line">               <span class="comment">//ilog( &quot;initializing plugin $&#123;name&#125;&quot;, (&quot;name&quot;,name()) );</span></span><br><span class="line">               <span class="built_in">app</span>().<span class="built_in">plugin_initialized</span>(*<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">assert</span>(_state == initialized); <span class="comment">/// if initial state was not registered, final state cannot be initialized</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handle_sighup</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 插件启动函数</span></span><br><span class="line">         <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">startup</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(_state == initialized) &#123;</span><br><span class="line">               _state = started;</span><br><span class="line">               <span class="built_in">static_cast</span>&lt;Impl*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">plugin_requires</span>([&amp;](<span class="keyword">auto</span>&amp; plug)&#123; plug.<span class="built_in">startup</span>(); &#125;);</span><br><span class="line">               <span class="built_in">static_cast</span>&lt;Impl*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">plugin_startup</span>();</span><br><span class="line">               <span class="built_in">app</span>().<span class="built_in">plugin_started</span>(*<span class="keyword">this</span>);     <span class="comment">// </span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">assert</span>(_state == started); <span class="comment">// if initial state was not initialized, final state cannot be started</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">shutdown</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(_state == started) &#123;</span><br><span class="line">               _state = stopped;</span><br><span class="line">               <span class="comment">//ilog( &quot;shutting down plugin $&#123;name&#125;&quot;, (&quot;name&quot;,name()) );</span></span><br><span class="line">               <span class="built_in">static_cast</span>&lt;Impl*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">plugin_shutdown</span>();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">protected</span>:</span><br><span class="line">         <span class="built_in">plugin</span>(<span class="type">const</span> string&amp; name) : _name(name)&#123;&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span>:</span><br><span class="line">         state _state = abstract_plugin::registered;</span><br><span class="line">         std::string _name;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
<p>首先可以看到plugin的初始化函数，由于plugin是一个模板类，在初始化过程中，传入的模板类的名称赋值给了plugin的protected变量_name，里面唯一不太理解的是，为什么这个_name是protected的类型而不是private类型。typeid在头文件typeindex中，主要是获得某个类的名称。</p>
<p>此外，plugin中实现了插件的startup()、initialized()和shutdown()三个功能。在initialize()函数中，首先判断当前状态是否是registered状态，随后更改状态为initialized状态，然后查询当前插件依赖的其他插件并且将其他插件初始化，随后初始化插件自身。注意到插件启动完成后有如下一句代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">app</span>().<span class="built_in">plugin_initialized</span>(*<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>app()函数返回客户端的引用，随后客户端将当前初始化的插件变量放入到当前客户端中已初始化插件的vector中。</p>
<p>在startup()之前，可以看到，插件启动之前，其状态必须是已经初始化的状态，这表明插件启动之前必须初始化。随后设置状态为启动状态。然后查询当前插件启动需要的其他插件并启动这些插件，随后再启动插件自身，随后客户端将当前已启动的插件变量放入到当前客户端中已启动插件的vector中。</p>
<p>在shutdown()函数中，特别厉害的一个设计就是关闭插件的调用，因为不同的插件，可能关闭方式不一样，但是在plugin中仍然也实现了这个方法，实在是太巧妙了。最精髓的就是这句代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_cast</span>&lt;Impl*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">plugin_shutdown</span>();</span><br></pre></td></tr></table></figure>
<p>将当前指针转换成模板类初始化时传进的类，然后调用这个类的plugin_shutdown()函数。好像很牛批，可是我仔细一想，最后不还是调用每个类自己的plugin_shutdown()函数了吗，每个类中自己实现这个功能好像也可以，这样设计就是看起来很牛批，但是没什么卵用，奇技淫巧而已~</p>
<p>现在介绍下EOS具体的插件，producer_plugin，这个插件主要负责超级节点的区块生产、同步以及新区快的校验工作，是4个插件里面最重要的一个插件。</p>
<h2 id="producer_plugin"><a class="markdownIt-Anchor" href="#producer_plugin"></a> producer_plugin</h2>
<h3 id="1-producer_pluginhpp"><a class="markdownIt-Anchor" href="#1-producer_pluginhpp"></a> （1）. producer_plugin.hpp</h3>
<p>producer_plugin插件的实现位于plugins\producer_plugin下。producer_plugin类的定义，就很头铁，定义方式如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">producer_plugin</span> : <span class="keyword">public</span> appbase::plugin&lt;producer_plugin&gt;&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在定义的过程中就传入了producer_plugin的类名，这个名称会传给plugin中的_name变量。<br />
为什么会有appbase这个玩意儿呢，因为这是一个命名空间，plugin就定义在appbase命名空间中。</p>
<p>接下来我们看看producer_plugin的头文件，由于头文件比较长，口味略重，非战斗人员请迅速撤离。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">producer_plugin</span> : <span class="keyword">public</span> appbase::plugin&lt;producer_plugin&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">APPBASE_PLUGIN_REQUIRES</span>((chain_plugin)(http_client_plugin))</span><br><span class="line"></span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">runtime_options</span> &#123;</span><br><span class="line">      fc::optional&lt;<span class="type">int32_t</span>&gt; max_transaction_time;</span><br><span class="line">      fc::optional&lt;<span class="type">int32_t</span>&gt; max_irreversible_block_age;</span><br><span class="line">      fc::optional&lt;<span class="type">int32_t</span>&gt; produce_time_offset_us;</span><br><span class="line">      fc::optional&lt;<span class="type">int32_t</span>&gt; last_block_time_offset_us;</span><br><span class="line">      fc::optional&lt;<span class="type">int32_t</span>&gt; max_scheduled_transaction_time_per_block_ms;</span><br><span class="line">      fc::optional&lt;<span class="type">int32_t</span>&gt; subjective_cpu_leeway_us;</span><br><span class="line">      fc::optional&lt;<span class="type">double</span>&gt;  incoming_defer_ratio;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">whitelist_blacklist</span> &#123;</span><br><span class="line">      fc::optional&lt; flat_set&lt;account_name&gt; &gt; actor_whitelist;</span><br><span class="line">      fc::optional&lt; flat_set&lt;account_name&gt; &gt; actor_blacklist;</span><br><span class="line">      fc::optional&lt; flat_set&lt;account_name&gt; &gt; contract_whitelist;</span><br><span class="line">      fc::optional&lt; flat_set&lt;account_name&gt; &gt; contract_blacklist;</span><br><span class="line">      fc::optional&lt; flat_set&lt; std::pair&lt;account_name, action_name&gt; &gt; &gt; action_blacklist;</span><br><span class="line">      fc::optional&lt; flat_set&lt;public_key_type&gt; &gt; key_blacklist;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">greylist_params</span> &#123;</span><br><span class="line">      std::vector&lt;account_name&gt; accounts;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">integrity_hash_information</span> &#123;</span><br><span class="line">      chain::block_id_type head_block_id;</span><br><span class="line">      chain::digest_type   integrity_hash;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">snapshot_information</span> &#123;</span><br><span class="line">      chain::block_id_type head_block_id;</span><br><span class="line">      std::string          snapshot_name;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">producer_plugin</span>();</span><br><span class="line">   <span class="keyword">virtual</span> ~<span class="built_in">producer_plugin</span>();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">set_program_options</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      boost::program_options::options_description &amp;command_line_options,</span></span></span><br><span class="line"><span class="params"><span class="function">      boost::program_options::options_description &amp;config_file_options</span></span></span><br><span class="line"><span class="params"><span class="function">      )</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 判断一个公钥是否是当前区块生产者的公钥</span></span><br><span class="line">   <span class="function"><span class="type">bool</span>                   <span class="title">is_producer_key</span><span class="params">(<span class="type">const</span> chain::public_key_type&amp; key)</span> <span class="type">const</span></span>; </span><br><span class="line">   <span class="comment">// 应该是对摘要进行签名，这里面的key应该是私钥。        </span></span><br><span class="line">   <span class="function">chain::signature_type  <span class="title">sign_compact</span><span class="params">(<span class="type">const</span> chain::public_key_type&amp; key, <span class="type">const</span> fc::sha256&amp; digest)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 对插件进行初始化</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">plugin_initialize</span><span class="params">(<span class="type">const</span> boost::program_options::variables_map&amp; options)</span></span>;</span><br><span class="line">   <span class="comment">// 插件启动函数</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">plugin_startup</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="comment">// 插件关闭函数</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">plugin_shutdown</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="comment">// 暂停运行和继续运行</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">pause</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="comment">// 返回插件是否被暂停的状态</span></span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">paused</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 更新运行的相关参数</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">update_runtime_options</span><span class="params">(<span class="type">const</span> runtime_options&amp; options)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取运行时的相关参数</span></span><br><span class="line">   <span class="function">runtime_options <span class="title">get_runtime_options</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 增加grey_list</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">add_greylist_accounts</span><span class="params">(<span class="type">const</span> greylist_params&amp; params)</span></span>;</span><br><span class="line">   <span class="comment">// 删除grey_list</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">remove_greylist_accounts</span><span class="params">(<span class="type">const</span> greylist_params&amp; params)</span></span>;</span><br><span class="line">   <span class="comment">// 获取greylist</span></span><br><span class="line">   <span class="function">greylist_params <span class="title">get_greylist</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取whitelist和设置whitelist</span></span><br><span class="line">   <span class="function">whitelist_blacklist <span class="title">get_whitelist_blacklist</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">set_whitelist_blacklist</span><span class="params">(<span class="type">const</span> whitelist_blacklist&amp; params)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取integrity_hash_information</span></span><br><span class="line">   <span class="function">integrity_hash_information <span class="title">get_integrity_hash</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 创建一个快照，snapshot中文意思是快照</span></span><br><span class="line">   <span class="function">snapshot_information <span class="title">create_snapshot</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 定义一个返回值为空，传入变量为const chain::producer_confirmation&amp;的signal</span></span><br><span class="line">   <span class="comment">// 这个信号用于区块的确认。</span></span><br><span class="line">   signal&lt;<span class="built_in">void</span>(<span class="type">const</span> chain::producer_confirmation&amp;)&gt; confirmed_block;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// producer_plugin_impl的指针,负责所有任务的执行</span></span><br><span class="line">    <span class="comment">// producer_plugin_impl类的定义在producer_plugin.cpp中</span></span><br><span class="line">   std::shared_ptr&lt;<span class="keyword">class</span> <span class="title class_">producer_plugin_impl</span>&gt; my; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>producer_plugin定义完毕之后第一个public函数就很恶心咯，这是什么鬼!!!仔细看看这些大写字母的定义，转换成小写字母，即appbase_plugin_requires,还记得前面说每个插件初始化或者启动的时候都要初始化或者启动它依赖的插件这个过程吗？这感觉应该是说producer_plugin类启动的时候依赖chain_plugin和http_client_plugin两个插件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">APPBASE_PLUGIN_REQUIRES</span>((chain_plugin)(http_client_plugin))</span><br></pre></td></tr></table></figure>
<p>大写的显示，应该是说明这一个宏定义，果然，我们翻了一下，宏定义在plugin.hpp文件中，具体定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> APPBASE_PLUGIN_REQUIRES( PLUGINS )                               \</span></span><br><span class="line"><span class="meta">   template<span class="string">&lt;typename Lambda&gt;</span>                                           \</span></span><br><span class="line"><span class="meta">   void plugin_requires( Lambda&amp;&amp; l ) &#123;                                \</span></span><br><span class="line"><span class="meta">      BOOST_PP_SEQ_FOR_EACH( APPBASE_PLUGIN_REQUIRES_VISIT, l, PLUGINS ) \</span></span><br><span class="line"><span class="meta">   &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APPBASE_PLUGIN_REQUIRES_VISIT( r, visitor, elem ) \</span></span><br><span class="line"><span class="meta">  visitor( appbase::app().register_plugin<span class="string">&lt;elem&gt;</span>() ) </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>哇~~~，越来越恶心了,这个宏定义，指向一个模板函数，这个模板函数的参数是一个函数，里面用到了BOOST_PP_SEQ_FOR_EACH，这个一般如下用法：</p>
<ul>
<li>BOOST_PP_SEQ_FOR_EACH(macro, r, data)</li>
<li>macro，一个以格式macro(r, data, elem)定义的三元宏。该宏被BOOST_PP_SEQ_FOR_EACH按照seq中每个元素进行展开。展开该宏，需要用到下一个BOOST_PP_FOR的重复项、备用数据data和当前元素。</li>
<li>data，备用数据，用于传给macro。</li>
<li>seq，用于供macro按照哪个序列进行展开。</li>
</ul>
<p>具体的细节尚未弄清楚，但是明确的是，这个hpp文件可以看出producer_plugin插件依赖两个插件，即chain_plugin和http_client_plugin。</p>
<p>随后再producer_plugin中定义了一系列结构体。这些结构体都用到了一个optional的类。简单地来说，这个类类似于boost::optional的概念，主要用于实现未初始化的概念。函数并不能总是返回有意义的结果，有时候函数可能返回“无意义”的值，一般来说我们通常使用一个不再正常解空间的一个哨兵来表示无意义的概念，如NULL，-1，end()或者EOF.然后对于不同的应用场合，这些哨兵并不是通用的，而且有时候可能不存在这种解空间之外的哨兵。optional很像一个仅能存放一个元素的容器，它实现了&quot;未初始化&quot;的概念：如果元素未初始化，那么容器就是空的，否则，容器内就是有效的，已经初始化的值。optional的真实接口很复杂，因为它要能包装任何的类型。</p>
<p>定义的这些结构体，我想应该是producer_plugin运行时配置的一些参数，大致知道这个概念即可。随后是producer_plugin的构造函数、析构函数以及设置参数的函数。更加详细的内容，我已经写在注释中，可以参看，至于producer_plugin中一些方法的具体实现，暂时不予理会，知道其作用就可以了。</p>
<h3 id="2-plugin_startup"><a class="markdownIt-Anchor" href="#2-plugin_startup"></a> （2）. plugin_startup</h3>
<p>producer_plugin.cpp中插件的plugin_shutdown, pause, resume等函数不是很重要，因此这里不再介绍。但是中最重要的一个函数是plugin_startup函数，nodeos节点启动之后，启动producer_plugin插件的接口就是这个函数，这里需对这个函数进行详细的解析，但是我们仍然会跳过一些细枝末节的东西，重点看其主要脉络。由于源码中这个函数内容比较多，这里不再展示源码，直接从主要流程开始。</p>
<p>在函数里面首先获取一个变量：chain</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chain::controller &amp;chain = my-&gt;chain-&gt;chain_plug-&gt;<span class="built_in">chain</span>()</span><br></pre></td></tr></table></figure>
<p>my是一个produer_plugin_impl类的智能指针，这个指针具体负责交易的打包、区块的生产和检查等工作。通过chain可以访问到区块链上的一些信息。</p>
<p>随后chain连接两个信号量，分别执行的函数是on_block()和on_irreversible_block。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my-&gt;_accepted_block_connection.<span class="built_in">emplace</span>(chain.accepted_block.<span class="built_in">connect</span>([<span class="keyword">this</span>](<span class="type">const</span> <span class="keyword">auto</span> &amp;bsp) &#123; my-&gt;<span class="built_in">on_block</span>(bsp); &#125;));</span><br><span class="line">      my-&gt;_irreversible_block_connection.<span class="built_in">emplace</span>(chain.irreversible_block.<span class="built_in">connect</span>([<span class="keyword">this</span>](<span class="type">const</span> <span class="keyword">auto</span> &amp;bsp) &#123; my-&gt;<span class="built_in">on_irreversible_block</span>(bsp-&gt;block); &#125;));</span><br></pre></td></tr></table></figure>
<p>在boost中，进行connect之后返回一个connection的对象，my将返回的两个对象放入自己的connection容器中。</p>
<p>随后获得了区块链上最近的一个不可逆区块的块号和其指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span> lib_num = chain.<span class="built_in">last_irreversible_block_num</span>();<span class="comment">// 返回块号</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> lib = chain.<span class="built_in">fetch_block_by_number</span>(lib_num); <span class="comment">// 返回指针</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果当前区块指针不为空，则进入my-&gt;on_irreversible_block(lib)函数。my-&gt;on_irreversible_block函数就是将不可逆区块的时间设置为lib指向的区块的时间。<br />
如果lib指针为空，设置不可逆区块的时间为当前时间的最大值，即设置为0xffffffff秒，时间大致为139年，那时候BM应该早就跪了~</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lib)&#123;</span><br><span class="line">   my-&gt;<span class="built_in">on_irreversible_block</span>(lib);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="comment">// maximum 大致是136年</span></span><br><span class="line">   my-&gt;_irreversible_block_time = fc::time_point::<span class="built_in">maximum</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，判断my中的区块生产者列表是否为空，若当前节点可以生产区块，如果是第一次接入的超节点，则展示new_chain_banner标志。随后开始进入区块生产的大循环中，区块生产的函是由my控制的。看起来my这个插件无法避免的需要介绍了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (my-&gt;_production_enabled)&#123;</span><br><span class="line">   <span class="keyword">if</span> (chain.<span class="built_in">head_block_num</span>() == <span class="number">0</span>)</span><br><span class="line">   &#123; <span class="comment">// 如果是创世块，展示新区块的标语</span></span><br><span class="line">      <span class="built_in">new_chain_banner</span>(chain);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//_production_skip_flags |= eosio::chain::skip_undo_history_check;</span></span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">// 开始进入区块生产循环中,持续不断的开始生产区块</span></span><br><span class="line">   my-&gt;<span class="built_in">schedule_production_loop</span>();</span><br></pre></td></tr></table></figure>
<p>至此，plugin_startup函数的主要情况已经介绍完毕，my-&gt;schedule_produetion_loop函数的介绍，将在produer_plugin_impl类的介绍中进行。</p>
<h2 id="producer_plugin_impl"><a class="markdownIt-Anchor" href="#producer_plugin_impl"></a> producer_plugin_impl</h2>
<h3 id="producer_plugin_impl类中的变量"><a class="markdownIt-Anchor" href="#producer_plugin_impl类中的变量"></a> producer_plugin_impl类中的变量</h3>
<p>produer_plugin_impl类的定义，上来我就懵逼了，这是什么！！！enable_shared_from_this也是一个类，但是这种继承的形式到底是怎么肥四？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">producer_plugin_impl</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;producer_plugin_impl&gt;</span><br></pre></td></tr></table></figure>
<p>查了一下网上的解释，enable_shared_from_this是c++ 11的新特性，使用这个特性就可以获得一个对象的多个shared_ptr指针，但是又不会造成对象的多次释放问题。具体的解释可以参看下面两个链接：</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/712279/what-is-the-usefulness-of-enable-shared-from-this">stack overflow</a></p>
<p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/memory/enable_shared_from_this">cpp reference</a></p>
<p>其初始化函数只有1个，里面_timer完成io操作，_transaction_ack_channel主要接收交易，具体形式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">producer_plugin_impl</span>(boost::asio::io_service &amp;io)</span><br><span class="line">      : _timer(io), _transaction_ack_channel(<span class="built_in">app</span>().<span class="built_in">get_channel</span>&lt;compat::channels::transaction_ack&gt;())&#123;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>老实说，produer_plugin_impl中定义的变量很多，这些变量都是public属性。因为这个类具体负责区块生产，因此涉及到的事务非常繁杂，所以变量比较多也算正常。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">optional&lt;fc::time_point&gt; <span class="title">calculate_next_block_time</span><span class="params">(<span class="type">const</span> account_name &amp;producer_name, <span class="type">const</span> block_timestamp_type &amp;current_block_time)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">schedule_production_loop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">produce_block</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">maybe_produce_block</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">boost::program_options::variables_map _options;  <span class="comment">// 程序启动的一些选项</span></span><br><span class="line"><span class="type">bool</span> _production_enabled = <span class="literal">false</span>;   <span class="comment">//能够生产区块</span></span><br><span class="line"><span class="type">bool</span> _pause_production = <span class="literal">false</span>;     <span class="comment">// 是否暂停生产</span></span><br><span class="line"><span class="type">uint32_t</span> _production_skip_flags = <span class="number">0</span>; <span class="comment">//eosio::chain::skip_nothing;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是啥玩意，我不明白</span></span><br><span class="line"><span class="keyword">using</span> signature_provider_type = std::function&lt;chain::<span class="built_in">signature_type</span>(chain::digest_type)&gt;; </span><br><span class="line"><span class="comment">// 映射公钥和签名</span></span><br><span class="line">std::map&lt;chain::public_key_type, signature_provider_type&gt; _signature_providers;</span><br><span class="line">std::set&lt;chain::account_name&gt; _producers; <span class="comment">// BP名单</span></span><br><span class="line">boost::asio::deadline_timer _timer;       <span class="comment">// 负责io的_timer</span></span><br><span class="line">std::map&lt;chain::account_name, <span class="type">uint32_t</span>&gt; _producer_watermarks;  <span class="comment">// BP的水印</span></span><br><span class="line">pending_block_mode _pending_block_mode;                        <span class="comment">// 添加区块的模式，producing和speculate两个模式</span></span><br><span class="line">transaction_id_with_expiry_index _persistent_transactions;     <span class="comment">// 过期的交易</span></span><br><span class="line">fc::optional&lt;boost::asio::thread_pool&gt; _thread_pool;           <span class="comment">// 线程池</span></span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> _max_transaction_time_ms;                              <span class="comment">// 交易的延迟时间</span></span><br><span class="line">fc::microseconds _max_irreversible_block_age_us;</span><br><span class="line"><span class="comment">// 非最后一个区块产生时间的偏移量，按微秒计算。负值会导致块更早出去，正值会导致块更晚出去。</span></span><br><span class="line"><span class="type">int32_t</span> _produce_time_offset_us = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 最后一个区块产生时间的偏移量，按微秒计算。负值会导致块更早出去，正值会导致块更晚出去。</span></span><br><span class="line"><span class="type">int32_t</span> _last_block_time_offset_us = <span class="number">0</span>;</span><br><span class="line"><span class="type">int32_t</span> _max_scheduled_transaction_time_per_block_ms;          <span class="comment">// 一个区块全部交易打包完毕的最大时间耗费</span></span><br><span class="line"></span><br><span class="line">fc::time_point _irreversible_block_time;                       <span class="comment">// 不可逆区块的时间</span></span><br><span class="line">fc::microseconds _keosd_provider_timeout_us;                   <span class="comment">// 钱包客户端超时时间 us为单位</span></span><br><span class="line"></span><br><span class="line">time_point _last_signed_block_time;                            <span class="comment">// 最近一个签名区块的时间</span></span><br><span class="line">time_point _start_time = fc::time_point::<span class="built_in">now</span>();                <span class="comment">// 启动时间，当前时间</span></span><br><span class="line"><span class="type">uint32_t</span> _last_signed_block_num = <span class="number">0</span>;                           <span class="comment">// 最近一个签名区块的块号</span></span><br><span class="line"></span><br><span class="line">producer_plugin *_self = <span class="literal">nullptr</span>;                              <span class="comment">// 指向producer_plugin的指针</span></span><br><span class="line">chain_plugin *chain_plug = <span class="literal">nullptr</span>;                            <span class="comment">// 指向chain_plugin的指针</span></span><br><span class="line"></span><br><span class="line">incoming::channels::block::channel_type::handle _incoming_block_subscription; <span class="comment">// 订阅收到的区块？</span></span><br><span class="line">incoming::channels::transaction::channel_type::handle _incoming_transaction_subscription; <span class="comment">// 订阅收到交易？</span></span><br><span class="line"></span><br><span class="line">compat::channels::transaction_ack::channel_type &amp;_transaction_ack_channel;    <span class="comment">// 接收交易的通道</span></span><br><span class="line"></span><br><span class="line">incoming::methods::block_sync::method_type::handle _incoming_block_sync_provider;   <span class="comment">// 同步区块的数据提供方</span></span><br><span class="line">incoming::methods::transaction_async::method_type::handle _incoming_transaction_async_provider; <span class="comment">// 同步交易的数据提供方</span></span><br><span class="line"></span><br><span class="line">transaction_id_with_expiry_index _blacklisted_transactions;       <span class="comment">// 超时交易的id</span></span><br><span class="line"></span><br><span class="line">fc::optional&lt;scoped_connection&gt; _accepted_block_connection;       <span class="comment">// 存储已经接收区块的connection</span></span><br><span class="line">fc::optional&lt;scoped_connection&gt; _irreversible_block_connection;   <span class="comment">// 存储不可逆区块的connection</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      * HACK ALERT</span></span><br><span class="line"><span class="comment">      * Boost timers can be in a state where a handler has not yet executed but is not abortable.</span></span><br><span class="line"><span class="comment">      * As this method needs to mutate state handlers depend on for proper functioning to maintain</span></span><br><span class="line"><span class="comment">      * invariants for other code (namely accepting incoming transactions in a nearly full block)</span></span><br><span class="line"><span class="comment">      * the handlers capture a corelation ID at the time they are set.  When they are executed</span></span><br><span class="line"><span class="comment">      * they must check that correlation_id against the global ordinal.  If it does not match that</span></span><br><span class="line"><span class="comment">      * implies that this method has been called with the handler in the state where it should be</span></span><br><span class="line"><span class="comment">      * cancelled but wasn&#x27;t able to be.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"><span class="type">uint32_t</span> _timer_corelation_id = <span class="number">0</span>;                        </span><br><span class="line"></span><br><span class="line"><span class="comment">// keep a expected ratio between defer txn and incoming txn</span></span><br><span class="line"><span class="type">double</span> _incoming_trx_weight = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">double</span> _incoming_defer_ratio = <span class="number">1.0</span>; <span class="comment">// 1:1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// path to write the snapshots to</span></span><br><span class="line">bfs::path _snapshots_dir;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可能会奇怪，为什么my指针中的变量，在其初始化函数中都没有看到初始化的工作，例如其中的chain_plugin和producer_plugin指针。实际上，my中这些变量的初始化工作已经在producer_plugin的initialized函数中初始化完毕了。</p>
<h3 id="schedule_production_loop-函数"><a class="markdownIt-Anchor" href="#schedule_production_loop-函数"></a> schedule_production_loop 函数</h3>
<p>producer_plugin的startup函数中就是调用了producer_plugin_impl中的shcedule_production_loop函数开始生产区块。因此，我们首先从这个函数入手，开始分析producer_plugin_impl是如何生产区块的。</p>
<p>函数首先获得了chain的引用和指向producer_plugin_impl的一个weak_ptr指针，关闭了_timer的io操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chain::controller &amp;chain = chain_plug-&gt;<span class="built_in">chain</span>();</span><br><span class="line">_timer.<span class="built_in">cancel</span>(); <span class="comment">// _timer 是boost库中asio的一个定时器,关闭所有异步等待</span></span><br><span class="line">std::weak_ptr&lt;producer_plugin_impl&gt; weak_this = <span class="built_in">shared_from_this</span>();</span><br><span class="line"><span class="keyword">auto</span> result = <span class="built_in">start_block</span>()</span><br></pre></td></tr></table></figure>
<p>随后尝试生产区块，调用了start_block函数，start_block函数返回结果有succeed,failed,waiting,exhausted4种，针对4中情况分别执行不用的流程。</p>
<ol>
<li>
<p>failed， 获取各种调度信息异常，则重新获取数据进行调度；</p>
</li>
<li>
<p>waitting，其它节点正在出块，则进行等待；</p>
</li>
<li>
<p>producing，轮到本节点出块，则进行出块操作；</p>
</li>
<li>
<p>succeed，生产区块成功，计算下一个生产者出块的时间。</p>
</li>
</ol>
<p>当start_block()返回结果为failed的时，进入异步等待状态，稍后再尝试生产区块。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (result == start_block_result::failed)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">elog</span>(<span class="string">&quot;Failed to start a pending block, will try again later&quot;</span>);</span><br><span class="line">  </span><br><span class="line">   _timer.<span class="built_in">expires_from_now</span>(boost::posix_time::<span class="built_in">microseconds</span>(config::block_interval_us / <span class="number">10</span>)); <span class="comment">// 0.05秒后定时器失效</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 稍后继续尝试schedule_production_loop()函数</span></span><br><span class="line">   _timer.<span class="built_in">async_wait</span>([weak_this, cid = ++_timer_corelation_id](<span class="type">const</span> boost::system::error_code &amp;ec) &#123;</span><br><span class="line">      <span class="comment">// 获得this的shared_ptr指针以判断是否被销毁，销毁返回空的shared_ptr</span></span><br><span class="line">      <span class="keyword">auto</span> self = weak_this.<span class="built_in">lock</span>();</span><br><span class="line">      <span class="keyword">if</span> (self &amp;&amp; ec != boost::asio::error::operation_aborted &amp;&amp; cid == self-&gt;_timer_corelation_id)</span><br><span class="line">      &#123;</span><br><span class="line">         self-&gt;<span class="built_in">schedule_production_loop</span>();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果返回结果是waiting，表示本地的区块链还在从eos网络中下载区块已进行信息同步过程中，这个过程中还无法生产区块。随后查看当前是否还能继续生产区块，如果可以，则待会儿生产区块，即调用函数schedule_delayed_production_loop，这个函数这里不再进行仔细分析，主要就是过一段时间后这个函数中还会调用schedule_production_loop函数进行区块生产。<br />
返回结果时waiting的情况下，对应代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (result == start_block_result::waiting)</span><br><span class="line">&#123; <span class="comment">// 当前还在同步区块信息,等待中...</span></span><br><span class="line">    <span class="comment">// waiting的状态有两种情况,要么生产区块的BP名单为空,或者是生产区块受外部命令而停止</span></span><br><span class="line">   <span class="keyword">if</span> (!_producers.<span class="built_in">empty</span>() &amp;&amp; !<span class="built_in">production_disabled_by_policy</span>())</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">fc_dlog</span>(_log, <span class="string">&quot;Waiting till another block is received and scheduling Speculative/Production Change&quot;</span>);</span><br><span class="line">      <span class="comment">// 过会儿再进行区块生产</span></span><br><span class="line">      <span class="built_in">schedule_delayed_production_loop</span>(weak_this, <span class="built_in">calculate_pending_block_time</span>());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">fc_dlog</span>(_log, <span class="string">&quot;Waiting till another block is received&quot;</span>);</span><br><span class="line">      <span class="comment">// 其他区块还没有同步完毕,因此急需等待同步完成才能生产区块</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果返回结果是speculateing模式，并且还可以继续进行区块生产，但是生产者不确定这个区块是否合法，所以小心翼翼的过一会儿继续生产区块，过程如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_pending_block_mode == pending_block_mode::speculating &amp;&amp; !_producers.<span class="built_in">empty</span>() &amp;&amp; !<span class="built_in">production_disabled_by_policy</span>())</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">fc_dlog</span>(_log, <span class="string">&quot;Specualtive Block Created; Scheduling Speculative/Production Change&quot;</span>);</span><br><span class="line">   <span class="built_in">EOS_ASSERT</span>(chain.<span class="built_in">pending_block_state</span>(), missing_pending_block_state, <span class="string">&quot;speculating without pending_block_state&quot;</span>);</span><br><span class="line">   <span class="type">const</span> <span class="keyword">auto</span> &amp;pbs = chain.<span class="built_in">pending_block_state</span>();</span><br><span class="line">   <span class="built_in">schedule_delayed_production_loop</span>(weak_this, pbs-&gt;header.timestamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果返回结果是producing模式，表示已经成功的生产了一个区块，但是还需要其他一些验证工作。这里有个问题就是，为什么speculating模式下没有验证，非得在producing模式下验证生产的区块呢？</p>
<p>首先验证区块截止时间是否大于当前时间，如果大于当前时间，表明生产区块成功在截止日期内，是合法的区块，然后记录日志。如果截止日期超过现在，表明生产的区块已经过期了，此时将生产区块的时间减小0.5s，看是否超时并记录日志，这一步完成之后进行区块的同步操作。<br />
代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_pending_block_mode == pending_block_mode::producing)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 成功打包了一个区块,但是得看看打包的区块是否超时</span></span><br><span class="line">   <span class="type">static</span> <span class="type">const</span> boost::posix_time::ptime <span class="built_in">epoch</span>(boost::gregorian::<span class="built_in">date</span>(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">   <span class="comment">// pending_block_time 返回最后一个区块的时间戳(是刚刚生产的区块的时间戳还是之前有效区块的时间戳,暂时还不清楚)</span></span><br><span class="line">   <span class="keyword">auto</span> deadline = <span class="built_in">calculate_block_deadline</span>(chain.<span class="built_in">pending_block_time</span>());</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (deadline &gt; fc::time_point::<span class="built_in">now</span>())</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">// ship this block off no later than its deadline</span></span><br><span class="line">      <span class="built_in">EOS_ASSERT</span>(chain.<span class="built_in">pending_block_state</span>(), missing_pending_block_state, <span class="string">&quot;producing without pending_block_state, start_block succeeded&quot;</span>);</span><br><span class="line">      _timer.<span class="built_in">expires_at</span>(epoch + boost::posix_time::<span class="built_in">microseconds</span>(deadline.<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>()));</span><br><span class="line">      <span class="built_in">fc_dlog</span>(_log, <span class="string">&quot;Scheduling Block Production on Normal Block #$&#123;num&#125; for $&#123;time&#125;&quot;</span>, (<span class="string">&quot;num&quot;</span>, chain.<span class="built_in">pending_block_state</span>()-&gt;block_num)(<span class="string">&quot;time&quot;</span>, deadline));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">EOS_ASSERT</span>(chain.<span class="built_in">pending_block_state</span>(), missing_pending_block_state, <span class="string">&quot;producing without pending_block_state&quot;</span>);</span><br><span class="line">      <span class="keyword">auto</span> expect_time = chain.<span class="built_in">pending_block_time</span>() - fc::<span class="built_in">microseconds</span>(config::block_interval_us);</span><br><span class="line">      <span class="comment">// ship this block off up to 1 block time earlier or immediately</span></span><br><span class="line">      <span class="keyword">if</span> (fc::time_point::<span class="built_in">now</span>() &gt;= expect_time)</span><br><span class="line">      &#123;</span><br><span class="line">         _timer.<span class="built_in">expires_from_now</span>(boost::posix_time::<span class="built_in">microseconds</span>(<span class="number">0</span>));</span><br><span class="line">         <span class="built_in">fc_dlog</span>(_log, <span class="string">&quot;Scheduling Block Production on Exhausted Block #$&#123;num&#125; immediately&quot;</span>, (<span class="string">&quot;num&quot;</span>, chain.<span class="built_in">pending_block_state</span>()-&gt;block_num));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">         _timer.<span class="built_in">expires_at</span>(epoch + boost::posix_time::<span class="built_in">microseconds</span>(expect_time.<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>()));</span><br><span class="line">         <span class="built_in">fc_dlog</span>(_log, <span class="string">&quot;Scheduling Block Production on Exhausted Block #$&#123;num&#125; at $&#123;time&#125;&quot;</span>, (<span class="string">&quot;num&quot;</span>, chain.<span class="built_in">pending_block_state</span>()-&gt;block_num)(<span class="string">&quot;time&quot;</span>, expect_time));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   _timer.<span class="built_in">async_wait</span>([&amp;chain, weak_this, cid = ++_timer_corelation_id](<span class="type">const</span> boost::system::error_code &amp;ec) &#123;</span><br><span class="line">      <span class="keyword">auto</span> self = weak_this.<span class="built_in">lock</span>();</span><br><span class="line">      <span class="keyword">if</span> (self &amp;&amp; ec != boost::asio::error::operation_aborted &amp;&amp; cid == self-&gt;_timer_corelation_id)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">// pending_block_state expected, but can&#x27;t assert inside async_wait</span></span><br><span class="line">         <span class="keyword">auto</span> block_num = chain.<span class="built_in">pending_block_state</span>() ? chain.<span class="built_in">pending_block_state</span>()-&gt;block_num : <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">auto</span> res = self-&gt;<span class="built_in">maybe_produce_block</span>();</span><br><span class="line">         <span class="built_in">fc_dlog</span>(_log, <span class="string">&quot;Producing Block #$&#123;num&#125; returned: $&#123;res&#125;&quot;</span>, (<span class="string">&quot;num&quot;</span>, block_num)(<span class="string">&quot;res&quot;</span>, res));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果对其他一些细节的代码不太明白，也不必在意，因为我也不太清楚。但是我们注意到同步操作中的一段代码，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_timer.async_wait(</span><br><span class="line">   [&amp;chain, weak_this, cid = ++_timer_corelation_id](const boost::system::error_code &amp;ec) &#123;</span><br><span class="line">   auto self = weak_this.lock();</span><br><span class="line">   if (self &amp;&amp; ec != boost::asio::error::operation_aborted &amp;&amp; cid == self-&gt;_timer_corelation_id)</span><br><span class="line">   &#123;</span><br><span class="line">      // pending_block_state expected, but can&#x27;t assert inside async_wait</span><br><span class="line">      auto block_num = chain.pending_block_state() ? chain.pending_block_state()-&gt;block_num : 0;</span><br><span class="line">      auto res = self-&gt;maybe_produce_block();</span><br><span class="line">      fc_dlog(_log, &quot;Producing Block #$&#123;num&#125; returned: $&#123;res&#125;&quot;, (&quot;num&quot;, block_num)(&quot;res&quot;, res));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>_timer.async_wait应该是将生产出来的在群里面广播。这个函数接受一个lambda函数，表示同步的方法，同步过程中有一个maybe_produce_block()函数，我想应该是某个block procuder(以后简称BP)生产了一个区块，但是还没有得到其他BP的确认，这是个进行同步请求确认的过程。因此，我们再仔细看看进行同步的细节（不过貌似很多细节我也看不懂哎…囧…）。</p>
<p>mayb_produce_block函数的主要内容如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">producer_plugin_impl::maybe_produce_block</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">auto</span> reschedule = fc::<span class="built_in">make_scoped_exit</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line">      <span class="built_in">schedule_production_loop</span>();</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">produce_block</span>();</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">catch</span> (<span class="type">const</span> guard_exception &amp;e)</span><br><span class="line">      &#123;</span><br><span class="line">         chain_plug-&gt;<span class="built_in">handle_guard_exception</span>(e);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">FC_LOG_AND_DROP</span>();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">catch</span> (boost::interprocess::bad_alloc &amp;)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">raise</span>(SIGUSR1);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">fc_dlog</span>(_log, <span class="string">&quot;Aborting block due to produce_block error&quot;</span>);</span><br><span class="line">   chain::controller &amp;chain = chain_plug-&gt;<span class="built_in">chain</span>();</span><br><span class="line">   chain.<span class="built_in">abort_block</span>();</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上来就是一句我不懂的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> reschedule = fc::<span class="built_in">make_scoped_exit</span>(</span><br><span class="line">   [<span class="keyword">this</span>]&#123;</span><br><span class="line">   <span class="built_in">schedule_production_loop</span>();</span><br><span class="line">&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>也就是说，往里面传了一个lambda函数，函数就是重复生产区块的函数。但是fc::make_scope_exit又是什么意思呢？这里面大概介绍一下，make_scoped_exit函数中传入一个lambda函数，may_produe_block函数结束时reschedule函数只是定义了一下，reschedule隶属于scoped_exit类，这个类的析构函数中调用了schedule_production_loop();表明函数结束之后继续生产区块。<br />
随后may_produce_block中有一个重要的函数，即produce_block()函数，我们继续追踪，这个函数代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer_plugin_impl::produce_block</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">//ilog(&quot;produce_block $&#123;t&#125;&quot;, (&quot;t&quot;, fc::time_point::now())); // for testing _produce_time_offset_us</span></span><br><span class="line">   <span class="built_in">EOS_ASSERT</span>(_pending_block_mode == pending_block_mode::producing, producer_exception, <span class="string">&quot;called produce_block while not actually producing&quot;</span>);</span><br><span class="line">   </span><br><span class="line">   chain::controller &amp;chain = chain_plug-&gt;<span class="built_in">chain</span>();</span><br><span class="line">   <span class="comment">// 获取当前打包好的区块的指针</span></span><br><span class="line">   <span class="type">const</span> <span class="keyword">auto</span> &amp;pbs = chain.<span class="built_in">pending_block_state</span>();</span><br><span class="line">   <span class="comment">// 获取打包的区块的区块头</span></span><br><span class="line">   <span class="type">const</span> <span class="keyword">auto</span> &amp;hbs = chain.<span class="built_in">head_block_state</span>();</span><br><span class="line">   <span class="built_in">EOS_ASSERT</span>(pbs, missing_pending_block_state, <span class="string">&quot;pending_block_state does not exist but it should, another plugin may have corrupted it&quot;</span>);</span><br><span class="line">   <span class="comment">// 寻找BP的私钥</span></span><br><span class="line">   <span class="keyword">auto</span> signature_provider_itr = _signature_providers.<span class="built_in">find</span>(pbs-&gt;block_signing_key);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">EOS_ASSERT</span>(signature_provider_itr != _signature_providers.<span class="built_in">end</span>(), producer_priv_key_not_found, <span class="string">&quot;Attempting to produce a block for which we don&#x27;t have the private key&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//idump( (fc::time_point::now() - chain.pending_block_time()) );</span></span><br><span class="line">   <span class="comment">// 将区块内容写入数据库中，确定区块头中的merkel_root等内容</span></span><br><span class="line">   chain.<span class="built_in">finalize_block</span>();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 对区块进行签名</span></span><br><span class="line">   chain.<span class="built_in">sign_block</span>([&amp;](<span class="type">const</span> digest_type &amp;d) &#123;</span><br><span class="line">      <span class="keyword">auto</span> debug_logger = <span class="built_in">maybe_make_debug_time_logger</span>();</span><br><span class="line">      <span class="keyword">return</span> signature_provider_itr-&gt;<span class="built_in">second</span>(d);</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="comment">// 往本地的分叉的区块链数据库中提交区块，因为还没有确认</span></span><br><span class="line">   chain.<span class="built_in">commit_block</span>();</span><br><span class="line">   <span class="comment">// 获取区块时间戳</span></span><br><span class="line">   <span class="keyword">auto</span> hbt = chain.<span class="built_in">head_block_time</span>();</span><br><span class="line">   <span class="comment">//idump((fc::time_point::now() - hbt));</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取刚刚添加的最新的区块头状态</span></span><br><span class="line">   block_state_ptr new_bs = chain.<span class="built_in">head_block_state</span>();</span><br><span class="line">   <span class="comment">// 记录最新的区块生产者和其生产的区块号</span></span><br><span class="line">   _producer_watermarks[new_bs-&gt;header.producer] = chain.<span class="built_in">head_block_num</span>();</span><br><span class="line"></span><br><span class="line">   <span class="built_in">ilog</span>(<span class="string">&quot;Produced block $&#123;id&#125;... #$&#123;n&#125; @ $&#123;t&#125; signed by $&#123;p&#125; [trxs: $&#123;count&#125;, lib: $&#123;lib&#125;, confirmed: $&#123;confs&#125;]&quot;</span>,</span><br><span class="line">        (<span class="string">&quot;p&quot;</span>, new_bs-&gt;header.producer)(<span class="string">&quot;id&quot;</span>, fc::<span class="built_in">variant</span>(new_bs-&gt;id).<span class="built_in">as_string</span>().<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">16</span>))(<span class="string">&quot;n&quot;</span>, new_bs-&gt;block_num)(<span class="string">&quot;t&quot;</span>, new_bs-&gt;header.timestamp)(<span class="string">&quot;count&quot;</span>, new_bs-&gt;block-&gt;transactions.<span class="built_in">size</span>())(<span class="string">&quot;lib&quot;</span>, chain.<span class="built_in">last_irreversible_block_num</span>())(<span class="string">&quot;confs&quot;</span>, new_bs-&gt;header.confirmed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，大致对producer_plugin这个插件的内容以及主要功能有一个大致的了解。<br />
这个插件主要负责区块的接收、检验、打包和本地写入功能。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hzxgoforward.github.io/2019/03/14/An%20Empirical%20Analysis%20of%20Anonymity%20in%20Zcash/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌虎下山">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/14/An%20Empirical%20Analysis%20of%20Anonymity%20in%20Zcash/" class="post-title-link" itemprop="https://hzxgoforward.github.io/index.html">An Empirical Analysis of Anonymity in Zcash</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建于：2019-03-14 18:02:14" itemprop="dateCreated datePublished" datetime="2019-03-14T18:02:14+08:00">2019-03-14</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="更新于：2019-11-08 14:56:16" itemprop="dateModified" datetime="2019-11-08T14:56:16+08:00">2019-11-08</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/" itemprop="url" rel="index"><span itemprop="name">区块链技术研究</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          


          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-zcash的相关知识介绍"><a class="markdownIt-Anchor" href="#1-zcash的相关知识介绍"></a> 1. Zcash的相关知识介绍</h1>
<h2 id="11-zcash的工作原理"><a class="markdownIt-Anchor" href="#11-zcash的工作原理"></a> 1.1 Zcash的工作原理</h2>
<p>Zcash是一种从Bitcoin中分叉出来的代币, 其目的在于解决bitcoin中交易在执行过程中可以利用区块追踪交易记录的问题,进而使得交易难以追踪以提高匿名性.<br />
Zcash中的地址有两种,一种叫做transparent address,简称t-address,这种地址以t开头. 另外一种地址叫做shielded address, 这种地址以z开头.Zcash中大概有如下4种交易类型,如下图所示:</p>
<center>
<img src = "https://img-blog.csdnimg.cn/20190313141202670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70"  >
</center>
<p>z-address 到z-address的转账称之为Private transactions, z-address 到t-address的转账称之为Deshielding transactions, t-address到z-address的转账叫做Shielded transactions, 而t-address到t-address的转账叫做transparent transactions.</p>
<ol>
<li>
<p><strong>t-to-t transaction</strong></p>
<p>两个t-address之间的交易, 和Bitcoin中的交易完全相同,交易双方的地址, 交易费, 交易金额都是公开并且可以追踪的.一个典型的示例如下:</p>
 </center>
 <img src="https://img-blog.csdnimg.cn/2019031314352632.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70" ></center>
 这笔交易中, 有一个输入,2个输出,输入和输出的地址都是t开头.
</li>
<li>
<p><strong>t-to-z transaction</strong></p>
<p>t-to-z transaction中,可以叫做shielded transaction, 只能看到输入地址, 即以t开头的地址,交易费等信息, 但是输出的具体地址以及地址个数是未知的.</p>
 </center>
 <img src="https://img-blog.csdnimg.cn/20190313144006733.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70" ></center>
<p>这笔交易中,只有1个输入,输入代币总量以及交易费也是已知的,但是输出的地址以及输出地址的个数是未知的, 最终输入的其他ZEC流入了<strong>shielded pool</strong>中.</p>
</li>
<li>
<p><strong>z-to-t transaction</strong></p>
<p>z-to-t transaction,又叫做 deshielded transaction,即从shielded pool中的代币转出至某个特定的t-address中.</p>
 </center>
 <img src="https://img-blog.csdnimg.cn/20190313144615912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70" ></center>
<p>上图中,交易的输入地址和输入地址的个数未知,但是知道输出地址的数量和具体信息,同时输出代币数和交易费用已知.</p>
</li>
<li>
<p><strong>z-to-z transaction</strong></p>
<p>z-address 到z-address的转账称之为Private transactions,从z-toz交易中只能得知交易费。但是交易地址、地址数量以及交易的ZEC数目都是未知的。</p>
 </center>
 	<img src="https://img-blog.csdnimg.cn/20190313145010448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70" ></center>
<p>这笔交易中，输入地址和输出地址的数量以及具体信息都是未知的，唯一能确定的是交易费用。z-to-z地址之间的转换，就相当于在shielded pool中进行持续转账。所有z-address中的ZEC就组成了shielded pool.</p>
</li>
</ol>
<h2 id="12-joinsplits"><a class="markdownIt-Anchor" href="#12-joinsplits"></a> 1.2 JoinSplits</h2>
<p>简单的理解, 从t-add 转入 z-addr的转账交易，即将ZEC转入到shielded pool中，因此叫做shielded交易，而从z-addr转到t-addr的交易， 即从shielded pool中转出ZEC, 因此叫做deshielded 交易, z-address之间的转账,则称之为private transaction.</p>
<p>从上述4中交易的介绍中, 可以观察发现,只有t-address和t-address之间的转账中没有JoinSplits, 而凡是涉及到z-addrress的交易,图中都会有一个JoinSplits的字段, JoinSplits字段中指定了交易中ZEC的来源和去向,以及其中的零知识证明,这个证明允许其他人在不揭露交易内容的前提下验证加密交易的真实性. 关于阅读本论文, 我们只需要知道这个就可以了.</p>
<p>更多关于零知识的证明,感兴趣可以点击<a target="_blank" rel="noopener" href="https://z.cash/technology/zksnarks">zk-SNARKs</a>以及如下几个链接.</p>
<ul>
<li>
<p>ZCash中的Transaction: <a target="_blank" rel="noopener" href="https://z.cash/technology/#viewing-keys">https://z.cash/technology/#viewing-keys</a></p>
</li>
<li>
<p>ZCash中的Anatomy:  <a target="_blank" rel="noopener" href="https://z.cash/blog/anatomy-of-zcash/">https://z.cash/blog/anatomy-of-zcash/</a> * ZCash协议详解: <a target="_blank" rel="noopener" href="https://github.com/zcash/zips/blob/master/protocol/protocol.pdf">https://github.com/zcash/zips/blob/master/protocol/protocol.pdf</a> (交易细节可以参看3.4节)</p>
</li>
<li>
<p>ZCash零知识证明: <a target="_blank" rel="noopener" href="https://z.cash/zh/technology/zksnarks/">https://z.cash/zh/technology/zksnarks/</a></p>
</li>
</ul>
<h2 id="13-zcash的主要参与者"><a class="markdownIt-Anchor" href="#13-zcash的主要参与者"></a> 1.3 Zcash的主要参与者</h2>
<p>Zcash中的参与人主要有4类,</p>
<ul>
<li>
<p><strong>创始人(Founders)</strong>,</p>
</li>
<li>
<p><strong>矿工(Miners)</strong>,</p>
</li>
<li>
<p><strong>服务提供商(Services)</strong></p>
</li>
<li>
<p><strong>用户(Users).</strong></p>
</li>
</ul>
<p>在Zcash刚开始挖矿的4年中,每次矿工挖出一个区块时,都需要将25%的出块奖励转发给创始人团队, 一个区块的出块奖励为12.5ZEC, 创始人拿到2.5ZEC, 矿工拿到10ZEC.</p>
<h2 id="2-论文主要内容简要介绍"><a class="markdownIt-Anchor" href="#2-论文主要内容简要介绍"></a> 2. 论文主要内容简要介绍</h2>
<h3 id="21-主要研究方法和内容介绍"><a class="markdownIt-Anchor" href="#21-主要研究方法和内容介绍"></a> 2.1 主要研究方法和内容介绍</h3>
<p>这篇文章发表于2018年第27届USENIX Security Symposium会议,本论文非常深入的分析了Zcash的匿名程度,文章首先对Zcash区块链中的区块链信息进行了统计说明, 统计结果表明Zcash区块链中, 85%的交易都是transparent 交易, 而匿名的交易仅仅占比25%左右.<br />
随后对Zcash中的交易(t-to-t, z-to-t, t-to-z, z-to-z), 使用5种启发式方法进行分析并尝试对其中的地址所对应的用户进行标记.通过文章中的启发式方法的分析,分别发现了创始人和矿工在进行z-to-t和t-to-z交易时的一些明显的特征, 利用这些特征识别出了创始人和矿工的隐匿的地址,同时也对其他一些黑客组织的地址进行了识别. 文章的5个启发式分析方法主要介绍如下:</p>
<ul>
<li>
<p><strong>启发式方法1: Zcash一笔交易中的多个输入地址都由同一个实体控制.</strong></p>
<ul>
<li>
<p>将Zcash区块链中每一个地址当做1个顶点, 同一笔交易中的多个输入地址之间用无向边连接, 以此完成了对Zcash中所有t-address的聚类, 总共得到560319个簇.</p>
</li>
<li>
<p>Zcash中的铸币交易, 一个区块产生12.5个ZEC, 其中10个归属矿工, 2.5个归属创始人, 因此每个区块的铸币交易中可以确定并且准确的标记出创始和矿工t-address.</p>
</li>
<li>
<p>分别从Top10的交易所购买Zcash, 随后在交易所的地址和自己Zcash的地址之间多次转账, 根据转账记录标记出交易所的地址.</p>
</li>
</ul>
</li>
<li>
<p><strong>启发式方法3: 任何交易值是250.0001ZEC的z-to-t转账交易时由创世团队发起</strong></p>
<ul>
<li>
<p>这是因为在文章作者在研究t-to-z的交易时, 发现创始团队比较有规律的往shielded pool转账, 每次转账249.9999ZEC, 这些t-to-z转账交易的时间间隔是6~10个区块. z-to-t的交易中, 有很多转账交易是价值250.0001ZEC的交易,这些交易也前后时间间隔是 6~10个区块,作者认为这是一种创世团队提取ZEC的一种自动转账脚本.</p>
</li>
<li>
<p>基于上述假设, 发现了创始人团队z-to-t转账中额外的75个地址, 而前面启发式方法1中发现了48个地址, 于是总共发现了123个创始人团队的地址.</p>
</li>
<li>
<p>创世人以为执行了t-to-z交易之后将自己的ZEC转入shielded pool, 随后从shielded pool中发起z-to-t的交易将ZEC转出, 结果使用了脚本, 于是作者利用启发式方法3建立了t-to-z 和z-to-t交易之间的联系,这是其重大意义所在.</p>
</li>
</ul>
</li>
<li>
<p><strong>启发式方法4: 如果1个z-to-t的交易中,输出地址超过100个,并且其中一个输出地址是一个已知的矿池地址, 那么认为其他输出地址也是矿工地址</strong></p>
<ul>
<li>这个假设的前提是因为在Zcash中, 矿工挖矿成功之后铸币交易的ZEC,必须先转入shield pool, 即先执行一个t-to-z交易, 随后从shield pool 转出时矿池将每个矿工的收益分别发送给矿工,剩余ZEC退回到矿池的地址.</li>
<li>通过上述的方法,确定了110918个矿工的地址, 启发式方法4能够将矿工的t-to-z和z-to-t转账交易中的t-address联系起来.</li>
</ul>
</li>
<li>
<p><strong>启发式方法5: 如果一笔t-to-z的交易, 交易值是V, 随后的一段时间内, 出现了一笔转账交易值也是V的z-to-t的交易, 则认为这笔交易时相关的</strong></p>
<ul>
<li>这个假设听起来很容易造成false positive, 但是实际上 总共有12841笔t-to-z和对应的z-to-t交易, 这些对应的交易都有着完全不同的交易值, 其中的9487笔交易精确到小数点后8位, 超过98.9%的交易精确到小数点后3位, 基于这个事实,基本可以认为这些交易是相关的.</li>
</ul>
</li>
</ul>
<p>注意, 上文没有介绍启发式方法2, 这是因为论文中仅仅介绍了该方法,但是考虑到实际的可靠性,并没有采用该方法.</p>
<h3 id="22-文章结论"><a class="markdownIt-Anchor" href="#22-文章结论"></a> 2.2 文章结论</h3>
<ul>
<li>通过上述启发式的方法, 作者能将shielded pool 中转账交易中69.1%的地址进行标记,这严重的降低了ZCash的匿名性功能. 大多数的用户并没有很好地使用ZCash的匿名性, 或者说与shield pool 进行交互进行匿名的方式仍然留下了线索从而被识别出来, 这减少了ZCash 中的匿名集的范围, 也严重的损害了其他用户的匿名性. 论文更多资料会议网址及资料<a target="_blank" rel="noopener" href="https://www.usenix.org/conference/usenixsecurity18/presentation/kappos">点击这里.</a></li>
</ul>
<h1 id="3-匿名性方面的其他研究"><a class="markdownIt-Anchor" href="#3-匿名性方面的其他研究"></a> 3. 匿名性方面的其他研究</h1>
<p>匿名性方面的研究工作, 目前的研究方向是两种, 一种是建立一个更好的匿名性的机制, 以增强区块链中的匿名性, 例如目前的CoinJoin,Mix混币技术,或者是建立新的Dash, Monero以及Zcash等匿名性更强的币种. 另外一方面的研究工作, 则是通过分析方法,指出目前区块链匿名性技术方面的不足.</p>
<ul>
<li>
<p>有一些学者致力于研究  <strong>混币(mix)</strong>  服务或者是建立新的币种的方法以提高匿名性, 或者致力于创建一种新的加密货币, 例如Dash, CoinJoin技术已经Monero和Zcash. 参考文献如下:</p>
<ul>
<li>E. Heilman, L. Alshenibr, F. Baldimtsi, A. Scafuro, and S. Goldberg. TumbleBit: an untrusted Bitcoin-compatible anonymous payment hub. In Proceedings of NDSS 2017, 2017</li>
<li>A. E. Kosba, A. Miller, E. Shi, Z. Wen, and C. Papamanthou. Hawk: The blockchain model of cryptography and privacypreserving smart contracts. In 2016 IEEE Symposium on Security and Privacy, pages 839–858, San Jose, CA, USA, May 22–26, 2016. IEEE Computer Society Press</li>
<li>S. Meiklejohn and R. Mercer. Mobius: Trustless tumbling for  transaction privacy. Proceedings on Privacy Enhancing Technologies, 2018</li>
<li>T. Ruffing, P. Moreno-Sanchez, and A. Kate. CoinShuffle: Practical decentralized coin mixing for Bitcoin. In M. Kutylowski and J. Vaidya, editors, ESORICS 2014, Part II, volume 8713 of LNCS, pages 345–364, Wroclaw, Poland, Sept. 7–11, 2014. Springer, Heidelberg, Germany.</li>
<li>G. Maxwell. CoinJoin: Bitcoin privacy for the real world. <a target="_blank" rel="noopener" href="http://bitcointalk.org/index.php?topic=279249">bitcointalk.org/index.php?topic=279249</a>, Aug. 2013.</li>
<li>Dash. <a target="_blank" rel="noopener" href="https://www.dash.org">https://www.dash.org</a>.</li>
<li>Monero. <a target="_blank" rel="noopener" href="https://getmonero.org">https://getmonero.org</a>.</li>
<li>Zcash. <a target="_blank" rel="noopener" href="https://z.cash">https://z.cash</a>.</li>
</ul>
</li>
<li>
<p>另外一些研究致力于通过一些方法检验加密货币的匿名性,指出其限制性.这些所有的研究都有共同的方案,就使用一些启发性的方法, 然后对所有的交易地址进行聚类, 再对聚类之后的地址进行标记以识别出这些地址的具体隶属信息. 目前已经有一些论文, 对Dash, Monero, CoinJoin以及Zcash的匿名性都进行了分析, 相关文献如下:</p>
</li>
<li>
<p>A. Kumar, C. Fischer, S. Tople, and P. Saxena. A traceability analysis of Monero’s blockchain. In Proceedings of ESORICS 2017, pages 153–173, 2017.</p>
</li>
<li>
<p>A. Miller, M. Moser, K. Lee, and A. Narayanan. An ¨ empirical analysis of linkability in the Monero blockchain. arXiv:1704.04299, 2017. <a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1704.04299.pdf">https://arxiv.org/pdf/1704.04299.pdf</a></p>
</li>
<li>
<p>P. Moreno-Sanchez, M. B. Zafar, and A. Kate. Listening to whispers of Ripple: Linking wallets and deanonymizing transactions in the Ripple network. Proceedings on Privacy Enhancing Technologies, 2016(4):436–453, 2016</p>
</li>
<li>
<p>P. Moreno-Sanchez, M. B. Zafar, and A. Kate. Listening to whispers of Ripple: Linking wallets and deanonymizing transactions in the Ripple network. Proceedings on Privacy Enhancing Technologies, 2016(4):436–453, 2016</p>
</li>
<li>
<p>J. Quesnelle. On the linkability of Zcash transactions. arXiv:1712.01210, 2017. <a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1712.01210.pdf">https://arxiv.org/pdf/1712.01210.pdf</a></p>
</li>
</ul>
<h1 id="4-思考"><a class="markdownIt-Anchor" href="#4-思考"></a> 4. 思考</h1>
<ul>
<li>
<p>通过对这篇文章的阅读, 大概对区块链匿名性方面的研究有了一些初步的了解, &quot;An Empirical Analysis of Anonymity in Zcash&quot;这篇文章中的方法比较简单, 但是这些简单的方法应该是基于大量的研究分析工作得来的. 刚开始阅读完这篇文章的时候,我并没有认为这篇文章具有很大的贡献程度.</p>
</li>
<li>
<p>这篇文章能够发表在USENIX上,我觉得原因如下:</p>
<ol>
<li>文章的工作量很大, 对Zcash中所有的区块数据和交易都进行了大量的统计分析工作, 使得读者能对Zcash有一个非常直观的认知.</li>
<li>文章中使用了5种针对Zcash的启发式分析方法, 对t-address进行聚类, 随后进行标记, 然后建立tt-to-z和z-to-t这一匿名转账操作之间的联系, 找到了许多创始人和矿工的地址, 推理方法有理有据,分析比较到位.</li>
<li>该文章是第一个对Zcash的匿名性进行分析的文章, 指出了Zcash的弱点, 这就是对Zcash的匿名性的改进提供了方向.</li>
</ol>
</li>
<li>
<p>文章通过大量的分析和工作说明了一个问题, 即Zcash的匿名性并不仅仅是由零知识证明技术决定的, Zcash的用户在进行t-to-z交易和z-to-t交易中转换以隐藏自己身份的时候, 应该使用一种更加匿名的方式.一旦Zcash用户不能很好地隐匿自己, 其他用户的隐私性也会受到威胁.</p>
</li>
</ul>
<h1 id="5-对文章分析方法的详细阅读解析"><a class="markdownIt-Anchor" href="#5-对文章分析方法的详细阅读解析"></a> 5. 对文章分析方法的详细阅读解析</h1>
<h2 id="51-zcash的统计信息"><a class="markdownIt-Anchor" href="#51-zcash的统计信息"></a> 5.1 Zcash的统计信息</h2>
<p>作者这里所说的所有区块统计信息,都是以2018年1月21日为止.</p>
<h3 id="511-区块生产信息"><a class="markdownIt-Anchor" href="#511-区块生产信息"></a> 5.1.1 区块生产信息</h3>
<p>作者使用zcashd客户端下载Zcash 区块链,将区块链载入Apache Spark中,随后使用pySpark包进行分析.截止2018年1月21日为止, 总共生产了258472个区块, 产生了31,06,043个ZEC, 其中矿工分得2,485,461, 创始人团队获得621,182 ZEC. 这里有个疑问是总共产生258472个区块,如果每个区块的reward为12.5, 那么总共应该产生3,230,900ZEC,但是实际上并没有这么多,这是因为最初的 20,000 个块的奖励很少，从第 1 个块开始到第 20,000 个块的奖励线性增加，在第 20,000 个块处奖励 12.5 个Zcash. 官方解释说这样做的目的是为防止早期的快速挖矿对 Zcash 系统造成伤害。 Zcash 系统每 2.5 分钟一个块，20,000 个块之后，每个块奖励 12.5 个Zcash。</p>
<h3 id="512-交易transactions"><a class="markdownIt-Anchor" href="#512-交易transactions"></a> 5.1.2 交易(Transactions)</h3>
<p>所有区块总共2,242,847笔交易, 交易具体分布信息如Table.1 所示.<br />
<center><br />
<img src = "https://img-blog.csdnimg.cn/20190313152246158.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70"><br />
</center><br />
Table.1 中transparent指的是t-to-t交易的数量, Coingen指的是铸币交易, Deshielded指的是z-to-t的交易, shielded 指的是t-to-z交易.Mixed指的是混合交易,即一笔交易的输入或者输出中都包含t和z地址的交易. Private指的是z-to-z交易.<br />
从表中显然可以看出, t-to-t交易仍然占有很大的比例,它与铸币交易总共占全部交易的85%, 与shielded pool有关的交易仅仅有335,630笔,总共占有14.96%的比例.</p>
<p>在Fig.2中,展示了随着时间的增长, Zcash区块链中各种交易所占的比例变化趋势,图中可以看出, Coingen, shielded以及deshielded交易都呈现出线性增长的情况,将在后续分析中分析其成因.</p>
<center>
<img src = "https://img-blog.csdnimg.cn/20190313154343132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>
	Fig.3图揭示了随着时间增长,各种交易中涉及的ZEC比例变化趋势图. 从Fig.3 和Fig.2 的综合分析中, 可以看出与shielded pool的交易呈现出线性增长的趋势, 但是总ZEC的价值却呈现越来越小的比例, transparent交易的比例越来越高.
<center>
<img src = "https://img-blog.csdnimg.cn/20190313154215741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>
<h3 id="513-地址addresses统计信息"><a class="markdownIt-Anchor" href="#513-地址addresses统计信息"></a> 5.1.3 地址(Addresses)统计信息</h3>
<p>在所有的交易中, 有1,740,378个t-address, 其中8727笔交易时t-to-z trx, 另外330,780笔交易时z-to-t trx. 这两种交易不对称行的原因,是由于矿池的一些操作导致.矿池使用极少数量的地址收集block reward, 但是分配block reward时需要分别转给矿池中的每个矿工.由于shielded pool的存在, 无法探知到具体有多少z-address的存在.</p>
<p>Fig.4展示了shielded pool中ZEC随着时间增长的变化情况, 在图中有比较明显的震荡点, 而这是由于Zcash创始人的转账操作导致,后续会对这种情况给出更为具体的解释.截止到撰写本文的时间,<strong>shielded pool中总共有112, 235的ZEC.</strong></p>
<center>
	<img src = "https://img-blog.csdnimg.cn/20190313155805593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>
<p>分别对t-address中的地址拥有ZEC的数量进行排序, 可以发现其中只有25%的地址中的ZEC数量大于0, 而在这25%的地址中, 其中前1%的地址拥有78%的ZEC. <strong>拥有ZEC最多的账户拥有118,257.75个ZEC, 这比整个shielded pool中的ZEC还要多!</strong></p>
<p>截止目前为止,论文作者主要介绍了ZCash中一些统计信息,使读者对整个ZCash有一个大概的了解, 下文中,对ZCash进行一些启发式的分析方法.</p>
<h1 id="6-t-address-clustering"><a class="markdownIt-Anchor" href="#6-t-address-clustering"></a> 6. T-Address Clustering</h1>
<p>因为Zcash中从t-address地址发出的的交易与Bitcoin中的交易类似, Bitcoin中对同一笔交易中的多个输入聚类的方法同样可以用来对Zcash中同一笔交易的多个t-address进行聚类. 因此,论文提出Heuristic 1, 具体解释如下:</p>
<h5 id="heuristic-1-如果有多个t-address作为输入出现在同一笔交易中无论这笔交易是t-to-z或者t-to-t抑或是mixed交易-我们都认为这些地址受同一个实体的控制"><a class="markdownIt-Anchor" href="#heuristic-1-如果有多个t-address作为输入出现在同一笔交易中无论这笔交易是t-to-z或者t-to-t抑或是mixed交易-我们都认为这些地址受同一个实体的控制"></a> Heuristic 1: 如果有多个t-address作为输入出现在同一笔交易中,无论这笔交易是t-to-z或者t-to-t抑或是Mixed交易, 我们都认为这些地址受同一个实体的控制.</h5>
<p>鉴于这种启发式的方法已经在Bitcoin中采用, 而Zcash又是Bitcoin的一个分叉,因此认为这个论断基本上是可信的.随后作者按照该方法对Zcash中的所有交易进行了聚类,假设交易中的每个t-address是一个节点, 则对同一笔交易中的多个输入用一条无向边链接, 随后得到聚类结果.经过聚类后得到560, 319个cluster, 其中97,539个cluster包含至少2个t-address.</p>
<p>这种启发式的方法可以发现由同一实体控制的多个地址,但是却不能有效的追踪常见的地址变换情况, 最常见的地址变换情况是一个sender使用地址Addr_A将ZEC发送给recipient,此外还有一部分的ZEC作为找零转到了自己的另外一个地址Addr_B上,随后如果sender仅仅将在一笔交易中心仅仅以Addr_B作为输入将剩余ZEC全部花出去时,上述启发式方法无法建立Addr_A和Addr_B之间实际上由同一实体控制的情况.</p>
<h5 id="heuristic-2-如果在一笔交易的joinsplit的input中有一个或者多个地址是t-address代号t_addr_a-而第二个input地址代号t_addr_b同时又是唯一的一个output-t-address那么-t_addr_b和t_addr_a隶属于同一实体控制"><a class="markdownIt-Anchor" href="#heuristic-2-如果在一笔交易的joinsplit的input中有一个或者多个地址是t-address代号t_addr_a-而第二个input地址代号t_addr_b同时又是唯一的一个output-t-address那么-t_addr_b和t_addr_a隶属于同一实体控制"></a> Heuristic 2: 如果在一笔交易的JoinSplit的input中有一个或者多个地址是t-address(代号t_addr_A), 而第二个input地址(代号t_addr_B)同时又是唯一的一个output t-address,那么 t_addr_B和t_addr_A隶属于同一实体控制.</h5>
<p>这个假设实在是,作者先到了这个假设,但是实际上由于Zcash的一个钱包–zcash4win的存在,有些用户会给钱包开发者一些费用,因此这个可能是个例外,于是作者并没有采用这个方法.</p>
<h2 id="61-tagging-address标记各种地址"><a class="markdownIt-Anchor" href="#61-tagging-address标记各种地址"></a> 6.1 Tagging address(标记各种地址)</h2>
<h3 id="611-标记交易所的地址"><a class="markdownIt-Anchor" href="#611-标记交易所的地址"></a> 6.1.1 标记交易所的地址</h3>
<p>根据已有的clusters, 作者下一步目标是对这些cluster进行标记,以确定他们是Zcash的4类用户中的哪一类. 首先对交易所进行标记, 作者首先根据20家交易所的市场占有率,选出其中的top-10交易所, 随后分别从这些交易所中购入一些Zcash,然后在交易所的地址和自己注册的Zcash地址之间多次进行转账,每次转账的时候都对相应的交易所的地址进行标记.这样就可以确定相应交易所所在的cluster, 文章作者分别对每个cluster进行了标记,以每个簇中地址的个数从大到小排序,最大的簇标记为0, 与top-10交易所之间的交易次数,随后确定的交易所在的簇的编号, 具体结果如Table. 2所示.其中ShapShift是一家公司, 用户可以通过这个账户进行币种转换.</p>
<center>
<img src = "https://img-blog.csdnimg.cn/20190313185947149.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>
<h3 id="612-标记创始人和矿工的地址"><a class="markdownIt-Anchor" href="#612-标记创始人和矿工的地址"></a> 6.1.2  标记创始人和矿工的地址</h3>
<p>收集创始人已经公开的地址,同时从区块中标记矿工的地址, 验证矿工地址标记的正确性, 可以直接通过矿池网站查看矿池的为挖出区块的声明.</p>
<h3 id="613-结果"><a class="markdownIt-Anchor" href="#613-结果"></a> 6.1.3 结果</h3>
<h5 id="矿工和创始人"><a class="markdownIt-Anchor" href="#矿工和创始人"></a> 矿工和创始人</h5>
<p>其中发现有一些矿工的地址是交易所的地址,这说明有些矿工直接将所属交易所的地址用来接收block reward, 这样为的是方便提现, 同时有一些创始人的地址也隶属于交易所.<br />
Table2中可以看出ShapeShift的使用频率非常高,已经收到超过1.1M 的ZEC, 同时发送的ZEC几乎是等量的.与交易所不同，它的集群包含相对较少数量的矿工地址（54），这与其用作转移资金的方式相符，而不是将其存放在钱包中。<br />
尽管矿池和创始人在Zcash中非常活跃,但是由于他们只使用少部分的地址, 因此他们的地址形成的簇不太大.</p>
<h5 id="公开的组织"><a class="markdownIt-Anchor" href="#公开的组织"></a> 公开的组织</h5>
<p>另外,通过调查,发现了3个比较大的接收Zcash支付的组织:the Internet Archive, torservers.net以及Wikileaks. 其中torservers.net只通过z-address接收转账.因此无法识别出他们发起的交易. Wikileaks 也是只通过z-address接收转账.Internet Archive的31笔转账中总共转账17.3ZEC, 9笔交易是匿名的. Wikileaks的20笔转账交易全部是t-to-t交易,并且所有的地址单独成簇.</p>
<h1 id="7-与shielded-pool的交互"><a class="markdownIt-Anchor" href="#7-与shielded-pool的交互"></a> 7. 与Shielded Pool的交互</h1>
<p>这部分分析t-to-z和z-to-t交易.随着时间增长,总共有3,901,124的ZEC进入pool中,随后又有3,788,889的ZEC从pool中取出.Fig 5描述了这一情况, 基本上存储和取回的数量持平,并且呈现对称形式.这表明很多用户存入pool之后会很快的取回他们的ZEC.另外,图中有很明显的4处尖峰.第一处尖峰发生在2016年12月份,由1笔pool中取回7135ZEC的交易, 这笔ZEC分别转给15个t-address,这15个账户属于创始人. 第二处尖峰发生在2017年12月25日, 在242642个区块上,10,000ZECX分别转给10个t-address, 每个t-address收到了1,000ZEC, 目前这10个账户并没有进行任何交易.另外两次的t-to-z的尖峰是, 每个t-address都单独成一个簇,在后续中会说明与创始人有关.</p>
<center>
<img src = "https://img-blog.csdnimg.cn/20190313194509493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>
<p>利用标记好的创始人信息和矿工的地址信息,分析这些包含创始人地址或者包含矿工地址的t-to-z转账交易, 得到Figure 6. 根据Figure 6可知矿工和创始人是往shielded pool 转账最多的人, 实际上占比可达76.7%. 而矿工占比达到63.7%, 这表明创始人并没有将很多ZEC放入pool中,毕竟创始人的ZEC是矿工的20%.</p>
<center>
<img src = "https://img-blog.csdnimg.cn/20190313200026398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>
<p>转账最多的用户,往pool转入超过10,000ZEC, 转账情况如图Figure 7所示.从这图可以看出来, pool中存款的大户仍然是创始人和矿工.</p>
<center>
<img src = "https://img-blog.csdnimg.cn/20190313200534852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>
<h2 id="71-t-to-z和z-to-t交易之间建立联系"><a class="markdownIt-Anchor" href="#71-t-to-z和z-to-t交易之间建立联系"></a> 7.1 t-to-z和z-to-t交易之间建立联系</h2>
<p>shield pool的最大作用是提供了一个匿名集, 用户通过t-to-z的转账之后再从z-to-t中提款,这样其他人就无法追踪提的款来自于哪里.但是如果把t-to-z和z-to-t这两种交易之间能够联系起来,这样在未来发生z-to-t的转账时可以把已确定名单的交易排除出去,这样就能够减小匿名集的大小.</p>
<p>最简单的方法是, 如果t-to-z中的t和z-to-t中的地址相同,那么就能排除一部分 shield pool 的匿名集合.于是实施这个想法的结果如图Figure 8a所示.实际上,通过这种方法,几乎没法将一些z-to-t交易和创始人的地址对应起来, 实际上,只能对应一部分矿工的地址.毕竟创始人不傻, 交易进入shield pool就是为了匿名,怎么可能再采用使用过的地址转出呢, 何况这个团队是以密码学为看家本领,所以不会犯这种错误,而只有对于矿工来说, 使用同样地址无所谓,因为对匿名性要求不高,能提款就好. 最终能与矿工地址对应起来的交易总共有49280笔,占所有z-to-t交易的13.3%.</p>
<center>
<img src = "https://img-blog.csdnimg.cn/20190313205049137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>
<h3 id="711-将z-to-t中创始人的t-address识别出来"><a class="markdownIt-Anchor" href="#711-将z-to-t中创始人的t-address识别出来"></a> 7.1.1 将z-to-t中创始人的t-address识别出来</h3>
<p>经过对创始人团队的地址分析,发现其中14个地址用于t-to-z的交易, 而其中每一笔t-to-z的交易每次转账都是249.9999ZEC, 这恰好是100个区块的奖励. 而另外只有5笔 249到251范围之间的t-to-z转账交易.基于这个特点,本来没法将t-to-z和z-to-t交易联系起来,但是这种模式给了作者灵感. 在所有的z-to-t交易中,没有发现249.9999的转账交易,但是发现了1953笔250.0001ZEC笔交易, 另外1969笔交易在249和251范围之间.于是作者检查了249.9999的t-to-z交易的频率,发现每笔交易之间间隔6~ 10个区块,再检查z-to-t的250.0001ZEC的交易时,发现1953中的1943笔交易的间隔大概是6~10个区块, t-to-z和z-to-t的交易,都像同一个模式, 这种模式的表现情况可以参看figure 9.</p>
<center><img src = "https://img-blog.csdnimg.cn/20190313204433761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>
<p>基于Figure 9 的这种情况,作者大胆做出一个启发式方法:</p>
<h5 id="heuristic-3-任何z-to-t的交易中如果转出2500001zec-那么这笔交易是由创始人发起的"><a class="markdownIt-Anchor" href="#heuristic-3-任何z-to-t的交易中如果转出2500001zec-那么这笔交易是由创始人发起的"></a> Heuristic 3. 任何z-to-t的交易中,如果转出250.0001ZEC, 那么这笔交易是由创始人发起的.</h5>
<p>通过运行这个方法, 作者通过z-to-t交易, 额外发现了75个创始人的t-address, 这和之前的48个地址加起来,总共是123个地址.通过这一波操作, 可以找到创始人的z-to-t的交易, 对比之前的figure 8a, 此时得到的Fugire 8b.</p>
<h3 id="712-将z-to-t中矿工的t-address识别出来"><a class="markdownIt-Anchor" href="#712-将z-to-t中矿工的t-address识别出来"></a> 7.1.2 将z-to-t中矿工的t-address识别出来</h3>
<p>Zcash协议规定铸币交易产生的ZEC,必须先进入shield pool, 然后才能更使用, 正因为此, 很多矿池或者个人矿工在铸币交易之后还需要将地址中的ZEC转入shield pool, 使用的时候再从shield pool中取回. 由于每个矿池网站会公布自己挖出的区块信息, 这样每个铸币交易时转账的地址就可以和矿池对应起来. 于是可以统计出每个矿池随着时间增长的情况下转往poll的ZEC值得变化情况.</p>
<center><img src = "https://img-blog.csdnimg.cn/20190313210152616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>
<p>由于铸币交易存放在矿池的地址中, 矿池地址将ZEC转入pool之后把这些ZEC分发给自己的矿工, 每个矿池旗下都有很多个矿工,每个矿工都有自己的地址. 于是得出如下启发式方法.</p>
<h5 id="heuristic-4-如果一个z-to-t的交易中有超过100个输出地址只要其中1个地址属于已知的一个矿池地址那么则认为这笔交易是矿池的withdrawl交易-同时对其他输出地址标记为矿工的地址"><a class="markdownIt-Anchor" href="#heuristic-4-如果一个z-to-t的交易中有超过100个输出地址只要其中1个地址属于已知的一个矿池地址那么则认为这笔交易是矿池的withdrawl交易-同时对其他输出地址标记为矿工的地址"></a> Heuristic 4. 如果一个z-to-t的交易中有超过100个输出地址,只要其中1个地址属于已知的一个矿池地址,那么则认为这笔交易是矿池的withdrawl交易, 同时对其他输出地址标记为矿工的地址.</h5>
<p>启用该方法分析后, 最终得到在z-to-t标记中,将110918个地址标记为矿工地址, 最终得到的结果如图Fig.8c所示. top10矿池的t-to-z和z-to-t交易的信息如Table 4所示.</p>
<center><img src = "https://img-blog.csdnimg.cn/20190313213901501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>
<h3 id="713-识别其他实体交易"><a class="markdownIt-Anchor" href="#713-识别其他实体交易"></a> 7.1.3 识别其他实体交易</h3>
<h5 id="heuristic-5-如果一个z-to-t的交易中包含价值v的转账-随后若干个区块时间间隔内的z-to-t的交易中的价值也是v-则认为这笔交易时round-trip-transaction"><a class="markdownIt-Anchor" href="#heuristic-5-如果一个z-to-t的交易中包含价值v的转账-随后若干个区块时间间隔内的z-to-t的交易中的价值也是v-则认为这笔交易时round-trip-transaction"></a> Heuristic 5. 如果一个z-to-t的交易中包含价值v的转账, 随后若干个区块时间间隔内的z-to-t的交易中的价值也是v, 则认为这笔交易时round-trip transaction.</h5>
<p>这个假设看起来不那么靠谱,因为在若干个区块内t-to-z和z-to-t的两笔交易中的价值v相等的情况可能会很多,这种情况下没办法准确的将这些交易对应起来. 但是实际上经过分析发现,12,841笔不同面值的交易中, 其中9487笔交易的ZEC精确到了小数点后8位,其中的98.9%的交易,每笔交易的ZEC都精确到了小数点后3位.这些数据的特点,使得上述方法的实现成为了可能.</p>
<p>使用上述分析方法,最后识别出12841笔不同ZEC值的z-to-t和t-to-z的交易,转账总价值为 1,094,513.23684 ZEC, 其中97%的ZEC来自于矿工和创始人. 执行Heuristic 5中, 区块间隔分别设置为1~100,运行结果如图Figure 11所示. 当设置为10个区块间隔时, 可以关联到70%的z-to-t和t-to-z转账交易.</p>
<center><img src = "https://img-blog.csdnimg.cn/2019031321532617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>
<h2 id="8shielded-pool内部的交互"><a class="markdownIt-Anchor" href="#8shielded-pool内部的交互"></a> 8.Shielded Pool内部的交互</h2>
<p>文中作者分析了6,934笔z-to-z的交易, 其中包括8,444个JoinSplits.  其中93%的z-to-z交易仅仅使用1个JoinSplit作为输入. 1个JoinSplit中最多包括2个shield output作为input,  这表明大部分的z-to-z交易时以最多2个shielded output作为input. 作者不太确定 是不是一小部分用户进行了多次的交易,或者是很多用户仅仅做一次交易.这样的根本问题在于, shielded pool中z-address的个数有多少个, 并且控制他们的实体到底有多少. 实际上发现Bitclub Pool中t-to-z交易总共有196笔, 但是z-to-z交易有1516笔,这说明要么Bitclub Pool 在t-to-z之后进行了很多z-to-z的交易, 要么说明t-to-z之后还有返回的找零. 然而实际上BitClub总共只有200个z-to-t交易, 所以前者的概率更大.</p>
<h2 id="9案例分析the-shadow-brokers"><a class="markdownIt-Anchor" href="#9案例分析the-shadow-brokers"></a> 9.案例分析:The Shadow Brokers</h2>
<p>The Shadow Brokers(TSB), 是一个2016年兴起的黑客组织, 主要贩售美国国家安全局(NSA)制作的软件, TSB起先值接收Bitcoin的转账, 随后开始接收Zcash的转账.</p>
<p>作者首先翻看了TSB的博客(目前该博客的网址貌似打不开了), 在2017年5月, 该组织宣称他们开始接收Zcash作为他们的服务费, 2017年6月~8月收取Zcash和Monero, 但是9月份以后只收Zcash. Table 5展示了该组织从5月份开始到10月份,总共收到的ZEC.</p>
<center><img src = "https://img-blog.csdnimg.cn/20190313221915254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>
<p>为了识别出有关该组织的t-to-z交易, 首先排除矿工和创始人存储的有关100, 200, 400, 500的t-to-z的交易, 所以对于TSB的客户,有下述两个假设:</p>
<ul>
<li>他们的ZEC不是来自于z-to-t交易, 并应该是来自t-to-t交易,因为可以从交易所购买币种.</li>
<li>他们不是经常使用ZEC的人,因此假设这个账户的交易次数在250以内.(250这个参数估计作者根据数据定的阈值)</li>
<li>改地址所属的较大的群在1个月以内存入pool不超过1 ZEC(老实说,这个假设我没看明白是啥意思)<br />
最终得到24个疑似客户,结果如下Table 6所示.</li>
</ul>
<center><img src = "https://img-blog.csdnimg.cn/20190313225054124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>
<h2 id="10-结论"><a class="markdownIt-Anchor" href="#10-结论"></a> 10 结论</h2>
<p>该论文对Zcash的交易情况作了深入的分析, 尤其是对其匿名性保证进行了检验, 为了检验Zcash的匿名性,作者利用了众多启发式的方法以及之前对其他加密货币用过的经验分析方法. 论文研究结果表明大多数的用户并没有很好地使用ZCash的匿名性,或者说大多数的用户并没有很好地使用ZCash的匿名性, 与shield pool 进行交互进行匿名的方式仍然留下了线索从而被识别出来, 这减少了ZCash 中的匿名集的范围, 也严重的损害了其他用户的匿名性.</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hzxgoforward.github.io/2019/02/22/%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C%E7%A7%91%E6%99%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌虎下山">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/22/%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C%E7%A7%91%E6%99%AE/" class="post-title-link" itemprop="https://hzxgoforward.github.io/index.html">闪电网络科普</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建于：2019-02-22 21:16:44" itemprop="dateCreated datePublished" datetime="2019-02-22T21:16:44+08:00">2019-02-22</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="更新于：2019-11-08 15:11:28" itemprop="dateModified" datetime="2019-11-08T15:11:28+08:00">2019-11-08</time>
              
            
          </span>

          

          
            
          

          
          

          

          


          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="闪电网络"><a class="markdownIt-Anchor" href="#闪电网络"></a> 闪电网络</h2>
<p><img src="https://img-blog.csdnimg.cn/20190505213250545.jpg" alt="在这里插入图片描述" /><br />
很多人说闪电网络是比特币的未来，是趋势。但笔者始终觉得，如果不能理解底层的技术原理，就无以言对上层应用的深刻理解，更不足以谈对未来趋势的判断。接下来，我将在Aaron van Wirdum 编写的《闪电网络三部曲》的基础上，用更加通俗的语言介绍闪电网络。感谢Aaron van Wirdum绘制的交易结构图，这对我们理解闪电网络将会起到莫大的帮助。</p>
<p>理解闪电网络主要分为两步，一是理解双向支付通道，二是诸多通道扩展成闪电网络。</p>
<p>闪电网络想要解决的是比特币扩容、交易即时确认和手续费高的问题。举个例子来说明闪电网络整体思路，设想我们的老朋友Alice要给Bob转1个比特币，她该怎么做呢？</p>
<p>传统做法是Alice可以挑选出其未花费的输出用对应私钥签名，并向比特币网络广播，矿工验证打包，一般来说6个区块之后即可确认交易。这个过程很慢，需要等待一个小时左右，并且还要支付给矿工的手续费。于是呢，天才的程序员们碰撞出了闪电网络的解决方案。</p>
<p>操作过程是这样的，Alice和Bob先各自把5个BTC转给一个由两人共同控制的多重签名地址。这笔交易和比特币网络上其他普通交易没什么太大区别，只是转出的地址是一个多签地址。这个过程称为开启通道。</p>
<p>多重签名技术（multisig）是多个用户同时对一个数字资产进行签名。可以简单地理解为，一个账户多个人拥有签名权和支付权。如果一个地址只能由一个私钥签名和支付，表现形式就是1/1；而多重签名的表现形式是m/n，也就是说一共n个私钥可以给一个账户签名，而当m个地址签名时，就可以支付一笔交易。例如，多重签名2/3，表示3个人拥有签名权，而两个人签名就可以支付这个账户里的比特币；多重签名1/2，表示2个人拥有签名权，谁都可以单独来支配这笔资金。</p>
<p>开启通道后，这个多签地址里面就拥有10个比特币，这是被区块链记录了的，全网承认。接下来就是Alice和Bob私底下的交易了，不广播，不记在链上，正因如此，交易确认速度快，几乎零手续费（其实可能还有较低的路由费，后文会讲），这个过程称为链外交易，在交易通道（channel）中进行。（注意：有很多人问为什么闪电网络很快，我想说，没有第三方记账当然快啊。）</p>
<ol>
<li><strong>构建双向支付通道</strong></li>
</ol>
<p>什么是通道？怎么在通道进行交易呢？它安全吗？</p>
<p>简单来说，Alice和Bob都会在各自的小本本上记账，他们都知道对方怎么记的，且有密码学设计保证谁也不能多记耍赖。这当然也是由闪电协议精巧的设计保证的，后文再讲技术细节。</p>
<p>那么我们就可以想象出这样一个通道：在这个通道中，一开始Alice和Bob各有有5个，如果第一笔记“Alice有4个，Bob有6个”，这就相当于Alice给Bob转了1个比特币。如果，过了几天，Alice又要向Bob支付2个比特币，那么他俩会再记一次账，这次记“Alice有2个，Bob有8个”，同时上次记的“Alice有4个，Bob有6个”在两人共同确认后作废，也就是说，本次记账后，Alice只有2个比特币，她不能再拿出旧账单说“Alice有4个，Bob有6个”。</p>
<p>注意，在通道关闭之前，这10个比特币只能在Alice和Bob之间使用。也就是说，在不关闭通道的情况下，主网只知道多签地址有10个比特币，并不知道Bob已经拥有了其中的8个比特币，这就是所谓“双向支付通道”。</p>
<p>关于这个记账过程，EthFans翻译的《用算盘了解闪电网络》可以说很形象了。<br />
<img src="https://img-blog.csdnimg.cn/20190505213121133.png" alt="在这里插入图片描述" /></p>
<p>之后Alice和Bob就可以在通道里过上你来我往的相互转账的愉快生活，远离主链的拥堵与高费用。这就好比俩人结婚了，夫妻们想要私下结算，只要俩人同意，想怎么算就怎么算。</p>
<p>天有不测风云，突然有一天，Alice不想和Bob这么转来转去了，想取出自己在通道里的钱去外面的花花世界潇洒快活。那么就需要关闭通道了，常有两种方式，一是协议离婚，如下图，这种方式很和平，双方共同从最开始的多签地址签名发起一笔交易分别转到两人各自控制的地址对应数额的比特币，同时将之前记在小本本上的所有旧账一笔勾销。<br />
<img src="https://img-blog.csdnimg.cn/20190505213501880.jpg" alt="在这里插入图片描述" /><br />
二是起诉离婚，Alice想离而Bob不想离，这时Alice可以单方面强制关闭通道，将小本本最后一笔交易广播出去，只要矿工验证并打包进区块，这婚也算离了，代价是Alice并不能立马得到比特币，需要等待一定时间。本着劝和不劝分的原则，闪电协议设置了哈希时间锁定合约，单方面强制离婚（关闭交易通道）会受到延迟收到退款的惩罚，这是为了保证双方交易的稳定。</p>
<p>以上最后一个过程是通道关闭。注意，不管是协议离婚还是起诉离婚，这都是要法院受理登记的。关闭通道一定要发起交易并广播到主网，最后矿工记录，所以还是要忍耐一定确认时间和支付手续费的，这与闪电网络无关。</p>
<p>至此我们已经知道了Alice和Bob链下互相转账的那点事儿了，这就是所谓“双向支付通道”。开启通道需要在主链交易，这是锁定资金，关闭通道也需要在主链交易，这是释放资金。中间可以进行任意多次转账支付，是0确认0手续费的。</p>
<ol start="2">
<li><strong>将双向支付通道扩展成闪电网络</strong></li>
</ol>
<p>新问题来了，世界上除了这两位，还有Carol、Eric、Diana等等。设想Alice想转给Carol 1个BTC,她该怎么办呢？自然地，她俩可以再重复上述操作建立一个双向通道。但是，如果我们为了应用闪电网络，需要世界上每两个人之间都建立一条通道，这将是非常大的工作量且不切实际的。为了解决这一问题，我们需要将<strong>双向支付通道扩展成闪电网络</strong>。</p>
<p>假如Bob和Carol之间已经建立了支付通道，而Alice和Bob之间也有支付通道，那么Alice可以先把钱转给Bob再由他转给Carol，即Bob充当了支付的中间人，在网络里他就是一个<strong>路由节点</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/20190505213723692.png" alt="在这里插入图片描述" /><br />
如上图，B和C，A和B之间有通道， A和C就通过B来达成交易。更一般地，A和F可以经过B、D来交易。</p>
<p>当很多的节点相互建立通道，最后就会形成闪电网络。<br />
<img src="https://img-blog.csdnimg.cn/20190505213812781.png" alt="在这里插入图片描述" /></p>
<h2 id="闪电网络原理技术细节版"><a class="markdownIt-Anchor" href="#闪电网络原理技术细节版"></a> 闪电网络原理技术细节版</h2>
<p>通过上文，我们差不多了解了闪电网路是如何形成的。但是看完大家一定会觉得有哪里不对劲。哪里不对劲呢？</p>
<p>我们来回顾一下历史。</p>
<p>如果Alice和Bob完成了一笔交易，他们手头各自都有账本，在没有第三方见证的情况下，他们都可能把账本按照对自己有利的方向进行篡改。银行是怎么解决这个问题的呢？在传统的银行业中，由于Alice和Bob都信任银行，因此银行充当了双方都信任的第三方来进行记账，并且以第三方的账目为准，因此双方不管怎么篡改账本都没用。区块链是怎么解决这个问题的呢？区块链同样引入了第三方来充当记账者，虽然Alice和Bob都不信任记账者，但系统会想尽办法来保证记账者的诚实性。</p>
<p><strong>但是到了闪电网络，请注意，这里再也没有一个第三方记账者了！Alice和Bob又重新拿回了他们的小本子，各自记起了各自的账本。问题在于怎么保证他们都诚实记账！</strong></p>
<p>1.<strong>双方支付通道：如何使记账的双方保持诚实？</strong></p>
<p>这是一个非常有意思的问题，使得我们的第一步——建立“双向支付通道”,变得难以维持了。那么，Alice和Bob这样两个完全不信任对方的陌生人，究竟该如何在没有主链矿工记录的情况下，相互转账交易？</p>
<p>作为铺垫，我们需要讲解两个概念，哈希时间锁定和哈希密钥锁定。首先是哈希时间锁定，这是在交易脚本里面设置时钟，必须要等设定时间之后，才能用地址的私钥签名解锁地址里的比特币。例如Alice收到了一笔2 BTC转账，但是对方设定了1000个区块之后才能解锁，所以Alice必须等待1000个区块之后才能用自己的私钥签署交易,花费其中的BTC转给Bob。</p>
<p><img src="https://fs.bitcoinmagazine.com/img/articles/understanding-the-lightning-network-part-building-a-bidirectional-payment-channel-74.jpg" alt="" /></p>
<p>其次是哈希密钥锁定。哈希函数可以把一串输入转换成256位固定长度的输出，计算过程称为一次哈希运算，其中输入称为密文，输出称为密文的哈希值。哈希函数具有单向性，即从密文可以算出哈希值，但是从哈希值反向算出密文几乎是不可行的。计算的办法是暴力破解，逐一输入密文进行哈希运算，验证运算结果是否为要求的哈希值。基于这种特性，可以把一个密文的哈希值放入交易的输出当中充当哈希密文锁，也就是必须得输入该哈希值对应的密文才能解锁脚本中的比特币。例如，例如Alice收到了一笔2BTC转账，但是对方设定了哈希值锁定，所以Alice必须得到交易方的密文，同时配合自己的密钥签名才能签署交易，花费其中的BTC转给Bob。</p>
<p><img src="https://img-blog.csdnimg.cn/20190505213917413.jpg" alt="在这里插入图片描述" /></p>
<p>有了这两个工具，让我们看看那群程序员天才们是如何构想出一个程序，使得互不相识的双方能够诚实记账的。</p>
<p>在原理的白话版我们已经讲过了关于通道的三个步骤：开启通道，通道内交易，关闭通道。</p>
<p>开启通道较为简单，Alice和Bob分别向多签地址1转入5个BTC。这是一个2/2地址，也就是必须两人都签名，此地址的比特币才可以转出去。</p>
<p><img src="https://img-blog.csdnimg.cn/20190505214529422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<p>接下来是通道内交易，我们需要讲解Alice和Bob之间的两次交易才能完全明白双向支付通道的巧妙之处。第一次Alice需要向Bob支付1个BTC，第二次Bob需要向Alice支付1个比特币。</p>
<p>第一次交易的流程是，Bob首先在自己电脑的闪电网络软件上构建交易，如下左图所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20190505214228653.png" alt="在这里插入图片描述" /></p>
<p>Bob在构建交易时需要通过闪电网络软件的通信模块和Alice建立联系，获得Alice创建的密文的哈希值，然后把这个哈希值作为哈希锁放在自己构建的交易里。这笔交易Bob把10个比特币分别转给Bob控制的普通地址6个和另一个“多签地址2”4个BTC。（<strong>通俗来讲，就是A和B的财产放在一起，但是B主动从A那里要了一把锁把A的财产锁住了，没有A的钥匙B也无法打开。</strong>）</p>
<p>多签地址2是一个1/2地址，也就是两个条件有一个满足即可解锁。具体来说，需要Bob用自己的私钥和Alice的密文（此时Bob只有密文的哈希值，并不知道密文，所以Bob是不可能获得这4个比特币的）同时来解锁；或者Alice等待1000个区块后用私钥来解锁。如下图，这两个条件是双向支付通道的精髓所在，请先记住它，稍后分析中会讲设计的原因。</p>
<p><img src="https://img-blog.csdnimg.cn/20190505214414640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<p>Bob构建完交易后会签名，然后把这笔未完成的交易以点对点方式发送给Alice，而不是广播到全网。显然，上述交易是对Bob有利的，一旦Alice签名并广播，Bob可以立即获得6个比特币，而Alice需要等到1000个区块之后才能拥有4个比特币。<strong>这也就是上文提到的单方面“起诉离婚”会受到延时惩罚的技术实现细节。然而，这笔对Bob有利的交易的主动控制权却掌握在Alice手里，因为Alice不签名并广播的话，这笔交易暂时不会生效的。</strong></p>
<p>在Bob创建这笔对自己有利的交易同时，Alice也创建了类似的一笔对自己有利的交易，两者是一种镜像。这个过程相当于是Alice帮Bob在他的小本本上记了一笔账，这10个比特币Bob占6个，Alice占4个，同理Bob也帮Alice记账了。具体来说，就是Alice电脑里保存着Bob创建并签名的未完成交易，Bob保存着Alice创建并签名的未完成交易。两者合在一起，就完成了他们之间第一笔交易的记账过程，完整过程如下图。</p>
<p><img src="https://fs.bitcoinmagazine.com/img/articles/understanding-the-lightning-network-part-building-a-bidirectional-payment-channel-76.jpg" alt="" /></p>
<p>这个过程并不需要互相信任，只需双方同时在线，建立联系并交换哈希值，再在各自的电脑里创建交易最后发送给对方。整个过程不需要经主链由矿工打包确认，所以非常快速并且没有手续费。也可以看到，任何一方都可以随时强制关闭通道，将自己占主动权的交易签名并广播全网，代价是1000区块延时,如何理解1000区块的延迟呢,Bob写的交易此时在Alice手中,Alice写的交易在Bob手中,假若Bob单方面对Alice写的交易进行签名后广播,这个交易Alice可以立马拿到4BTC,但是Bob需要等待1000个区块之后才能拿到6个BTC,这就是单方面撕毁合约的惩罚.</p>
<p>但是这里仍然有一个问题，就是外界无法知道通道内的交易次序，因此无法鉴别通道关闭后广播出去的交易，是否为最终交易。例如，如果双方在这个通道里不断发生交易，最后导致Alice手中有9个，Bob手里有1个，但假设最后Bob强制关闭交易通道，并广播出去Alice有5个，Bob有5个，Bob便能凭空赚得4个。（虽然这4个要等到1000个区块后才能获得，但这是值得的。）该怎么解决这个问题呢？</p>
<p>这次我们就要再次用到上文提到的哈希密钥锁了。</p>
<p>现在我们考虑过了两天，Bob要向Alice转1个BTC，即双方发生第二笔交易B。类似他们仿照上述第一笔交易操作进行第二次记账，此时应当是Alice 5个，Bob 5个。</p>
<p><img src="https://fs.bitcoinmagazine.com/img/articles/understanding-the-lightning-network-part-building-a-bidirectional-payment-channel-77.jpg" alt="" /></p>
<p>**一个最大的区别是建立第二笔交易B之前，两人会相互交换第一笔交易中的密文，即对方第一把锁的钥匙。**这么做的目的在于作废第一笔交易记录A，使得两人都只能承认最新的交易记录B有效。</p>
<p>设想Bob在第一笔记录中拥有6个比特币，而第二笔记录变成了5个，那么如果他想作弊去签名并广播第一条记录呢？</p>
<p><strong>结果是他将失去通道内所有的比特币！</strong></p>
<p>因为Bob签名并广播了下图交易之后，Alice立马会获得4个BTC，同时Bob则必须等待1000个区块之后才能解锁6个BTC。然而，由于此时Alice已经获得了密文即钥匙1，所以Alice可以赶在Bob之前解锁这6个BTC。综合来看，只要Bob想要广播旧交易记录，他就会一无所有。</p>
<p><img src="https://img-blog.csdnimg.cn/201905052147117.png" alt="在这里插入图片描述" /></p>
<p>有了能作废旧账的保证，双方就可以在通道内反复任意多次交易，每次交易之后的状态都是资金池资金的划分比例的最新确认状态。</p>
<p>最后，关闭通道。如本文第二部分所讲，有两种方式关闭通道，一是单方面强制关闭，即某一方将自己控制的最新交易签名后广播出去即可。二是商议后关闭，此时双方再从最开始的多签地址构建一笔交易。</p>
<p>至此，我们明白了如何在无信任的条件下如何建立双向支付通道。</p>
<p>2.<strong>闪电网络：如何使路由节点保持诚实？</strong></p>
<p>同样的，在建立闪电网络的时候，我们同样会遇到信任问题：Alice想转给Carol 1个BTC，需要经过Bob，但Bob会担心自己给Carol转1BTC后，Alice耍赖；同样Alice会担心如果先给Bob转了1BTC，Bob也耍赖不转给Alice。在传统的金融系统中，是由大型知名金融中介机构的信用提供保证的。但闪电网络中，并没有这样一个独立于交易者的第三方去提供信用担保。</p>
<p>闪电网络采用了一种HTLC(哈希时间锁定合约)完美解决了这个问题。</p>
<p><img src="https://img-blog.csdnimg.cn/20190505214818498.jpg" alt="在这里插入图片描述" /></p>
<p>过程是这样的，第一，Carol会选择一个随机密文并运算得到其哈希值，再将此哈希值交给Alice。第二，Alice拿到哈希值后，会构建一笔转账给Bob的交易。这笔交易需要Bob拿到Carol的密文才能解锁，如果Bob在限定的时间内没有解锁成功，这笔钱则退回给Alice。第三，Bob从Alice处拿到哈希值，他也构建一笔转账给Carol的交易，Carol必须拿密文来解锁。第四，当Carol提供密文从Bob处获得1个BTC，Bob立马会拿密文从Alice处获得1个BTC，这就完成了从Alice给Carol转账的任务。</p>
<p><strong>上述过程可以看作一个智能合约。故事类似于这样：A想经过B转账给C，那么C先给A一把锁，C有钥匙A有钱。A跟B说，你从C那里拿到了钥匙，我的钱就是你的了。B就拿着锁去找C，用钱跟C换钥匙，然后拿钥匙去换A的钱。如此一来，就实现了钱和锁从A到B再到C，钥匙从C到B再到A的一个流转。</strong></p>
<p>当然，在实际操作过程中，Alice给Bob转账金额需要大于1个BTC，支付必要的路由费以激励Bob充当路由节点。<strong>其次，要注意两笔交易之间的哈希时间长度设置，第二步时间必须长于第三步时间。如果Bob在Alice关闭交易之后拿到Carol的钥匙，他将无法找Alice拿回1个BTC。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190505214923254.jpg" alt="在这里插入图片描述" /></p>
<p>到这里，我们已经明白了闪电网络中通过路由节点达成交易的技巧，最后一步只需把之前两步整合进交易即可，就不再赘述了。</p>
<h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/0KeSq2w8VBoeMYALAoVc9g">原文链接</a><br />
<a target="_blank" rel="noopener" href="https://bitcoinmagazine.com/articles/understanding-the-lightning-network-part-building-a-bidirectional-payment-channel-1464710791/">Understanding the Lightning Network, Part 1</a><br />
<a target="_blank" rel="noopener" href="https://bitcoinmagazine.com/articles/understanding-the-lightning-network-part-creating-the-network-1465326903/">Understanding the Lightning Network, Part 2</a><br />
<a target="_blank" rel="noopener" href="https://bitcoinmagazine.com/articles/understanding-the-lightning-network-part-completing-the-puzzle-and-closing-the-channel-1466178980/">Understanding the Lightning Network, Part 3</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">&gt;</a>
  </nav>


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar2.jpg"
                alt="博主" />
            
              <p class="site-author-name" itemprop="name">博主</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/hzxGoForward" title="github &rarr; https://github.com/hzxGoForward" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>github</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://www.zhihu.com/people/wen-ge-hua-49/activities" title="zhihu &rarr; https://www.zhihu.com/people/wen-ge-hua-49/activities" rel="noopener" target="_blank"><i class="fa fa-fw fa-globe"></i>zhihu</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="/hzx@pku.edu.cn" title="email &rarr; hzx@pku.edu.cn"><i class="fa fa-fw fa-envelope"></i>email</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://me.csdn.net/t46414704152abc" title="csdn &rarr; https://me.csdn.net/t46414704152abc" rel="noopener" target="_blank"><i class="fa fa-fw fa-globe"></i>csdn</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://leetcode.cn/u/hzxforward/" title="leetcode &rarr; https://leetcode.cn/u/hzxforward/" rel="noopener" target="_blank"><i class="fa fa-fw fa-globe"></i>leetcode</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </section>

      

      

<!--背景音乐-->
<!--iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=86 src="//music.163.com/outchain/player?type=2&id=37856454&auto=1&height=66"></iframe> --> 
<!--<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=556319523&auto=1&height=66"></iframe> -->
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=86 src="//music.163.com/outchain/player?type=2&id=4341314&auto=1&height=66"></iframe>

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

<div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">博主</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v6.3.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.6.0</div>


<div>
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!--注释本行<span id="busuanzi_container_site_pv" style='display:none'>-->
    本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    <span class="post-meta-divider">|</span>
</span>
<span id="busuanzi_container_site_uv" style='display:none'>
    本站访问<span id="busuanzi_value_site_uv"></span>人次
</span>
</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="Total Visitors">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="Total Views">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
      
  
  <script type="text/javascript" color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.6.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.6.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  










  





  

  

  

  



  
  

  
  
    
      
    
      
    
      
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<style>
.MathJax_Display {
    overflow: auto hidden;
}
</style>

    
  


  
  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('Copy').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('Copy')
        }, 300)
      }).append(e)
    })
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->


  

</body>
</html>
