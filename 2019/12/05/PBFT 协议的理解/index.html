<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.6.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.6.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '6.6.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false,"padding":18},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="PBFT 是一种分布式节点间的状态复制协议,在总节点数为n的情况下,它能容错不超过 $\lfloor \frac {n-1}{3} \rfloor$ 的拜占庭节点,使得大多数的状态复制机(replica)保持一致的状态。保持分布式节点之间的系统状态的一致性,只需要做到如下两点即可:  系统中节点就 client 的  request 分配一个唯一的编号,并且对于系统中任意两个非故障节点,同一个">
<meta property="og:type" content="article">
<meta property="og:title" content="共识协议 PBFT 协议的理解">
<meta property="og:url" content="https://hzxgoforward.github.io/2019/12/05/PBFT%20%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%90%86%E8%A7%A3/index.html">
<meta property="og:site_name" content="HuZhenXing">
<meta property="og:description" content="PBFT 是一种分布式节点间的状态复制协议,在总节点数为n的情况下,它能容错不超过 $\lfloor \frac {n-1}{3} \rfloor$ 的拜占庭节点,使得大多数的状态复制机(replica)保持一致的状态。保持分布式节点之间的系统状态的一致性,只需要做到如下两点即可:  系统中节点就 client 的  request 分配一个唯一的编号,并且对于系统中任意两个非故障节点,同一个">
<meta property="og:locale">
<meta property="article:published_time" content="2019-12-04T16:00:00.000Z">
<meta property="article:modified_time" content="2023-03-05T12:45:43.597Z">
<meta property="article:author" content="hzx">
<meta property="article:tag" content="PBFT">
<meta name="twitter:card" content="summary">






  <link rel="canonical" href="https://hzxgoforward.github.io/2019/12/05/PBFT 协议的理解/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>共识协议 PBFT 协议的理解 | HuZhenXing</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">HuZhenXing</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">与其感慨路难行，不如马上出发!</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hzxgoforward.github.io/2019/12/05/PBFT%20%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%90%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuZhenXing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">共识协议 PBFT 协议的理解
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建于：2019-12-05 00:00:00" itemprop="dateCreated datePublished" datetime="2019-12-05T00:00:00+08:00">2019-12-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="更新于：2023-03-05 20:45:43" itemprop="dateModified" datetime="2023-03-05T20:45:43+08:00">2023-03-05</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="index"><span itemprop="name">共识协议</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <span class="post-meta-divider">|</span>
            <span id="busuanzi_value_page_pv"></span>次阅读
          


          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>PBFT 是一种分布式节点间的状态复制协议,在总节点数为n的情况下,它能容错不超过 $\lfloor \frac {n-1}{3} \rfloor$ 的拜占庭节点,使得大多数的状态复制机(replica)保持一致的状态。保持分布式节点之间的系统状态的一致性,只需要做到如下两点即可:</p>
<ol>
<li>系统中节点就 client 的  request 分配一个唯一的编号,并且对于系统中任意两个非故障节点,同一个  request 对应相同并且唯一的编号.</li>
<li>系统中的节点有序的执行   request ,保证任意两个非故障节点的系统状态一致.</li>
</ol>
<p>PBFT 协议通过完成上述两个要求从而实现了系统的一致性.在介绍PBFT协议的具体内容前,应该首先明确该协议的系统模型. </p>
<h2 id="一、-系统模型"><a href="#一、-系统模型" class="headerlink" title="一、 系统模型"></a>一、 系统模型</h2><ul>
<li>网络是异步的分布式网络,网络中节点之间会出现信息发送失败, 延迟,重复发送,甚至无序的情况.</li>
<li>系统中可能有一个强力的恶意节点联合其他节点,故意导致发送信息出现延迟或者故意延迟正确的节点发送的信息,但是恶意节点不能无限延迟.</li>
<li>恶意节点无法伪造诚实节点的签名,而恶意节点之间可能串通,可以相互伪造签名.</li>
<li>恶意节点无法通过一条消息的摘要计算出消息体.</li>
<li>恶意节点无法针对一个消息m,找到另外一个对应的消息m’使得它们的摘要相同.(摘要是对消息求hash).</li>
<li>系统中总结点数为n的时候, PBFT协议最多容忍 $\lfloor \frac{n-1}{3}\rfloor$​ 的拜占庭节点.</li>
</ul>
<h2 id="二、-系统角色"><a href="#二、-系统角色" class="headerlink" title="二、 系统角色"></a>二、 系统角色</h2><ul>
<li><strong>Replica</strong>, 状态复制机,所有的 replica 都会执行 PBFT 协议并保持系统状态一致性.</li>
<li><strong>Primary</strong>, 在 PBFT 协议中,每个 primary 都有一个任期,称之为 view, 在一个 view 中,只有一个 replica 会被称为 primary,可以理解为leader.</li>
<li><strong>Backup</strong>,除了primary 以外的 replica 都称之为backup.</li>
<li><strong>client</strong>, 向 primary 发送 request 请求服务的客户端.</li>
</ul>
<h2 id="三、PBFT协议简述"><a href="#三、PBFT协议简述" class="headerlink" title="三、PBFT协议简述"></a>三、PBFT协议简述</h2><p>PBFT 协议以状态机复制的形式展示,将服务建立为在分布式环境下跨机器之间进行数据复制的状态机模型. 每一个状态复制机都会维护一个当前的服务状态,PBFT 协议可以保证所有非拜占庭节点的系统状态全部相同, 而这些状态复制机执行客户的请求后转入下一个状态,并将执行结果反馈给 client.</p>
<p>在PBFT协议中,主要有三个身份,client,primary 和 backup。replica 中有一个主节点,称之为primary, 其他 replica 称之为backup. client向 primary 发出操作请求, primary 把 client 的请求发送给所有 backup , primary和其他backup通过按照PBFT协议对操作进行响应,然后将执行结果返回给client. </p>
<p>PBFT论文中默认client在收到前一个 request 的执行结果之前不会发送下一个 request .每一个primary在其任期内对应一个view, 下一任primary上任时,view自动加1. 一个view中只有一个primary.</p>
<p>整个协议的整体流程如下:</p>
<ul>
<li>client向 primary发送一个  request .</li>
<li>primary向其他备份节点广播  request .</li>
<li>所有节点执行  request 并且向client返回执行结果</li>
<li>client 从f+1个不同的节点处得到相同的执行结果,则认为执行结果可靠并且接受这个结果.</li>
</ul>
<h2 id="PBFT-细节"><a href="#PBFT-细节" class="headerlink" title="PBFT 细节"></a>PBFT 细节</h2><p>再次强调的是，在该协议中,假定拜占庭节点的数目最多为 $f$​​ 个, 而全体节点的数目为 $n = 3f+1$​​​.</p>
<h3 id="1-client-发出-request"><a href="#1-client-发出-request" class="headerlink" title="1. client 发出 request"></a>1. client 发出 request</h3><p>client 向 primary 发出一个  request ,   request 的具体形式如下:</p>
<p>$<REQUEST, o,t,c>_{\sigma i}$</p>
<p>$o$ 表示 operation,即具体执行的操作, t 表示 <em>timestamp</em>, 之所以需要加上时间戳, 是在一个client在发出多次相同operation的时候, primary 用 timestamp 区分这些命令, c 表示 client 编号, $\sigma i$ 表示 client $i$ 将这些信息进行签名,以证实自身合法的身份.</p>
<p><strong>注意</strong>: 如果 client 将  request 发送给了 backup 节点,那么该节点会将 client 的 request 转发给 primary.</p>
<h3 id="2-pre-prepare-阶段"><a href="#2-pre-prepare-阶段" class="headerlink" title="2. pre-prepare 阶段"></a>2. pre-prepare 阶段</h3><p>为了确保所有的非拜占庭节点保持一致的状态, primary 需要对 request 分配一个序号(sequence number),如果全体 replica 能够对每一个  request 的序号达成一致,那么就能达成整个系统服务状态的一致性. </p>
<h4 id="2-1-Primary-收到-Request"><a href="#2-1-Primary-收到-Request" class="headerlink" title="2.1 Primary 收到 Request"></a>2.1 Primary 收到 Request</h4><p>收到一个 request 时，primary会检查 request 的合法性,首先检查客户端的签名是否正确, 如果不正确,则拒绝执行后续步骤; </p>
<p>如果正确,则给 request分配一个唯一的序列号n,然后向其他 backup 广播一条 $pre-prepare$ ​​​​(预准备)消息,形式如下:</p>
<p> $\left &lt;  \left &lt;  PRE-PREPARE, v, n, d  \right &gt; _{\sigma p}, m \right &gt;$</p>
<p>$v$是当前<em>view</em>序号, $n$​是 primary 为 request 分配的序列号, d是 request 的摘要, m 代表 client的 request 信息, $\sigma_p$​ 是 primary 的签名.</p>
<h4 id="2-2-Backup-收到-pre-prepare消息"><a href="#2-2-Backup-收到-pre-prepare消息" class="headerlink" title="2.2 Backup 收到 pre-prepare消息"></a>2.2 Backup 收到 pre-prepare消息</h4><p>backup收到pre-prepare消息时,会验证如下消息:</p>
<ul>
<li>request 的签名是否正确, 确保client的签名不是伪造的.</li>
<li>view的序列号与当前backup当前的view序列号相等.</li>
<li>backup确定当前 <em>view</em>下,序号n没有分配给另外一个不同的  request .</li>
<li>n应该在某个范围[h, H].</li>
</ul>
<p>如果上述条件全部符合,则backup接受这个 $pre-prepare$ 消息, 并且进入 <strong>prepare</strong> 阶段.</p>
<h3 id="3-prepare阶段"><a href="#3-prepare阶段" class="headerlink" title="3. prepare阶段"></a>3. prepare阶段</h3><h4 id="3-1-广播-Prepare-消息"><a href="#3-1-广播-Prepare-消息" class="headerlink" title="3.1 广播 Prepare 消息"></a>3.1 广播 Prepare 消息</h4><p>对于 Prepare 阶段做一下解释，节点收到 pre-prepare 消息之后，相当于收到了一个来自 primary 的提议，但是节点不清楚其他节点是否收到了同样的 pre-prepare 信息，因为 primary 节点可能是恶意节点，它可能向其 backup 发送不同的 pre-prepare 信息。因此，每个节点向网络中其他节点广播 prepare 信息进行同步，其含义是告诉其他节点：本节点收到了来自 primary 的一条 pre-prepare 信息。</p>
<p>backup 在 prepare 阶段,向本地的log中插入 $pre-prepare$​ 消息以及自身的 $prepare$ 消息 ,并向其他 backup(包括primary)广播一条<em>prepare</em>消息,<em>prepare</em>消息形式如下:</p>
<p>$\left &lt; PREPARE, v, n, d,i\right &gt;_{\sigma i}$</p>
<p>其中 $i$​​ 是 backup 的编号, $\sigma_i$​​ 表示节点 $i$​​ 的签名, backup(包括primary)收到来自其他节点的prepare消息时,会验证如下信息:</p>
<ul>
<li>view 序号和节点自身的 view序号相同.</li>
<li>n在 [h,H] 范围内.</li>
<li>d 和 pre-prepare阶段消息的摘要相同。</li>
</ul>
<p>如果上述验证通过,则将这条信息插入本地log. </p>
<p>如果一个节点收到 $2f+1$ ​(包括自身的)相同的 $prepare$ 消息,并且这些消息与之前收到的 $pre-prepare$ 消息的 $m, v, n$​​相同, 则认为 <strong><em>prepared(m, v, n, i)</em></strong> 为真,并将 <strong>prepared(m, v, n, i)</strong> 插入log, 然后进入<em>commit</em> 阶段.</p>
<h4 id="3-2-pre-prepare-和-prepare-阶段的作用"><a href="#3-2-pre-prepare-和-prepare-阶段的作用" class="headerlink" title="3.2 pre-prepare 和 prepare 阶段的作用"></a>3.2 pre-prepare 和 prepare 阶段的作用</h4><p>$prepared(m, v, n, i)$​​​ 的主要作用就是,确保在一个 view 中，一个 request 唯一的对应一个序列号 n。因为 $prepared(m, v, n, i)$​​​为真的条件是,有$2f+1$​​​个节点广播信息验证了$m, v, n$​​​的一一对应关系.证明如下：</p>
<ol>
<li>$2f+1$​ 个一致的 $prepared(m, v, n, i)$​消息中，最多有 $f$​ 个拜占庭节点的 prepared 消息, 至少有 $f+1$​ 个诚实节点的 $prepared(m, v, n, i)$​ 消息。</li>
<li>剩余的 $f$​ 个诚实节点由于收到了错误的prepare 消息，它们互相广播 $prepared(m’, v, n, i)$​ 。由于存在 $f$​ 个拜占庭节点，这些节点可能广播了 $f$​ 个 $prepared(m, v, n, i)$​  消息，又作恶的广播了 $f$​ 个 $prepared(m’, v, n, i)$ 消息，此时也只能存在 $2f$ 个 $prepared(m’, v, n, i)$ 消息，这不足以达成一致 (达成一致的要求是至少$2f+1$个相同的prepared消息)。</li>
</ol>
<p>综上所述， <em>pre-prepare</em>和<em>prepare</em>两个阶段保证了在<strong>同一个 view下</strong>,n 和 request 的一一对应关系. 这一步骤带来的好处是，即使发生了 view change，此时最多 f 个节点出错，那么剩余的 2f+1 个节点至少有一个节点保留有最新的 2f+1 个prepare信息。当新的 leader 产生时，最新的 2f+1 个 prepare 消息仍然会被执行，保证了系统的安全性。</p>
<h3 id="4-commit阶段"><a href="#4-commit阶段" class="headerlink" title="4. commit阶段"></a>4. commit阶段</h3><h4 id="4-1-广播-commit-消息"><a href="#4-1-广播-commit-消息" class="headerlink" title="4.1 广播 commit 消息"></a>4.1 广播 commit 消息</h4><p>对 commit 消息再作下解释，进入 commit 阶段的前提是节点收到了 2f+1 个合法的prepare消息，然而在异步环境下，节点不知道其他节点是否也收到了 2f+1 个prepare 消息，所以，节点向其他节点广播一条 commit 消息，其目的是告诉其他节点：本节点已经收到了 2f+1 个prepare 消息。</p>
<p>backup 进入commit 阶段时, 向其他 backup (包括 primary) 广播一条 commit 消息,具体形式如下:</p>
<p>$\left &lt; COMMIT, v, n, D(m), i \right &gt;_{\sigma i}$</p>
<p>其他replica收到commit消息后,验证如下信息:</p>
<ul>
<li>节点 $i$​ 的签名正确.</li>
<li>view 的序号和本地 view 序号相同.</li>
<li>n在[h,H]范围内.</li>
</ul>
<p>如果上述验证全部通过,节点将该commit信息插入本地log. 如果节点$i$满足两个条件:</p>
<ol>
<li>节点 $i$​ ​​的 $prepare(m, n, v,i)$​​​ 为真,即节点 $i$​​ ​也进入commi阶段.</li>
<li>节点 $i$​ ​收到 $2f+1$​​ (包括自身)一致的 commit 信息, 并且它们与本地的 <em>pre-prepare</em>的$m, v, n$​​全部相同.</li>
</ol>
<p>则作出定义$committed-local(m, n, v, i)$​​为真的判断。</p>
<h4 id="4-2-执行-commit"><a href="#4-2-执行-commit" class="headerlink" title="4.2 执行 commit"></a>4.2 执行 commit</h4><p>$committed-local(m, n, v, i)$​​​​为真，表示系统中至少有$2f+1$ 个节点认同对 request 分配的编号，这些达成共识的节点执行 request 后的系统状态是一致的. 执行完毕后所有节点会向 client 发送一个 $reply$​ 消息. 其形式如下：</p>
<p>$<REPLY, v, t, c, i, r>_{\sigma i}$</p>
<p>其中 v 是当前的 view 编号，t 是 client 的 request 的时间戳，client可以根据时间戳判断是哪一个 request 的执行结果，因为client可能先后不同的时间发送同一个 request, i 是 replica 的编号， r 是执行结果.</p>
<h4 id="4-3-client-验证结果"><a href="#4-3-client-验证结果" class="headerlink" title="4.3 client 验证结果"></a>4.3 client 验证结果</h4><p>client如果只要收到 $f+1$​​​​个相同的执行结果（相同的 r，t）,则认为执行结果可信.</p>
<p>这里面对相同的执行结果的定义是，对应同一个 request，收到了 $f+1$​ 个执行结果，这些执行结果具有相同的 r，同时它们也对应于同一个时间戳。这里并不要求同一个 view， 具体详见 view change 阶段。</p>
<p>为什么是 $f+1$​ 个相同的结果，client 就能确保结果可信呢？ 因为 $f+1$​ 个节点中至少有一个诚实的节点，而一个诚实的节点能够执行一个 request，说明有其他 2f 个节点向其广播了 commit 信息，这 2f 个节点也必然进入了commit 阶段。这说明至少有 $2f+1$​ 个节点对 request 的编号 $n$ 达成一致，这种情况下，一个诚实节点返回的执行结果一定可信。</p>
<h3 id="5-Garbage-Collect"><a href="#5-Garbage-Collect" class="headerlink" title="5 Garbage Collect"></a>5 Garbage Collect</h3><p>每个节点都有一个日志系统记录当前系统的执行状态，但是需要定时的对系统做一个snap shot，这是为了确保其他节点从错误中恢复时，可以从中间某个状态再次启动，因此就有了 checkpoint。</p>
<p>Checkpoint 有两个作用:</p>
<ol>
<li>checkpoint之前的所有 request 的内容都已经执行，因此可以删除之前的log,节省 replica 的存储.</li>
<li>replica 丢失状态时,可以向其他节点请求系统状态时，可以请求最近的checkpoint以快速恢复状态.</li>
</ol>
<p>假设系统每执行了 $T$ 个request后进行一次checkpoint，于是replica 执行第n个request后,如果 $n\%T == 0$​​, 则该节点向其他节点广播一条checkpoint 消息:</p>
<p>$<CHECKPOINT, n, d, i>_{\sigma i}$</p>
<p>其中 <em>d</em> 是执行完第 n 个 request 后的系统状态的摘要, $i$​​是节点编号.</p>
<p>如果收到 $2f+1$​​​​ 相互一致并且合法的 heckpoint 信息,则认为这些checkpoint代表的系统状态是合法并且一致的。</p>
<p>对于一个checkpoint，如果有其他 $2f$​​ 个 与之相同的checkpoint 信息，则这个 checkpoint 可以称作是 <strong>stable checkpoint</strong>。节点可以删除 checkpoint 对应的序列号n的所有 pre-prepared, prepared 和 commit 消息。</p>
<p>当其他节点请求本地传输某个系统状态时, $2f+1$个 checkpoint 消息可以作为传输的系统状态合法的证明.</p>
<p>checkpoint协议用来对下一次序列号的范围进行设定,当某个 checkpoint 被证明合法后,对序列号范围可以调整为H = h+k, 其中h是上一次稳定检查点的序列号, 假如每100个请求后进行一次检查点验证, k 可以设置为200, 即H = 200.</p>
<h3 id="6-View-Change-视图切换"><a href="#6-View-Change-视图切换" class="headerlink" title="6. View Change(视图切换)"></a>6. View Change(视图切换)</h3><p>view-change 消息是为了应对系统中primary发生故障后切换新的 primary 的机制.</p>
<h4 id="6-1-backup广播-View-Change消息"><a href="#6-1-backup广播-View-Change消息" class="headerlink" title="6.1 backup广播 View Change消息"></a>6.1 backup广播 View Change消息</h4><p>如果 当前 view 的编号为 $v$​​​, 那么出现故障时，下一任 primary的编号为 $(v+1)\%n$​​​​​，因此，PBFT 协议不存在 primary 出现故障后其他 backup 竞争 primary 的情况，这一点和 RAFT 协议有所不同。</p>
<p>每个 backup 收到一个 request 时,就会启动一个计时器,如果计时器超时之后,仍然没有执行该 request ,该backup认为 primary 出现了故障，那么它向其他 replica 发出一个view-change消息,格式如下:</p>
<p>$<VIEW-CHANGE, v+1, n, C, P, i>_{\sigma i}$</p>
<p>其中，$v+1$​​​表示下一个视图的编号, n表示该节点已知的最近的一个stable checkpoint的编号, $C$​​ 是一个集合,其中包括 $2f+1$​​ 个有效的 checkpoint 信息以证明该 checkpoint是stable checkpoint. $P$​​ 也是一个集合,集合中的每一个元素是$P_m$​​, $P_m$​​本身又是一个集合, 每一个$P_m$​​中包含序列号大于n的<em>pre-prepare</em>消息以及与之匹配的$2f$​​​​​个 <em>prepared</em> 消息.<br>从这里看到，一条 view-change 消息中包含的消息数量复杂度是 $O(n)$ 级别的，而 $n$ 节点，每个节点都广播一个 new-view 消息，广播消息的复杂度是 $O(n^2)$ 级别，所以，整个 view-change 的广播的消息数量，其复杂度是 $O(n^3)$ 级别</p>
<h4 id="6-2-新primary广播new-view消息"><a href="#6-2-新primary广播new-view消息" class="headerlink" title="6.2 新primary广播new-view消息"></a>6.2 新primary广播new-view消息</h4><p>当 v+1视图对应的 primary 从其他 replica 收到 $2f$​ 个有效的 view-change 消息时,向其他所有节点广播new-view消息,具体格式如下:</p>
<p>$<NEW-VIEW, v+1, V, O>_{\sigma p}$</p>
<p>其中 $V$​ 是一个集合, 包括 $2f+1$​(包含新的primary自身)个view-change消息, O是pre-prepare消息的集合。</p>
<p>O的计算方式如下:</p>
<ol>
<li><p>primary 首先确定两个变量 $min-s$​​ ​和 $max-s$​​​, $min-s$​​​指的是 primary 收到的所有view-change消息中最新的stable checkpoint的对应的序号n, $max-s$​​​指的是view-change消息中,集合$P$​​​中所有$P_m$​​​中pre-prepare消息编号的最大值.</p>
</li>
<li><p>primary 为编号为$( min-s, max-s]$​范围内的  request , 重新创建view序号为v+1的 pre-prepare 信息. 这里包含两种情况:</p>
<ol>
<li>primary 收到的所有 <em>view-change</em> 消息中,至少有1个集合P不为空, 即存在某个编号$n\in (min-s, max-s]$​的<em>pre-prepare</em>消息.</li>
<li>所有的view-change消息中的集合P全部为空.</li>
</ol>
<p>第一种情况下, primary为 P  中所有 request 创建一个新的pre-prepare消息,格式为:</p>
<script type="math/tex; mode=display">\left <  \left <  PRE-PREPARE, v+1, n, d  \right > _{\sigma p}, m \right ></script><p>其中 d是该  request 的摘要, n 的范围为$(min-s, max-s]$​，这表明这些 request 虽然处于不同的 view，但是为其分配的编号仍然不变。​</p>
<p>第二种情况下, primary创建一个<em>null request</em> 的pre-prepare消息,格式如下:</p>
<script type="math/tex; mode=display">\left <  PRE-PREPARE, v+1, n, d^{null}  \right > _{\sigma p}</script></li>
</ol>
<p>$d^{null}$​是特定的的<em>null request</em>摘要, <em>null request</em>不执行任何操作.</p>
<p>随后，primary 将 $O$​ 中的信息插入 log 之中。因为 $min-s$​ 是最新的一个 checkpoint 的 request 的编号，如果 primary 发现 $min-s$​​​ 大于 primary 本地最新的stable checkpoint的编号n,则primary也会将相应的 $min-s$​​​​ 对应的 checkpoint 的 proof 插入到 log之中, 然后丢弃 stable checkpoint 之前的所有信息。</p>
<h4 id="6-3-backup-验证-new-view消息"><a href="#6-3-backup-验证-new-view消息" class="headerlink" title="6.3 backup 验证 new-view消息"></a>6.3 backup 验证 new-view消息</h4><p>当 backup 收到primary发送的new-view信息时, 检查如下信息:</p>
<ul>
<li>primary签名是否正确.</li>
<li>new-view中包含的 view-change 消息是否合法。</li>
<li>根据new view信息中的集合V计算集合$O$, 检查计算得到的$O$是否消息中的$O$一致.</li>
</ul>
<p>如果上述条件全部满足, backup选择最新的stable checkpoint, 删除stable checkpoint之前的所有log, 并根据执行集合O中的pre-prepare信息.执行步骤按照PBFT的协议进行,如果该节点已经执行过该 request ,则不再执行该 request，但是其他prepared、commit以及reply信息，都需要照常发送.</p>
<p><strong>注意:</strong> backup如果没有最新的stable checkpoint的状态,应该首先向其他节点请求最新的stable checkpoint的系统服务状态,然后再执行$(min-s, max-s]$​​范围内的 request ,否则会导致系统状态不一致.</p>
<h2 id="7-PBFT协议讨论"><a href="#7-PBFT协议讨论" class="headerlink" title="7. PBFT协议讨论"></a>7. PBFT协议讨论</h2><h3 id="7-1-为什么PBFT协议中节点总数-N-gt-3f-​-为什么后两个阶段至少需要-2f-1-​的投票"><a href="#7-1-为什么PBFT协议中节点总数-N-gt-3f-​-为什么后两个阶段至少需要-2f-1-​的投票" class="headerlink" title="7.1 为什么PBFT协议中节点总数$N&gt;3f$​,  为什么后两个阶段至少需要$2f+1$​的投票?"></a>7.1 为什么PBFT协议中节点总数$N&gt;3f$​,  为什么后两个阶段至少需要$2f+1$​的投票?</h3><h5 id="以下证明来自个人理解"><a href="#以下证明来自个人理解" class="headerlink" title="以下证明来自个人理解"></a>以下证明来自个人理解</h5><p>设系统总节点数为$N$​, 拜占庭节点数目为$f$​,于是剩余的诚实节点的数量为$N-f$​，假设系统中有 $Q$ 个节点就一个消息达成一致，那么就认为达成共识。共识协议需要保证安全性(Safeness) 和活性方面(Liveness)。</p>
<ol>
<li>活性方面，即如果系统中 f 个拜占庭节点不参与投票，那么其他节点应该能够达成一致，于是:<br><script type="math/tex">Q<=N-f \quad\quad\quad\quad\quad\quad\quad\quad\quad\quad    \bold \{1\}</script>​</li>
<li>安全性方面，考虑拜占庭节点会让系统出现两种投票方案，但是我们只能允许一个方案通过投票。假设 $f$​​ 个拜占庭节点与一部分数量为 $A$ 的节点达成共识，即 $f+A = Q$。为了让系统出现另外一种共识，$f$ 个拜占庭节点又尝试与剩余的数量为 $B$ 诚实节点达成另外一个共识，它们数量为 $f+B$, 此时不应该达成共识，于是应该有 $f+B&lt;Q$ 。我们将这两个不等式相加，得到：<script type="math/tex; mode=display">2f + A + B < 2Q \rightarrow N + f < 2Q \quad (已知A+B = N-f)\quad\quad\quad    \bold \{2\}$$​​
根据 1 和 2 得到的两个不等式，得到：
$$ N+f<2Q \leq2N- 2f</script><script type="math/tex; mode=display">\rightarrow N+f<2N-2f</script><script type="math/tex; mode=display">\rightarrow 3f < N  \rightarrow 3f+1 \leq N   \quad\quad\quad \bold\{3\}</script>将 3 的结果代入到 2 式中，得到 $2f &lt; Q$， 即 $Q$ 的取值至少为 $2f+1$。</li>
</ol>
<h5 id="下文来自-PBFT-论文证明"><a href="#下文来自-PBFT-论文证明" class="headerlink" title="下文来自 PBFT 论文证明"></a>下文来自 PBFT 论文证明</h5><ol>
<li>系统中 $f$ 个拜占庭节点可能不参与共识,此时协议应该保证剩余 $N-f$ 个 replica 达成共识，即 $Q&lt;=N-f$。</li>
<li>$N-f$​​个节点中<strong>必须保证诚实节点数量超过拜占庭节点的数量</strong>（我不太理解作者为什么想当然这么说这句话，可能BFT问题中一个已知的定理）,即 $N-f-f = N-2f &gt; f \rightarrow N&gt;3f$​​​​​​​​​.</li>
<li>$3f+1 \leq N$, 根据第 2 式可得 $2f+1 \leq Q$​.</li>
<li>当 $N = 3f+1$ 时，根据 $Q \leq N-f$,推导出$Q \leq 2f+1$,即此时Q的取值只能为 $2f+1$.</li>
<li>当$N = 3f+k, (k&gt;0)$时，Q 的取值范围为$[2f+1, 2f+k]$。</li>
</ol>
<h3 id="7-2-PBFT的三个步骤中将commit步骤去掉可以吗"><a href="#7-2-PBFT的三个步骤中将commit步骤去掉可以吗" class="headerlink" title="7.2 PBFT的三个步骤中将commit步骤去掉可以吗?"></a>7.2 PBFT的三个步骤中将commit步骤去掉可以吗?</h3><p>现在撤销$commit$步骤, 只有$pre-prepare$阶段和$prepare$,如果$prepare(m,n,v,i)$为真,则直接执行  request 并且返回给client.</p>
<p>假设有部分诚实的节点数量为$f$,成功的收到了$2f+1$与本地<em>pre-prepare</em>匹配的$prepare$消息, 它们执行了对应的request-m, 假设m对应的序号是$n$, view序号是$v$. 但是其他$2f+1$个节点在接收$prepare$消息过程中网络不好, 没能收到足够的$2f+1$个匹配的$prepare$消息, 所以它们不会执行这个m.(PBFT协议中假设网络中信息传输会出现丢失的情况). 然后这$2f+1$个节点进行了$view-change$, 并且primary在这$2f+1$个节点中产生, 这$2f+1$个$view-change$消息中没有request-m的对应的$2f$个prepared消息,并且如果出现 $2f+1$个节点的 <em>view-change</em>消息集合中的 <em>P</em>为空,新的primary重新发布$new-view$消息时,消息中的<em>O</em>只包含了一个null-request的<em>pre-prepare</em>消息:</p>
<p>$\left &lt;  PRE-PREPARE, v+1, n, d^{null}  \right &gt; _{\sigma p}$</p>
<p>此时执行了request-m的$f$个节点验证 <em>new-view</em>后通过,它们本地的序号n对应request-m,但是new-view中的序号$n$对应的是一个null request, 而不是request-m.  这就导致了这诚实的$f$个节点和另外$2f+1$个节点的系统状态已经出现了不一致.这不满足PBFT协议保证系统一致性的另外一个条件,所有系统中的非故障节点都必须对  request 的执行达成一致.</p>
<p>实际上,引入$commit$步骤中,$committed-locally$为真才执行  request 这一条件, 就是保证至少有$2f+1$个节点(其中至少$f+1$个诚实的节点)的$prepared(m,v,n)$为真, 这些节点一起执行  request .</p>
<p><em>view-change</em>时,这$2f+1$个执行了reqeust-m的节点中,至少有$f+1$个节点参与其中,这个节点的参与,保证了request-m在view序号为 <em>v+1</em>的时候分配的编号仍然是 view序号为<em>v</em>时的序号,这就是为什么论文中说$commit$步骤保证了不同$view$中  request 的有序执行.</p>
<h3 id="7-3-如果client在发出request之后在一定时间内没有收到足够多的响应怎么办"><a href="#7-3-如果client在发出request之后在一定时间内没有收到足够多的响应怎么办" class="headerlink" title="7.3 如果client在发出request之后在一定时间内没有收到足够多的响应怎么办?"></a>7.3 如果client在发出request之后在一定时间内没有收到足够多的响应怎么办?</h3><p>client会将  request 广播给所有节点, 如果收到的节点已经处理了这条  request ,则会直接向client返回执行结果.如果该节点没有处理过这条  request ,则会将这条  request 转发给primary. 如果primary在一段时间内不广播该  request ,其他节点会怀疑primary作恶并且进行$view-change$操作以更换primary.</p>
<h3 id="7-4-为什么client收到-f-1-​-个一致的结果就认为结果是正确的"><a href="#7-4-为什么client收到-f-1-​-个一致的结果就认为结果是正确的" class="headerlink" title="7.4 为什么client收到 $f+1$​ 个一致的结果就认为结果是正确的?"></a>7.4 为什么client收到 $f+1$​ 个一致的结果就认为结果是正确的?</h3><p>在PBFT协议中最多有$f$个恶意的节点,当client收到$f+1$个相同的执行结果时,说明其中至少包含一个诚实的节点的执行结果. 诚实的节点返回执行结果的前提就是, 分别在prepared和committed-local达成了一致,并且这个一致性是唯一的,这也能说明系统中诚实的节点达成了唯一的一致, 所以client可以相信执行结果.</p>
<h3 id="7-5-backup-验证pre-prepare消息时为什么n的范围需要在-h-H-之间"><a href="#7-5-backup-验证pre-prepare消息时为什么n的范围需要在-h-H-之间" class="headerlink" title="7.5 backup 验证pre-prepare消息时为什么n的范围需要在[h, H]之间"></a>7.5 backup 验证pre-prepare消息时为什么n的范围需要在[h, H]之间</h3><p>为了防止恶意的primary选择一个超级大的序列号n耗尽序列号的空间.不过这个解释不太令人信服,我暂时也不太清楚.</p>
<h3 id="7-6-PBFT协议中的log有什么作用"><a href="#7-6-PBFT协议中的log有什么作用" class="headerlink" title="7.6 PBFT协议中的log有什么作用?"></a>7.6 PBFT协议中的log有什么作用?</h3><ul>
<li><p>log可以记录节点是否执行了某个  request .</p>
</li>
<li><p>另外如果发生$view-change$时可能会从最新的stable checkpoint重新执行  request ,log记录了  request , 方便重新执行.</p>
</li>
<li>其他节点请求stable point时可以直接传输$committed-local$消息方便该节点恢复.</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] M. Fischer, N. Lynch, and M. Paterson. Impossibility of Distributed Consensus With One Faulty Process. Journal of the ACM, 32(2), 1985</p>
<p>[2] G. Bracha and S. Toueg. Asynchronous Consensus and Broadcast Protocols. Journal of the ACM, 32(4), 1995<br>[3] Castro M, Liskov B. Practical Byzantine fault tolerance[J]. operating systems design and implementation, 1999: 173-186.</p>

      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/PBFT/" rel="tag"># PBFT</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/28/%E5%8C%BF%E5%90%8D%E5%B8%81%E5%8C%BF%E5%90%8D%E6%80%A7%E6%AF%94%E8%BE%83/" rel="next" title="匿名币匿名性比较">
                <i class="fa fa-chevron-left"></i> 匿名币匿名性比较
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2023/03/03/hexo%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" rel="prev" title="hexo 常用命令">
                hexo 常用命令 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar1.jpg"
                alt="博主" />
            
              <p class="site-author-name" itemprop="name">博主</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://github.com/hzxGoForward" title="github &rarr; https://github.com/hzxGoForward" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://www.zhihu.com/people/wen-ge-hua-49/activities" title="zhihu &rarr; https://www.zhihu.com/people/wen-ge-hua-49/activities" rel="noopener" target="_blank"><i class="fa fa-fw fa-zhihu"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="/hzx@pku.edu.cn" title="email &rarr; hzx@pku.edu.cn"><i class="fa fa-fw fa-envelope"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://me.csdn.net/t46414704152abc/" title="csdn &rarr; https://me.csdn.net/t46414704152abc/" rel="noopener" target="_blank"><i class="fa fa-fw fa-csdn"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://leetcode.cn/u/hzxforward/" title="leetcode &rarr; https://leetcode.cn/u/hzxforward/" rel="noopener" target="_blank"><i class="fa fa-fw fa-leetcode"></i></a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81-%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B"><span class="nav-text">一、 系统模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81-%E7%B3%BB%E7%BB%9F%E8%A7%92%E8%89%B2"><span class="nav-text">二、 系统角色</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81PBFT%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0"><span class="nav-text">三、PBFT协议简述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PBFT-%E7%BB%86%E8%8A%82"><span class="nav-text">PBFT 细节</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-client-%E5%8F%91%E5%87%BA-request"><span class="nav-text">1. client 发出 request</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-pre-prepare-%E9%98%B6%E6%AE%B5"><span class="nav-text">2. pre-prepare 阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-Primary-%E6%94%B6%E5%88%B0-Request"><span class="nav-text">2.1 Primary 收到 Request</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-Backup-%E6%94%B6%E5%88%B0-pre-prepare%E6%B6%88%E6%81%AF"><span class="nav-text">2.2 Backup 收到 pre-prepare消息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-prepare%E9%98%B6%E6%AE%B5"><span class="nav-text">3. prepare阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-%E5%B9%BF%E6%92%AD-Prepare-%E6%B6%88%E6%81%AF"><span class="nav-text">3.1 广播 Prepare 消息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-pre-prepare-%E5%92%8C-prepare-%E9%98%B6%E6%AE%B5%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-text">3.2 pre-prepare 和 prepare 阶段的作用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-commit%E9%98%B6%E6%AE%B5"><span class="nav-text">4. commit阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-%E5%B9%BF%E6%92%AD-commit-%E6%B6%88%E6%81%AF"><span class="nav-text">4.1 广播 commit 消息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-%E6%89%A7%E8%A1%8C-commit"><span class="nav-text">4.2 执行 commit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-client-%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%9C"><span class="nav-text">4.3 client 验证结果</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Garbage-Collect"><span class="nav-text">5 Garbage Collect</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-View-Change-%E8%A7%86%E5%9B%BE%E5%88%87%E6%8D%A2"><span class="nav-text">6. View Change(视图切换)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-backup%E5%B9%BF%E6%92%AD-View-Change%E6%B6%88%E6%81%AF"><span class="nav-text">6.1 backup广播 View Change消息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-%E6%96%B0primary%E5%B9%BF%E6%92%ADnew-view%E6%B6%88%E6%81%AF"><span class="nav-text">6.2 新primary广播new-view消息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-backup-%E9%AA%8C%E8%AF%81-new-view%E6%B6%88%E6%81%AF"><span class="nav-text">6.3 backup 验证 new-view消息</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-PBFT%E5%8D%8F%E8%AE%AE%E8%AE%A8%E8%AE%BA"><span class="nav-text">7. PBFT协议讨论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%E4%B8%BA%E4%BB%80%E4%B9%88PBFT%E5%8D%8F%E8%AE%AE%E4%B8%AD%E8%8A%82%E7%82%B9%E6%80%BB%E6%95%B0-N-gt-3f-%E2%80%8B-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%90%8E%E4%B8%A4%E4%B8%AA%E9%98%B6%E6%AE%B5%E8%87%B3%E5%B0%91%E9%9C%80%E8%A6%81-2f-1-%E2%80%8B%E7%9A%84%E6%8A%95%E7%A5%A8"><span class="nav-text">7.1 为什么PBFT协议中节点总数$N&gt;3f$​,  为什么后两个阶段至少需要$2f+1$​的投票?</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A5%E4%B8%8B%E8%AF%81%E6%98%8E%E6%9D%A5%E8%87%AA%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3"><span class="nav-text">以下证明来自个人理解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8B%E6%96%87%E6%9D%A5%E8%87%AA-PBFT-%E8%AE%BA%E6%96%87%E8%AF%81%E6%98%8E"><span class="nav-text">下文来自 PBFT 论文证明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-PBFT%E7%9A%84%E4%B8%89%E4%B8%AA%E6%AD%A5%E9%AA%A4%E4%B8%AD%E5%B0%86commit%E6%AD%A5%E9%AA%A4%E5%8E%BB%E6%8E%89%E5%8F%AF%E4%BB%A5%E5%90%97"><span class="nav-text">7.2 PBFT的三个步骤中将commit步骤去掉可以吗?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-%E5%A6%82%E6%9E%9Cclient%E5%9C%A8%E5%8F%91%E5%87%BArequest%E4%B9%8B%E5%90%8E%E5%9C%A8%E4%B8%80%E5%AE%9A%E6%97%B6%E9%97%B4%E5%86%85%E6%B2%A1%E6%9C%89%E6%94%B6%E5%88%B0%E8%B6%B3%E5%A4%9F%E5%A4%9A%E7%9A%84%E5%93%8D%E5%BA%94%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="nav-text">7.3 如果client在发出request之后在一定时间内没有收到足够多的响应怎么办?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-%E4%B8%BA%E4%BB%80%E4%B9%88client%E6%94%B6%E5%88%B0-f-1-%E2%80%8B-%E4%B8%AA%E4%B8%80%E8%87%B4%E7%9A%84%E7%BB%93%E6%9E%9C%E5%B0%B1%E8%AE%A4%E4%B8%BA%E7%BB%93%E6%9E%9C%E6%98%AF%E6%AD%A3%E7%A1%AE%E7%9A%84"><span class="nav-text">7.4 为什么client收到 $f+1$​ 个一致的结果就认为结果是正确的?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-backup-%E9%AA%8C%E8%AF%81pre-prepare%E6%B6%88%E6%81%AF%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88n%E7%9A%84%E8%8C%83%E5%9B%B4%E9%9C%80%E8%A6%81%E5%9C%A8-h-H-%E4%B9%8B%E9%97%B4"><span class="nav-text">7.5 backup 验证pre-prepare消息时为什么n的范围需要在[h, H]之间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-6-PBFT%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84log%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="nav-text">7.6 PBFT协议中的log有什么作用?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="nav-text">参考文献</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

<!--背景音乐-->
<!--iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=86 src="//music.163.com/outchain/player?type=2&id=37856454&auto=1&height=66"></iframe> --> 
<!--<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=556319523&auto=1&height=66"></iframe> -->
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=86 src="//music.163.com/outchain/player?type=2&id=4341314&auto=1&height=66"></iframe>

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

<div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">博主</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v6.3.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.6.0</div>


<div>
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!--注释本行<span id="busuanzi_container_site_pv" style='display:none'>-->
    本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    <span class="post-meta-divider">|</span>
</span>
<span id="busuanzi_container_site_uv" style='display:none'>
    本站访问<span id="busuanzi_value_site_uv"></span>人次
</span>
</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="Total Visitors">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="Total Views">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
      
  
  <script type="text/javascript" color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.6.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.6.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.6.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.6.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  










  





  

  

  

  



  
  

  
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<style>
.MathJax_Display {
    overflow: auto hidden;
}
</style>

    
  


  
  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('Copy').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('Copy')
        }, 300)
      }).append(e)
    })
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->


  

</body>
</html>
