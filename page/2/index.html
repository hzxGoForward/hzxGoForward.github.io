<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.6.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.6.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '6.6.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false,"padding":18},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="HuZhenXing">
<meta property="og:url" content="https://hzxgoforward.github.io/page/2/index.html">
<meta property="og:site_name" content="HuZhenXing">
<meta property="og:locale">
<meta property="article:author" content="hzx">
<meta name="twitter:card" content="summary">






  <link rel="canonical" href="https://hzxgoforward.github.io/page/2/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>HuZhenXing</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">HuZhenXing</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">与其感慨路难行，不如马上出发!</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hzxgoforward.github.io/2019/04/08/New%20Empirical%20Traceability%20Analysis%20of%20CryptoNote-Style%20Blockchains/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuZhenXing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/08/New%20Empirical%20Traceability%20Analysis%20of%20CryptoNote-Style%20Blockchains/" class="post-title-link" itemprop="https://hzxgoforward.github.io/page/2/index.html">New Empirical Traceability Analysis of CryptoNote-Style Blockchains</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建于：2019-04-08 17:00:14" itemprop="dateCreated datePublished" datetime="2019-04-08T17:00:14+08:00">2019-04-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="更新于：2023-03-05 20:02:56" itemprop="dateModified" datetime="2023-03-05T20:02:56+08:00">2023-03-05</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/" itemprop="url" rel="index"><span itemprop="name">区块链技术研究</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          


          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>发表于Financial Cryptography and Data Security 2019的一篇文章。<br>文章链接：<a target="_blank" rel="noopener" href="http://fc19.ifca.ai/preproceedings/69-preproceedings.pdf">http://fc19.ifca.ai/preproceedings/69-preproceedings.pdf</a> </p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>在（PETS’18）会议提出对Monero 不可追踪性的cascade effect 攻击已被开发者使用两个方法规避，其中之一是增加币环形签名(Ring Signature)中mix-ins的个数，从 0.9.0版本中的3个增加到了0.12.0版本中的7个，同时增加了ring confidential transactions(ringCTs)以提升隐私性。然而，目前并没有人对Monero当前应对的策略的匿名性进行分析。 改论文提出一种统计学分析，对所有CryptoNote类型的加密货币进行closed set attack.随后对Monero、Bytecoin以及DigitalNOte进行这种攻击，实验表明，结合了cascade attack之后的closed set attack能够识别出Monero中70.52%的input、Bytecoin中74.25%的inputs以及DigitalNote中91.56%的input。<br>随后对该种攻击成功的概率进行理论分析，发现成功概率为 2^19，closed set attack近似于statiscal attacks，据此，文中分析认为Monero当前的系统设置可以抵御statiscal attacks，另外文章分析说明了mix-ins不是越大越好，而是其中未被花费的input比例越高越好。</p>
<h2 id="Intruductioon"><a href="#Intruductioon" class="headerlink" title="Intruductioon"></a>Intruductioon</h2><p>   目前加密货币中用户的匿名性和隐私性都逐渐受到重视，因此出现了很多致力于保护用户隐私的加密货币，例如Monero、Bytecoin、Dash、DigitalNote、Boolberry等货币，这些货币都使用了CryptoNote 协议。在这些货币中，使用了ring signature(环形签名)技术，即在一笔交易的输入中，支付方会将自己的input地址和区块链中其他output地址混合起来形成一个环，这样做的目的是不让外界知道真正的input具体是哪一个，其他没有被花费的input称之为mix-ins。</p>
<p>   然而实际上Monero区块链中有65%的用户在花销的时候，使用的mix-ins为0，而这些交易很容易被确定真正的input，随后其他一些用户使用了这些被追踪的input作为mix-ins之后也面临着被追踪的危险，也确实有文章进行了相关分析，经过分析后发现其中87%的input都能被追踪到。随后Monero开发团队也对其进行了升级，其中引入了RingCTs技术，RingCTs技术中即使是不同数目的输入也可以作为mix-ins，同时将mix-ins的数量从2提升到了6（2019年3月29日的0.12.0版本）。但是实际上这些货币匿名性如何呢？</p>
<p>   本文中作者引入了closed set attack方式，简而言之就是如果有X个inputs的集合，其中恰好又有X个不同的地址，那么说明在这X个inputs中，不同的X个地址都已经被花销出去，因为每个inputs至少要消费一个地址。假若其他inputs中包含了这X中的地址，那么其他inputs的匿名集就可以减小，如果减小到1，就能够追踪到其中的交易。</p>
<h2 id="Preliminary"><a href="#Preliminary" class="headerlink" title="Preliminary"></a>Preliminary</h2><h3 id="CryptoNote-protocol"><a href="#CryptoNote-protocol" class="headerlink" title="CryptoNote protocol"></a>CryptoNote protocol</h3><p>   CryptoNote协议致力于做两件事情：</p>
<ul>
<li><strong>Untraceability：</strong> 对于任何交易，真正被花费的地址应该是在一系列outputs中匿名的作为inputs</li>
<li><p><strong>Unlinkability：</strong> 对于任意两个交易，不可能证明这两笔交易是发送给同一个用户的。</p>
<p>为了实现unlinkability，CryptoNote中每次转账时使用一个一次性地址，而这个一次性地址来源于接受者的公钥和发送者生成的一个随机数。 为了实现untraceability，CryptoNote中使用了环形签名。</p>
</li>
</ul>
<h2 id="Closed-Set-Attack"><a href="#Closed-Set-Attack" class="headerlink" title="Closed Set Attack"></a>Closed Set Attack</h2><p>   为了说明攻击方法，用txi.in表示每笔交易的输入，假设当前有4笔交易，每笔交易中的inputs分别是：</p>
<ul>
<li>tx1.in = { pk1, pk2, pk3 }</li>
<li>tx2.in = { pk2, pk3 }</li>
<li>tx3.in = { pk1, pk3 }</li>
<li>tx4.in = { pk1, pk2, pk3, pk4 }<br>其中pk表示public key， 即公钥。在tx1、tx2以及tx3中分别用到了pk1、pk2和pk3，而每个tx中都会花费一个pk，因此前3个交易必然是吧pk1、pk2和pk3已经花费掉了，在tx4中，很明显可以推出pk4是真正的花费地址。<br>应用理论分析应该是，在一系列交易中，所有的inputs的数量之和恰好等于这些inputs中不同地址的数目，那么其他应用这些不同地址作为mix-ins的交易，其匿名集中可以除去这些地址以减少其匿名集，如果匿名集和数量为1，那么这笔交易就成为可追踪交易了。</li>
</ul>
<h3 id="Definition-of-Cluster"><a href="#Definition-of-Cluster" class="headerlink" title="Definition of Cluster"></a>Definition of Cluster</h3><p>   那么这种攻击是如何进行的呢？文中定义一个Clus记为一个inputs的集合，Clus = { R1， R2，…, Rn }，每一个Clusetr中所有不同地址的集合，称之为PK_Clus，一个inputs我们使用R代表。假设已经存在一个Clus，那么一个inputs和Clus之间的差集定义为</p>
<ul>
<li>Dist(R, Clus)  = Dist(R, PK_Clus) = |R| - |PK_Clus∩R|<br> 举例说明之，假设Clus = { { pk1, pk2 } ,  { pk1, pk3 }, { pk2, pk4 } }, 那么PK_Clus = { pk1,, pk2, pk3, pk4 }，假设某个R = { pk1, pk3, pk5 },  那么Dist(R, Clus) = 3-2 =1.</li>
</ul>
<h3 id="closed-set-Attack-Algorithm"><a href="#closed-set-Attack-Algorithm" class="headerlink" title="closed set Attack Algorithm"></a>closed set Attack Algorithm</h3><p>   为了进行closed set Attack，文中使用了一种聚类的方法，这种聚类的方法由两个算法构成，其中第二个算法调用了第1个算法。算法首先对所有的inputs应用Cascade-Effect攻击以减少其匿名集，随后对剩余的inputs集合输入到算法2中，Algorithm 2如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: Let DataSet be all transaction inputs in the blockchain.</span><br><span class="line"><span class="number">1.</span> Cascade-<span class="built_in">Effect</span>(Dataset)</span><br><span class="line"><span class="number">2.</span> Flag = <span class="literal">true</span></span><br><span class="line"><span class="number">3.</span> <span class="keyword">while</span> Flag == <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line"><span class="number">4.</span>     Flag = <span class="literal">false</span></span><br><span class="line"><span class="number">5.</span>     <span class="keyword">for</span> each R ∈ DataSet <span class="keyword">do</span></span><br><span class="line"><span class="number">6.</span>     <span class="built_in">Clus_Form</span>(R) -&gt; Clus		<span class="comment">// 调用了Algorithm 1</span></span><br><span class="line"><span class="number">7.</span>     <span class="keyword">if</span> Clus is a closed set then</span><br><span class="line"><span class="number">8.</span>        <span class="built_in">Remove</span>(Clus) -&gt;Flag  <span class="comment">// 删除Dataset中的Clus集合</span></span><br><span class="line"><span class="number">9.</span>        <span class="keyword">if</span> Flag == <span class="literal">true</span> then</span><br><span class="line"><span class="number">10.</span>           find traceable inputs</span><br><span class="line"><span class="number">11.</span>           check whether rings inside Clus are traceable     </span><br></pre></td></tr></table></figure>
<p>Algorithm 1算法如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>  Start with an input R, <span class="keyword">and</span> define the cluster as Clus = &#123; R &#125;</span><br><span class="line"><span class="number">2.</span> Let DataSet be all transaction inputs in the blockchain</span><br><span class="line"><span class="number">3.</span> <span class="keyword">for</span> each <span class="built_in">R1</span>(≠ R) <span class="number">2</span> DataSet <span class="keyword">do</span></span><br><span class="line"><span class="number">4.</span>     <span class="keyword">if</span> <span class="built_in">Dist</span>(R1， Clus) ≤ <span class="number">1</span> then</span><br><span class="line"><span class="number">5.</span>         Clus = Clus ∪ &#123; R1 &#125;</span><br><span class="line"><span class="number">6.</span> <span class="keyword">return</span> Clus </span><br></pre></td></tr></table></figure><br>对于Dataset中的所有inputs，迭代使用Algorithm 2，假设所有inputs个数为N，而每个R的长度为L，那么总的算法复杂度为θ(LN²) 。</p>
<h2 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h2><h3 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h3><p>   本文收集了从Monero区块链创世块(2014年4月18日)到2018年3月30日的区块，总共1541236个区块，工2612070笔非coinbase 交易。</p>
<h3 id="Experiment-Result"><a href="#Experiment-Result" class="headerlink" title="Experiment Result"></a>Experiment Result</h3><p>将本文方法应用于Monero区块链分析，首先应用Cascade effect attack，发现其中16334967笔交易可追踪，而closed set总工追踪到了5752笔交易，因此总共追踪到70.52%的inputs。追踪结果如下表所示。总共找到3017个closed set，大小从2到55不等，总共包含了7478个public_keys，这些public keys已经被花销了，如果其他输入使用这些inputs作为mix-ins，那么是无效的。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>mix-insg个数</th>
<th>inputs数</th>
<th>共可追踪inputs数</th>
<th>Cascade Effect</th>
<th>Closed set</th>
<th>百分比</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>12209675</td>
<td>12209675</td>
<td>12209675</td>
<td>0</td>
<td>100</td>
</tr>
<tr>
<td>1</td>
<td>707786</td>
<td>625641</td>
<td>625264</td>
<td>377</td>
<td>88.39</td>
</tr>
<tr>
<td>2</td>
<td>4496490</td>
<td>1779134</td>
<td>1776192</td>
<td>2942</td>
<td>39.57</td>
</tr>
<tr>
<td>3</td>
<td>1486593</td>
<td>952855</td>
<td>951984</td>
<td>871</td>
<td>64.10</td>
</tr>
<tr>
<td>4</td>
<td>3242625</td>
<td>451959</td>
<td>451230</td>
<td>729</td>
<td>13.94</td>
</tr>
<tr>
<td>5</td>
<td>319352</td>
<td>74186</td>
<td>73980</td>
<td>206</td>
<td>23.23</td>
</tr>
<tr>
<td>6</td>
<td>432875</td>
<td>202360</td>
<td>202100</td>
<td>260</td>
<td>46.75</td>
</tr>
<tr>
<td>7</td>
<td>21528</td>
<td>4296</td>
<td>4282</td>
<td>14</td>
<td>19.96</td>
</tr>
<tr>
<td>8</td>
<td>30067</td>
<td>3506</td>
<td>3490</td>
<td>16</td>
<td>11.66</td>
</tr>
<tr>
<td>9</td>
<td>17724</td>
<td>2178</td>
<td>2162</td>
<td>16</td>
<td>12.29</td>
</tr>
<tr>
<td>Total</td>
<td>≥10</td>
<td>200030</td>
<td>29177</td>
<td>28856</td>
<td>321</td>
<td>14.59</td>
</tr>
</tbody>
</table>
</div>
<p>最后还剩余6829778笔inputs仍然不可追踪，但是这些交易的匿名集已经大大减少，减少情况如下图所示。可以看到，很多之前inputs中地址很多，但是经过closed set分析之后币有多都可以识别，其中inputs你们集合是1的，当下有超过100万，想办法进一步进行分析，或许可以有更多收获。不过作者并没有进一步分析。</p>
<p><img src="https://img-blog.csdnimg.cn/20190408163804418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>此外，作者分别对Bytecoin和DigitalNote进行了同样的分析，分析的结果没有过多需要介绍的，因此这里略过。</p>
<h2 id="Observations-and-Recommendations"><a href="#Observations-and-Recommendations" class="headerlink" title="Observations and Recommendations"></a>Observations and Recommendations</h2><ul>
<li><strong>Obervation 1：</strong> 区块链中outputs的使用率是匿名性中一个非常重要的因素，因为每个outputs毕竟只能被redeem 1次，因此低的使用量能提升匿名性。</li>
<li><strong>Obervation 2：</strong> Closed sets与intpus的匿名性息息相关，找到Closed sets有助于减少匿名集和找到real spent，虽然其数量不多，但是仍然会威胁到匿名集。</li>
<li><strong>Recommendation 1：</strong> 为了减少outputs的使用率，应该增加更多的outputs，建议用户增加一些价值为0 的输出。(PS:输出越多，花费的交易费越多，用户愿意吗？)</li>
<li><strong>Recommendation 2：</strong> 不用使用无效的mix-ins。PS：如果用户知道的话，用户当然不会使用了。</li>
</ul>
<h2 id="Thinking"><a href="#Thinking" class="headerlink" title="Thinking"></a>Thinking</h2><p>这篇文章就提出了1种攻击方式，相比于其他文章来说，在内容和分析展示情况上都显示出比较单一，个人觉得提出的方法很好，但是并没有很好地挖掘这种方法之后的结果，这种方法已经将匿名集降低到1了，此时如果在坚持一下，或者在想想别的分析方法，那么就不是简单的发表在FC上了，可以冲击一下B类会议。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hzxgoforward.github.io/2019/03/28/EOS%E4%B8%ADplugin%E4%B9%8Bnet-plugin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuZhenXing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/28/EOS%E4%B8%ADplugin%E4%B9%8Bnet-plugin/" class="post-title-link" itemprop="https://hzxgoforward.github.io/page/2/index.html">EOS中plugin之net_plugin</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建于：2019-03-28 14:15:24" itemprop="dateCreated datePublished" datetime="2019-03-28T14:15:24+08:00">2019-03-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="更新于：2023-03-05 20:02:39" itemprop="dateModified" datetime="2023-03-05T20:02:39+08:00">2023-03-05</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/" itemprop="url" rel="index"><span itemprop="name">区块链技术研究</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          


          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这部分重点介绍EOS中的服务器端部分nodeos启动之后开启的另外一个重要的插件——net_plugin，这个插件主要负责服务器在网络中的接入、同步区块信息、断开等功能。对于这个插件，首先从其类的定义开始了解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">net_plugin</span> : <span class="keyword">public</span> appbase::plugin&lt;net_plugin&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">net_plugin</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">net_plugin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">APPBASE_PLUGIN_REQUIRES</span>((chain_plugin))    <span class="comment">// net_plugin这个插件的启动，依赖chain_plugin插件</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">set_program_options</span><span class="params">(options_description&amp; cli, options_description&amp; cfg)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">plugin_initialize</span><span class="params">(<span class="type">const</span> variables_map&amp; options)</span></span>;  <span class="comment">// 插件初始化</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">plugin_startup</span><span class="params">()</span></span>;                                 <span class="comment">// 插件的启动</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">plugin_shutdown</span><span class="params">()</span></span>;                                <span class="comment">// 插件关闭</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span>   <span class="title">broadcast_block</span><span class="params">(<span class="type">const</span> chain::signed_block &amp;sb)</span></span>; <span class="comment">// 广播区块</span></span><br><span class="line"></span><br><span class="line">    <span class="function">string                       <span class="title">connect</span><span class="params">( <span class="type">const</span> string&amp; endpoint )</span></span>; <span class="comment">// 连接其他端点</span></span><br><span class="line">    <span class="function">string                       <span class="title">disconnect</span><span class="params">( <span class="type">const</span> string&amp; endpoint )</span></span>; <span class="comment">// 断开连接</span></span><br><span class="line">    <span class="function">optional&lt;connection_status&gt;  <span class="title">status</span><span class="params">( <span class="type">const</span> string&amp; endpoint )</span><span class="type">const</span></span>;   <span class="comment">// 查看与某个端点的链接状态</span></span><br><span class="line">    <span class="function">vector&lt;connection_status&gt;    <span class="title">connections</span><span class="params">()</span><span class="type">const</span></span>;                   <span class="comment">// 查看连接状态</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">num_peers</span><span class="params">()</span> <span class="type">const</span></span>;                                          <span class="comment">// 查看建立连接的端点个数</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;<span class="keyword">class</span> <span class="title class_">net_plugin_impl</span>&gt; my;   <span class="comment">// 和producer_plugin_imple一样，这个插件负责网络中的具体操作</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>net_plugin插件的代码还是比较容易理解的，net_plugin的初始化函数非常简单，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net_plugin::<span class="built_in">net_plugin</span>()</span><br><span class="line">    :<span class="built_in">my</span>( <span class="keyword">new</span> net_plugin_impl ) &#123;</span><br><span class="line">    my_impl = my.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化函数中生成了一阁net_plugin_impl的实例，随后将my的指针赋值给了net_plugin_impl类中的定义的静态指针,这个静态指针的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> net_plugin_impl *my_impl;</span><br></pre></td></tr></table></figure>
<p>再nodeos的main函数中，net_plugin首先会初始化，随后调用其plugin_initialize函数和<a href="https://hzxgoforward.github.io/2019/03/20/EOS%E4%B8%ADplugin%E7%9A%84%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84/">EOS中lugin之producer_plugin</a>的介绍的procuder_plugin类初始化方式时一样的，先寻找这个插件依赖的插件，然后初始化依赖的插件、一些启动参数，设置心跳计时器等。</p>
<p>nodeos中初始化完毕，随后调用net_plugin的plugin_startup函数，该函数代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">net_plugin::plugin_startup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    my-&gt;producer_plug = <span class="built_in">app</span>().<span class="built_in">find_plugin</span>&lt;producer_plugin&gt;();</span><br><span class="line">    <span class="keyword">if</span>( my-&gt;acceptor ) &#123;</span><br><span class="line">        <span class="comment">// 常见的网络服务操作,打开监听服务,设置选项,绑定地址,启动监听</span></span><br><span class="line">        my-&gt;acceptor-&gt;<span class="built_in">open</span>(my-&gt;listen_endpoint.<span class="built_in">protocol</span>());</span><br><span class="line">        my-&gt;acceptor-&gt;<span class="built_in">set_option</span>(tcp::acceptor::<span class="built_in">reuse_address</span>(<span class="literal">true</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// acceptor 来自于boost::asio::ip::tcp，即tcp::acceptor</span></span><br><span class="line">        my-&gt;acceptor-&gt;<span class="built_in">bind</span>(my-&gt;listen_endpoint);</span><br><span class="line">        &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        <span class="built_in">ilog</span>(<span class="string">&quot;net_plugin::plugin_startup failed to bind to port $&#123;port&#125;&quot;</span>,</span><br><span class="line">            (<span class="string">&quot;port&quot;</span>, my-&gt;listen_endpoint.<span class="built_in">port</span>()));</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        my-&gt;acceptor-&gt;<span class="built_in">listen</span>();</span><br><span class="line">        <span class="built_in">ilog</span>(<span class="string">&quot;starting listener, max clients is $&#123;mc&#125;&quot;</span>,(<span class="string">&quot;mc&quot;</span>,my-&gt;max_client_count));</span><br><span class="line">        my-&gt;<span class="built_in">start_listen_loop</span>();   <span class="comment">// 循环监听函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    chain::controller&amp;cc = my-&gt;chain_plug-&gt;<span class="built_in">chain</span>();</span><br><span class="line">    &#123;</span><br><span class="line">        cc.accepted_block.<span class="built_in">connect</span>(  boost::<span class="built_in">bind</span>(&amp;net_plugin_impl::accepted_block, my.<span class="built_in">get</span>(), _1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    my-&gt;incoming_transaction_ack_subscription = <span class="built_in">app</span>().<span class="built_in">get_channel</span>&lt;channels::transaction_ack&gt;().<span class="built_in">subscribe</span>(boost::<span class="built_in">bind</span>(&amp;net_plugin_impl::transaction_ack, my.<span class="built_in">get</span>(), _1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( cc.<span class="built_in">get_read_mode</span>() == chain::db_read_mode::READ_ONLY ) &#123;</span><br><span class="line">        my-&gt;max_nodes_per_host = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">ilog</span>( <span class="string">&quot;node in read-only mode setting max_nodes_per_host to 0 to prevent connections&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动连接和交易到期的监视</span></span><br><span class="line">    my-&gt;<span class="built_in">start_monitors</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">auto</span> seed_node : my-&gt;supplied_peers ) &#123;</span><br><span class="line">        <span class="built_in">connect</span>( seed_node );<span class="comment">// 连接种子节点,接入p2p网络</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fc::<span class="built_in">get_logger_map</span>().<span class="built_in">find</span>(logger_name) != fc::<span class="built_in">get_logger_map</span>().<span class="built_in">end</span>())</span><br><span class="line">        logger = fc::<span class="built_in">get_logger_map</span>()[logger_name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先打开监听的端口号，设置相关协议，随后绑定端口号，然后开始监听网络中的信息，同时让本端点连接到网络中的种子节点，以此连接EOS中的p2p网络。这里面最重要的2个函数是 my-&gt;start_listen_loop()以及my-&gt;start_monitors()函数,my-&gt;start_listen_loop，通过函数名称可以断定主要用来不断地从网络中监听网络中发送的信息，my-&gt;start_monitors()应该是进行监听，但是到底监听什么，我们还不得而知。</p>
<p>这里暂时先不对net_plugin_impl进行具体解析，因为这并不影响我们对这两个函数的分析，另外一方面，net_plugin_impl的介绍对于这两个函数的分析，帮助不大。<br>因此，我们直接进入start_listen_loop函数一探究竟。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 该函数循环监听信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">net_plugin_impl::start_listen_loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> socket = std::<span class="built_in">make_shared</span>&lt;tcp::socket&gt;( std::<span class="built_in">ref</span>( <span class="built_in">app</span>().<span class="built_in">get_io_service</span>() ) );</span><br><span class="line">    acceptor-&gt;<span class="built_in">async_accept</span>( *socket, [socket,<span class="keyword">this</span>]( boost::system::error_code ec ) &#123;</span><br><span class="line">        <span class="keyword">if</span>( !ec ) &#123;</span><br><span class="line">            <span class="type">uint32_t</span> visitors = <span class="number">0</span>;</span><br><span class="line">            <span class="type">uint32_t</span> from_addr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">auto</span> paddr = socket-&gt;<span class="built_in">remote_endpoint</span>(ec).<span class="built_in">address</span>();</span><br><span class="line">            <span class="keyword">if</span> (ec) &#123;</span><br><span class="line">                <span class="built_in">fc_elog</span>(logger,<span class="string">&quot;Error getting remote endpoint: $&#123;m&#125;&quot;</span>,(<span class="string">&quot;m&quot;</span>, ec.<span class="built_in">message</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;conn : connections) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(conn-&gt;socket-&gt;<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (conn-&gt;peer_addr.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                        visitors++;</span><br><span class="line">                        boost::system::error_code ec;</span><br><span class="line">                        <span class="keyword">if</span> (paddr == conn-&gt;socket-&gt;<span class="built_in">remote_endpoint</span>(ec).<span class="built_in">address</span>()) &#123;</span><br><span class="line">                            from_addr++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (num_clients != visitors) &#123;</span><br><span class="line">                    <span class="built_in">ilog</span>(<span class="string">&quot;checking max client, visitors = $&#123;v&#125; num clients $&#123;n&#125;&quot;</span>,(<span class="string">&quot;v&quot;</span>,visitors)(<span class="string">&quot;n&quot;</span>,num_clients));</span><br><span class="line">                    num_clients = visitors;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>( from_addr &lt; max_nodes_per_host &amp;&amp; (max_client_count == <span class="number">0</span> || num_clients &lt; max_client_count )) &#123;</span><br><span class="line">                    ++num_clients;</span><br><span class="line">                    connection_ptr c = std::<span class="built_in">make_shared</span>&lt;connection&gt;( socket );</span><br><span class="line">                    connections.<span class="built_in">insert</span>( c );</span><br><span class="line">                    <span class="built_in">start_session</span>( c );</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (from_addr &gt;= max_nodes_per_host) &#123;</span><br><span class="line">                    <span class="built_in">fc_elog</span>(logger, <span class="string">&quot;Number of connections ($&#123;n&#125;) from $&#123;ra&#125; exceeds limit&quot;</span>,</span><br><span class="line">                            (<span class="string">&quot;n&quot;</span>, from_addr+<span class="number">1</span>)(<span class="string">&quot;ra&quot;</span>,paddr.<span class="built_in">to_string</span>()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">fc_elog</span>(logger, <span class="string">&quot;Error max_client_count $&#123;m&#125; exceeded&quot;</span>,</span><br><span class="line">                            ( <span class="string">&quot;m&quot;</span>, max_client_count) );</span><br><span class="line">                    &#125;</span><br><span class="line">                    socket-&gt;<span class="built_in">close</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">elog</span>( <span class="string">&quot;Error accepting connection: $&#123;m&#125;&quot;</span>,( <span class="string">&quot;m&quot;</span>, ec.<span class="built_in">message</span>() ) );</span><br><span class="line">            <span class="comment">// For the listed error codes below, recall start_listen_loop()</span></span><br><span class="line">            <span class="keyword">switch</span> (ec.<span class="built_in">value</span>()) &#123;</span><br><span class="line">                <span class="keyword">case</span> ECONNABORTED:</span><br><span class="line">                <span class="keyword">case</span> EMFILE:</span><br><span class="line">                <span class="keyword">case</span> ENFILE:</span><br><span class="line">                <span class="keyword">case</span> ENOBUFS:</span><br><span class="line">                <span class="keyword">case</span> ENOMEM:</span><br><span class="line">                <span class="keyword">case</span> EPROTO:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">start_listen_loop</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>start_listen_loop()函数中最重要的一个函数是，监听到消息之后的start_session()函数，表示监听到了新的链接，于是开始会话。start_session()函数内容如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">net_plugin_impl::start_session</span><span class="params">(<span class="type">const</span> connection_ptr&amp; con)</span> </span>&#123;</span><br><span class="line">    boost::asio::ip::<span class="function">tcp::no_delay <span class="title">nodelay</span><span class="params">( <span class="literal">true</span> )</span></span>;</span><br><span class="line">    boost::system::error_code ec;</span><br><span class="line">    con-&gt;socket-&gt;<span class="built_in">set_option</span>( nodelay, ec );</span><br><span class="line">    <span class="keyword">if</span> (ec) &#123;</span><br><span class="line">        <span class="comment">// 如果接受数据出错， 直接关闭连接，写日志</span></span><br><span class="line">        <span class="built_in">elog</span>( <span class="string">&quot;connection failed to $&#123;peer&#125;: $&#123;error&#125;&quot;</span>,</span><br><span class="line">            ( <span class="string">&quot;peer&quot;</span>, con-&gt;<span class="built_in">peer_name</span>())(<span class="string">&quot;error&quot;</span>,ec.<span class="built_in">message</span>()));</span><br><span class="line">        con-&gt;connecting = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">close</span>(con);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 读取数据，已经开启的session+1</span></span><br><span class="line">        <span class="built_in">start_read_message</span>( con );</span><br><span class="line">        ++started_sessions;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// for now, we can just use the application main loop.</span></span><br><span class="line">        <span class="comment">//     con-&gt;readloop_complete  = bf::async( [=]()&#123; read_loop( con ); &#125; );</span></span><br><span class="line">        <span class="comment">//     con-&gt;writeloop_complete = bf::async( [=]()&#123; write_loop con ); &#125; );</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中重要的是start_read_message，即回话过程中读取数据，即start_read_message()函数，其具体内容如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">net_plugin_impl::start_read_message</span><span class="params">(<span class="type">const</span> connection_ptr&amp; conn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!conn-&gt;socket) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        connection_wptr weak_conn = conn;</span><br><span class="line"></span><br><span class="line">        std::<span class="type">size_t</span> minimum_read = conn-&gt;outstanding_read_bytes ? *conn-&gt;outstanding_read_bytes : message_header_size;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认为false，在plugin_initialized中使用</span></span><br><span class="line">        <span class="keyword">if</span> (use_socket_read_watermark) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">size_t</span> max_socket_read_watermark = <span class="number">4096</span>;</span><br><span class="line">        std::<span class="type">size_t</span> socket_read_watermark = std::<span class="built_in">min</span>&lt;std::<span class="type">size_t</span>&gt;(minimum_read, max_socket_read_watermark);</span><br><span class="line">        boost::asio::<span class="function">socket_base::receive_low_watermark <span class="title">read_watermark_opt</span><span class="params">(socket_read_watermark)</span></span>;</span><br><span class="line">        conn-&gt;socket-&gt;<span class="built_in">set_option</span>(read_watermark_opt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> completion_handler = [minimum_read](boost::system::error_code ec, std::<span class="type">size_t</span> bytes_transferred) -&gt; std::<span class="type">size_t</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ec || bytes_transferred &gt;= minimum_read ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> minimum_read - bytes_transferred;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从stream中异步读取固定大小的数据</span></span><br><span class="line">        <span class="comment">/* async_read(AsyncReadStream &amp;S, const MutableBufferSequence&amp; buffers, ReadHandler&amp;&amp; handler, )</span></span><br><span class="line"><span class="comment">        从*conn-&gt;socket中读取data，读到buffers中去，buffers的大小告诉系统读取多少</span></span><br><span class="line"><span class="comment">        handler是读取数据完毕之后调用的函数 */</span></span><br><span class="line">        boost::asio::<span class="built_in">async_read</span>(*conn-&gt;socket,</span><br><span class="line">        conn-&gt;pending_message_buffer.<span class="built_in">get_buffer_sequence_for_boost_async_read</span>(), </span><br><span class="line">        completion_handler,</span><br><span class="line">        [<span class="keyword">this</span>,weak_conn]( boost::system::error_code ec, std::<span class="type">size_t</span> bytes_transferred ) &#123;</span><br><span class="line">            <span class="keyword">auto</span> conn = weak_conn.<span class="built_in">lock</span>();</span><br><span class="line">            <span class="keyword">if</span> (!conn) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            conn-&gt;outstanding_read_bytes.<span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>( !ec ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (bytes_transferred &gt; conn-&gt;pending_message_buffer.<span class="built_in">bytes_to_write</span>()) &#123;</span><br><span class="line">                    <span class="built_in">elog</span>(<span class="string">&quot;async_read_some callback: bytes_transfered = $&#123;bt&#125;, buffer.bytes_to_write = $&#123;btw&#125;&quot;</span>,</span><br><span class="line">                            (<span class="string">&quot;bt&quot;</span>,bytes_transferred)(<span class="string">&quot;btw&quot;</span>,conn-&gt;pending_message_buffer.<span class="built_in">bytes_to_write</span>()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">EOS_ASSERT</span>(bytes_transferred &lt;= conn-&gt;pending_message_buffer.<span class="built_in">bytes_to_write</span>(), plugin_exception, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                    conn-&gt;pending_message_buffer.<span class="built_in">advance_write_ptr</span>(bytes_transferred);</span><br><span class="line">                    <span class="keyword">while</span> (conn-&gt;pending_message_buffer.<span class="built_in">bytes_to_read</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">uint32_t</span> bytes_in_buffer = conn-&gt;pending_message_buffer.<span class="built_in">bytes_to_read</span>();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (bytes_in_buffer &lt; message_header_size) &#123;</span><br><span class="line">                        conn-&gt;outstanding_read_bytes.<span class="built_in">emplace</span>(message_header_size - bytes_in_buffer);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="type">uint32_t</span> message_length;</span><br><span class="line">                        <span class="keyword">auto</span> index = conn-&gt;pending_message_buffer.<span class="built_in">read_index</span>();</span><br><span class="line">                        conn-&gt;pending_message_buffer.<span class="built_in">peek</span>(&amp;message_length, <span class="built_in">sizeof</span>(message_length), index);</span><br><span class="line">                        <span class="keyword">if</span>(message_length &gt; def_send_buffer_size*<span class="number">2</span> || message_length == <span class="number">0</span>) &#123;</span><br><span class="line">                            boost::system::error_code ec;</span><br><span class="line">                            <span class="built_in">elog</span>(<span class="string">&quot;incoming message length unexpected ($&#123;i&#125;), from $&#123;p&#125;&quot;</span>,</span><br><span class="line">                                (<span class="string">&quot;i&quot;</span>, message_length)(<span class="string">&quot;p&quot;</span>,boost::<span class="built_in">lexical_cast</span>&lt;std::string&gt;(conn-&gt;socket-&gt;<span class="built_in">remote_endpoint</span>(ec))));</span><br><span class="line">                            <span class="built_in">close</span>(conn);</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">auto</span> total_message_bytes = message_length + message_header_size;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (bytes_in_buffer &gt;= total_message_bytes) &#123;</span><br><span class="line">                            conn-&gt;pending_message_buffer.<span class="built_in">advance_read_ptr</span>(message_header_size);</span><br><span class="line">                            <span class="comment">// 这一部分是网络通信的内容，对于其中细节不甚了解</span></span><br><span class="line">                            <span class="comment">// 接收的数据传递到pending_message_buffer中，</span></span><br><span class="line">                            <span class="comment">// process_next_message中进行处理从pending_message_buffer中处理数据</span></span><br><span class="line">                            <span class="keyword">if</span> (!conn-&gt;<span class="built_in">process_next_message</span>(*<span class="keyword">this</span>, message_length)) &#123;</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">auto</span> outstanding_message_bytes = total_message_bytes - bytes_in_buffer;</span><br><span class="line">                            <span class="keyword">auto</span> available_buffer_bytes = conn-&gt;pending_message_buffer.<span class="built_in">bytes_to_write</span>();</span><br><span class="line">                            <span class="keyword">if</span> (outstanding_message_bytes &gt; available_buffer_bytes) &#123;</span><br><span class="line">                                conn-&gt;pending_message_buffer.<span class="built_in">add_space</span>( outstanding_message_bytes - available_buffer_bytes );</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            conn-&gt;outstanding_read_bytes.<span class="built_in">emplace</span>(outstanding_message_bytes);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">start_read_message</span>(conn);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">auto</span> pname = conn-&gt;<span class="built_in">peer_name</span>();</span><br><span class="line">                    <span class="keyword">if</span> (ec.<span class="built_in">value</span>() != boost::asio::error::eof) &#123;</span><br><span class="line">                    <span class="built_in">elog</span>( <span class="string">&quot;Error reading message from $&#123;p&#125;: $&#123;m&#125;&quot;</span>,(<span class="string">&quot;p&quot;</span>,pname)( <span class="string">&quot;m&quot;</span>, ec.<span class="built_in">message</span>() ) );</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">ilog</span>( <span class="string">&quot;Peer $&#123;p&#125; closed connection&quot;</span>,(<span class="string">&quot;p&quot;</span>,pname) );</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">close</span>( conn );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">catch</span>(<span class="type">const</span> std::exception &amp;ex) &#123;</span><br><span class="line">                string pname = conn ? conn-&gt;<span class="built_in">peer_name</span>() : <span class="string">&quot;no connection name&quot;</span>;</span><br><span class="line">                <span class="built_in">elog</span>(<span class="string">&quot;Exception in handling read data from $&#123;p&#125; $&#123;s&#125;&quot;</span>,(<span class="string">&quot;p&quot;</span>,pname)(<span class="string">&quot;s&quot;</span>,ex.<span class="built_in">what</span>()));</span><br><span class="line">                <span class="built_in">close</span>( conn );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">catch</span>(<span class="type">const</span> fc::exception &amp;ex) &#123;</span><br><span class="line">                string pname = conn ? conn-&gt;<span class="built_in">peer_name</span>() : <span class="string">&quot;no connection name&quot;</span>;</span><br><span class="line">                <span class="built_in">elog</span>(<span class="string">&quot;Exception in handling read data $&#123;s&#125;&quot;</span>, (<span class="string">&quot;p&quot;</span>,pname)(<span class="string">&quot;s&quot;</span>,ex.<span class="built_in">to_string</span>()));</span><br><span class="line">                <span class="built_in">close</span>( conn );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">                string pname = conn ? conn-&gt;<span class="built_in">peer_name</span>() : <span class="string">&quot;no connection name&quot;</span>;</span><br><span class="line">                <span class="built_in">elog</span>( <span class="string">&quot;Undefined exception hanlding the read data from connection $&#123;p&#125;&quot;</span>,( <span class="string">&quot;p&quot;</span>,pname));</span><br><span class="line">                <span class="built_in">close</span>( conn );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; );</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        string pname = conn ? conn-&gt;<span class="built_in">peer_name</span>() : <span class="string">&quot;no connection name&quot;</span>;</span><br><span class="line">        <span class="built_in">elog</span>( <span class="string">&quot;Undefined exception handling reading $&#123;p&#125;&quot;</span>,(<span class="string">&quot;p&quot;</span>,pname) );</span><br><span class="line">        <span class="built_in">close</span>( conn );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抛去其中try catch语句，我们重点看到conn-&gt;process_next_message函数，这个函数正如注释所说，从接受到的pending_message_buffer中处理数据，我们继续追踪这个处理函数，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该函数用于数据同步,使用中心消息处理系统处理数据</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">connection::process_next_message</span><span class="params">(net_plugin_impl&amp; impl, <span class="type">uint32_t</span> message_length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> ds = pending_message_buffer.<span class="built_in">create_datastream</span>();</span><br><span class="line">        net_message msg;</span><br><span class="line">        fc::raw::<span class="built_in">unpack</span>(ds, msg);  <span class="comment">// 将解压的ds信息放入msg中</span></span><br><span class="line">        <span class="function">msg_handler <span class="title">m</span><span class="params">(impl, shared_from_this() )</span></span>;</span><br><span class="line">        <span class="comment">// 判断msg的类型，msg可以是带签名的区块或者打包后的交易</span></span><br><span class="line">        <span class="comment">// 如果是区块，获取signed_block后放入m中</span></span><br><span class="line">        <span class="comment">// 如果是trx，则获取packed_trx后放入m中</span></span><br><span class="line">        <span class="keyword">if</span>( msg.<span class="built_in">contains</span>&lt;signed_block&gt;() ) &#123;</span><br><span class="line">        <span class="built_in">m</span>( std::<span class="built_in">move</span>( msg.<span class="built_in">get</span>&lt;signed_block&gt;() ) );</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>( msg.<span class="built_in">contains</span>&lt;packed_transaction&gt;() ) &#123;</span><br><span class="line">        <span class="built_in">m</span>( std::<span class="built_in">move</span>( msg.<span class="built_in">get</span>&lt;packed_transaction&gt;() ) );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        msg.<span class="built_in">visit</span>( m );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span>(  <span class="type">const</span> fc::exception&amp; e ) &#123;</span><br><span class="line">        <span class="built_in">edump</span>((e.<span class="built_in">to_detail_string</span>() ));</span><br><span class="line">        impl.<span class="built_in">close</span>( <span class="built_in">shared_from_this</span>() );</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中重要的是msg_handler类型，这里面分别针对消息不同的类型做不同的处理，首先查看针对如果msg中包含了signed_block，则进入处理block函数；如果msg中包含packed_transaction，则进入处理trx的函数。首先查看msg_handler是如何处理signed_block的，处理区块的函数如下。收到区块之后验证区块，验证通过则接受区块，验证失败则拒绝区块。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果从网络中收到一个区块，执行相应的处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">net_plugin_impl::handle_message</span><span class="params">(<span class="type">const</span> connection_ptr&amp; c, <span class="type">const</span> signed_block_ptr&amp; msg)</span> </span>&#123;</span><br><span class="line">   controller &amp;cc = chain_plug-&gt;<span class="built_in">chain</span>();</span><br><span class="line">   block_id_type blk_id = msg-&gt;<span class="built_in">id</span>();</span><br><span class="line">   <span class="type">uint32_t</span> blk_num = msg-&gt;<span class="built_in">block_num</span>();</span><br><span class="line">   <span class="built_in">fc_dlog</span>(logger, <span class="string">&quot;canceling wait on $&#123;p&#125;&quot;</span>, (<span class="string">&quot;p&quot;</span>,c-&gt;<span class="built_in">peer_name</span>()));</span><br><span class="line">   c-&gt;<span class="built_in">cancel_wait</span>();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>( cc.<span class="built_in">fetch_block_by_id</span>(blk_id)) &#123;</span><br><span class="line">         <span class="comment">// recv_block函数具体含义为止，同步区块数据？不应该是检查在先？</span></span><br><span class="line">         sync_master-&gt;<span class="built_in">recv_block</span>(c, blk_id, blk_num);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="built_in">catch</span>( ...) &#123;</span><br><span class="line">      <span class="comment">// should this even be caught?</span></span><br><span class="line">      <span class="built_in">elog</span>(<span class="string">&quot;Caught an unknown exception trying to recall blockID&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   dispatcher-&gt;<span class="built_in">recv_block</span>(c, blk_id, blk_num);  <span class="comment">// 进行报告，我已经从连接c收到一个编号blk_id和blk_num的区块？</span></span><br><span class="line">   <span class="function">fc::microseconds <span class="title">age</span><span class="params">( fc::time_point::now() - msg-&gt;timestamp)</span></span>;</span><br><span class="line">   <span class="built_in">peer_ilog</span>(c, <span class="string">&quot;received signed_block : #$&#123;n&#125; block age in secs = $&#123;age&#125;&quot;</span>,</span><br><span class="line">           (<span class="string">&quot;n&quot;</span>,blk_num)(<span class="string">&quot;age&quot;</span>,age.<span class="built_in">to_seconds</span>()));</span><br><span class="line"></span><br><span class="line">   go_away_reason reason = fatal_other;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 在chain_plug中再检查其具体含义，看catch中的内容，应该是使用chain_plug对区块进行检查</span></span><br><span class="line">      <span class="comment">// 如果检查无错误，reason的值应该是no_reason</span></span><br><span class="line">      chain_plug-&gt;<span class="built_in">accept_block</span>(msg); <span class="comment">//, sync_master-&gt;is_active(c));</span></span><br><span class="line">      reason = no_reason;</span><br><span class="line">   &#125; <span class="built_in">catch</span>( <span class="type">const</span> unlinkable_block_exception &amp;ex) &#123;</span><br><span class="line">      <span class="built_in">peer_elog</span>(c, <span class="string">&quot;bad signed_block : $&#123;m&#125;&quot;</span>, (<span class="string">&quot;m&quot;</span>,ex.<span class="built_in">what</span>()));</span><br><span class="line">      reason = unlinkable;</span><br><span class="line">   &#125; <span class="built_in">catch</span>( <span class="type">const</span> block_validate_exception &amp;ex) &#123;</span><br><span class="line">      <span class="built_in">peer_elog</span>(c, <span class="string">&quot;bad signed_block : $&#123;m&#125;&quot;</span>, (<span class="string">&quot;m&quot;</span>,ex.<span class="built_in">what</span>()));</span><br><span class="line">      <span class="built_in">elog</span>( <span class="string">&quot;block_validate_exception accept block #$&#123;n&#125; syncing from $&#123;p&#125;&quot;</span>,(<span class="string">&quot;n&quot;</span>,blk_num)(<span class="string">&quot;p&quot;</span>,c-&gt;<span class="built_in">peer_name</span>()));</span><br><span class="line">      reason = validation;</span><br><span class="line">   &#125; <span class="built_in">catch</span>( <span class="type">const</span> assert_exception &amp;ex) &#123;</span><br><span class="line">      <span class="built_in">peer_elog</span>(c, <span class="string">&quot;bad signed_block : $&#123;m&#125;&quot;</span>, (<span class="string">&quot;m&quot;</span>,ex.<span class="built_in">what</span>()));</span><br><span class="line">      <span class="built_in">elog</span>( <span class="string">&quot;unable to accept block on assert exception $&#123;n&#125; from $&#123;p&#125;&quot;</span>,(<span class="string">&quot;n&quot;</span>,ex.<span class="built_in">to_string</span>())(<span class="string">&quot;p&quot;</span>,c-&gt;<span class="built_in">peer_name</span>()));</span><br><span class="line">   &#125; <span class="built_in">catch</span>( <span class="type">const</span> fc::exception &amp;ex) &#123;</span><br><span class="line">      <span class="built_in">peer_elog</span>(c, <span class="string">&quot;bad signed_block : $&#123;m&#125;&quot;</span>, (<span class="string">&quot;m&quot;</span>,ex.<span class="built_in">what</span>()));</span><br><span class="line">      <span class="built_in">elog</span>( <span class="string">&quot;accept_block threw a non-assert exception $&#123;x&#125; from $&#123;p&#125;&quot;</span>,( <span class="string">&quot;x&quot;</span>,ex.<span class="built_in">to_string</span>())(<span class="string">&quot;p&quot;</span>,c-&gt;<span class="built_in">peer_name</span>()));</span><br><span class="line">      reason = no_reason;</span><br><span class="line">   &#125; <span class="built_in">catch</span>( ...) &#123;</span><br><span class="line">      <span class="built_in">peer_elog</span>(c, <span class="string">&quot;bad signed_block : unknown exception&quot;</span>);</span><br><span class="line">      <span class="built_in">elog</span>( <span class="string">&quot;handle sync block caught something else from $&#123;p&#125;&quot;</span>,(<span class="string">&quot;num&quot;</span>,blk_num)(<span class="string">&quot;p&quot;</span>,c-&gt;<span class="built_in">peer_name</span>()));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function">update_block_num <span class="title">ubn</span><span class="params">(blk_num)</span></span>;</span><br><span class="line">   <span class="keyword">if</span>( reason == no_reason ) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;recpt : msg-&gt;transactions) &#123;</span><br><span class="line">         <span class="keyword">auto</span> id = (recpt.trx.<span class="built_in">which</span>() == <span class="number">0</span>) ? recpt.trx.<span class="built_in">get</span>&lt;transaction_id_type&gt;() : recpt.trx.<span class="built_in">get</span>&lt;packed_transaction&gt;().<span class="built_in">id</span>();</span><br><span class="line">         <span class="keyword">auto</span> ltx = local_txns.<span class="built_in">get</span>&lt;by_id&gt;().<span class="built_in">find</span>(id);</span><br><span class="line">         <span class="keyword">if</span>( ltx != local_txns.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            local_txns.<span class="built_in">modify</span>( ltx, ubn );</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">auto</span> ctx = c-&gt;trx_state.<span class="built_in">get</span>&lt;by_id&gt;().<span class="built_in">find</span>(id);</span><br><span class="line">         <span class="keyword">if</span>( ctx != c-&gt;trx_state.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            c-&gt;trx_state.<span class="built_in">modify</span>( ctx, ubn );</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 这里再次进行recv_block，不明白其含义</span></span><br><span class="line">      sync_master-&gt;<span class="built_in">recv_block</span>(c, blk_id, blk_num);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 验证区块过程中出现错误，直接拒绝这个区块</span></span><br><span class="line">      sync_master-&gt;<span class="built_in">rejected_block</span>(c, blk_num);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对交易的验证与对区块的处理方式相同，验证交易，如果本地存在此交易，则丢弃，否则开始验证交易，若验证通过则接受交易并广播交易，否则拒绝交易。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">net_plugin_impl::handle_message</span><span class="params">(<span class="type">const</span> connection_ptr&amp; c, <span class="type">const</span> packed_transaction_ptr&amp; trx)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fc_dlog</span>(logger, <span class="string">&quot;got a packed transaction, cancel wait&quot;</span>);</span><br><span class="line">    <span class="built_in">peer_ilog</span>(c, <span class="string">&quot;received packed_transaction&quot;</span>);</span><br><span class="line">    controller&amp; cc = my_impl-&gt;chain_plug-&gt;<span class="built_in">chain</span>();</span><br><span class="line">    <span class="keyword">if</span>( cc.<span class="built_in">get_read_mode</span>() == eosio::db_read_mode::READ_ONLY ) &#123;</span><br><span class="line">        <span class="built_in">fc_dlog</span>(logger, <span class="string">&quot;got a txn in read-only mode - dropping&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( sync_master-&gt;<span class="built_in">is_active</span>(c) ) &#123;</span><br><span class="line">        <span class="built_in">fc_dlog</span>(logger, <span class="string">&quot;got a txn during sync - dropping&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ptrx = std::<span class="built_in">make_shared</span>&lt;transaction_metadata&gt;( trx );</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; tid = ptrx-&gt;id;</span><br><span class="line"></span><br><span class="line">    c-&gt;<span class="built_in">cancel_wait</span>();</span><br><span class="line">    <span class="keyword">if</span>(local_txns.<span class="built_in">get</span>&lt;by_id&gt;().<span class="built_in">find</span>(tid) != local_txns.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="built_in">fc_dlog</span>(logger, <span class="string">&quot;got a duplicate transaction - dropping&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dispatcher-&gt;<span class="built_in">recv_transaction</span>(c, tid);</span><br><span class="line">    <span class="comment">// 验证交易</span></span><br><span class="line">    chain_plug-&gt;<span class="built_in">accept_transaction</span>(ptrx, [c, <span class="keyword">this</span>, ptrx](<span class="type">const</span> static_variant&lt;fc::exception_ptr, transaction_trace_ptr&gt;&amp; result) &#123;</span><br><span class="line">        <span class="keyword">if</span> (result.<span class="built_in">contains</span>&lt;fc::exception_ptr&gt;()) &#123;</span><br><span class="line">        <span class="built_in">peer_dlog</span>(c, <span class="string">&quot;bad packed_transaction : $&#123;m&#125;&quot;</span>, (<span class="string">&quot;m&quot;</span>,result.<span class="built_in">get</span>&lt;fc::exception_ptr&gt;()-&gt;<span class="built_in">what</span>()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> trace = result.<span class="built_in">get</span>&lt;transaction_trace_ptr&gt;();</span><br><span class="line">        <span class="keyword">if</span> (!trace-&gt;except) &#123;</span><br><span class="line">            <span class="built_in">fc_dlog</span>(logger, <span class="string">&quot;chain accepted transaction&quot;</span>);</span><br><span class="line">            <span class="comment">// 广播交易</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;dispatcher-&gt;<span class="built_in">bcast_transaction</span>(ptrx);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">peer_elog</span>(c, <span class="string">&quot;bad packed_transaction : $&#123;m&#125;&quot;</span>, (<span class="string">&quot;m&quot;</span>,trace-&gt;except-&gt;<span class="built_in">what</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 拒绝交易</span></span><br><span class="line">        dispatcher-&gt;<span class="built_in">rejected_transaction</span>(ptrx-&gt;id);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>至此，net_plugin以及net_plugin_impl插件中的比较重要的函数已经分析完毕，由于其中细节错综复杂，因此在分析过程中抓住主要脉络进行分析，对于其他细节内容并没有深究。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hzxgoforward.github.io/2019/03/20/EOS%E4%B8%ADplugin%E4%B9%8Bproducer_plugin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuZhenXing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/20/EOS%E4%B8%ADplugin%E4%B9%8Bproducer_plugin/" class="post-title-link" itemprop="https://hzxgoforward.github.io/page/2/index.html">EOS中plugin之producer_plugin</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建于：2019-03-20 18:29:54" itemprop="dateCreated datePublished" datetime="2019-03-20T18:29:54+08:00">2019-03-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="更新于：2023-03-05 20:03:09" itemprop="dateModified" datetime="2023-03-05T20:03:09+08:00">2023-03-05</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/" itemprop="url" rel="index"><span itemprop="name">区块链技术研究</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          


          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="EOS中plugin之producer-plugin"><a href="#EOS中plugin之producer-plugin" class="headerlink" title="EOS中plugin之producer_plugin"></a>EOS中plugin之producer_plugin</h1><p>EOS中的插件是非常重要的工具，其中大大小小总共有26个插件，其中比较重要的插件有chain_plugin、producer_plugin、http_plugin、net_plugin等四个插件。这四个插件在EOS服务器端启动后也开始启动进行工作。</p>
<h2 id="abstract-plugin"><a href="#abstract-plugin" class="headerlink" title="abstract_plugin"></a>abstract_plugin</h2><p>EOS中所有插件继承于plugin类，而plugin类又继承于abstract_plugin类。<br>abstract_plugin中规定了每个插件的4个状态，这4个状态依次如下。</p>
<ul>
<li>registered，表示插件已经注册， 每个插件初始化后就是注册的状态。</li>
<li>initialized，表示插件已经初始化，插件之后注册之后才能初始化。</li>
<li>started， 表示插件正在运行中。</li>
<li>stopped，表示插件停止运行。</li>
</ul>
<p>下面是abstract_plugin的源代码，由于是个抽象类，abstract_plugin定义在appbase\appbase\plugin.hpp中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">abstract_plugin</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 插件的4个状态。</span></span><br><span class="line">        <span class="keyword">enum</span> <span class="title class_">state</span> &#123;</span><br><span class="line">        registered, <span class="comment">///&lt; the plugin is constructed but doesn&#x27;t do anything</span></span><br><span class="line">        initialized, <span class="comment">///&lt; the plugin has initialized any state required but is idle</span></span><br><span class="line">        started, <span class="comment">///&lt; the plugin is actively running</span></span><br><span class="line">        stopped <span class="comment">///&lt; the plugin is no longer running</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">abstract_plugin</span>()&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> state <span class="title">get_state</span><span class="params">()</span><span class="type">const</span> </span>= <span class="number">0</span>; <span class="comment">// 查询插件当前的状态</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> std::string&amp; <span class="title">name</span><span class="params">()</span><span class="type">const</span>  </span>= <span class="number">0</span>;    <span class="comment">// 获取插件名称</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">set_program_options</span><span class="params">( options_description&amp; cli, options_description&amp; cfg )</span> </span>= <span class="number">0</span>;                 <span class="comment">// 设置插件参数</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">initialize</span><span class="params">(<span class="type">const</span> variables_map&amp; options)</span> </span>= <span class="number">0</span>;<span class="comment">//初始化插件</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handle_sighup</span><span class="params">()</span> </span>= <span class="number">0</span>;               <span class="comment">// 这个干嘛用的不清楚</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">startup</span><span class="params">()</span> </span>= <span class="number">0</span>;                     <span class="comment">// 启动插件</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>= <span class="number">0</span>;                    <span class="comment">// 关闭插件</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><p>plugin这个类继承了abstract_plugin，plugin的代码在appbase\apppbase\apllication.hpp中，这里比较奇怪的是，为什么plugin的定义不再plugin.hpp文件中，而plugin.hpp中定义了abstract_plugin类。</p>
<p>plugin是一个模板类，在plugin中，除去handle_sighup函数之外，已经实现了abstract_plugin中的全部纯虚函数。handle_sighup函数的含义，目前我不太清楚。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Impl&gt;</span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">plugin</span> : <span class="keyword">public</span> abstract_plugin &#123;</span><br><span class="line">      <span class="keyword">public</span>:</span><br><span class="line">         <span class="built_in">plugin</span>():_name(boost::core::<span class="built_in">demangle</span>(<span class="built_in">typeid</span>(Impl).<span class="built_in">name</span>()))&#123;&#125;</span><br><span class="line">         <span class="keyword">virtual</span> ~<span class="built_in">plugin</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">virtual</span> state <span class="title">get_state</span><span class="params">()</span><span class="type">const</span> <span class="keyword">override</span>         </span>&#123; <span class="keyword">return</span> _state; &#125;</span><br><span class="line">         <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> std::string&amp; <span class="title">name</span><span class="params">()</span><span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> _name; &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">register_dependencies</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">static_cast</span>&lt;Impl*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">plugin_requires</span>([&amp;](<span class="keyword">auto</span>&amp; plug)&#123;&#125;);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">initialize</span><span class="params">(<span class="type">const</span> variables_map&amp; options)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(_state == registered) &#123;</span><br><span class="line">               _state = initialized;</span><br><span class="line">               <span class="built_in">static_cast</span>&lt;Impl*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">plugin_requires</span>([&amp;](<span class="keyword">auto</span>&amp; plug)&#123; plug.<span class="built_in">initialize</span>(options); &#125;);</span><br><span class="line">               <span class="built_in">static_cast</span>&lt;Impl*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">plugin_initialize</span>(options);</span><br><span class="line">               <span class="comment">//ilog( &quot;initializing plugin $&#123;name&#125;&quot;, (&quot;name&quot;,name()) );</span></span><br><span class="line">               <span class="built_in">app</span>().<span class="built_in">plugin_initialized</span>(*<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">assert</span>(_state == initialized); <span class="comment">/// if initial state was not registered, final state cannot be initialized</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handle_sighup</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 插件启动函数</span></span><br><span class="line">         <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">startup</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(_state == initialized) &#123;</span><br><span class="line">               _state = started;</span><br><span class="line">               <span class="built_in">static_cast</span>&lt;Impl*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">plugin_requires</span>([&amp;](<span class="keyword">auto</span>&amp; plug)&#123; plug.<span class="built_in">startup</span>(); &#125;);</span><br><span class="line">               <span class="built_in">static_cast</span>&lt;Impl*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">plugin_startup</span>();</span><br><span class="line">               <span class="built_in">app</span>().<span class="built_in">plugin_started</span>(*<span class="keyword">this</span>);     <span class="comment">// </span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">assert</span>(_state == started); <span class="comment">// if initial state was not initialized, final state cannot be started</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">shutdown</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(_state == started) &#123;</span><br><span class="line">               _state = stopped;</span><br><span class="line">               <span class="comment">//ilog( &quot;shutting down plugin $&#123;name&#125;&quot;, (&quot;name&quot;,name()) );</span></span><br><span class="line">               <span class="built_in">static_cast</span>&lt;Impl*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">plugin_shutdown</span>();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">protected</span>:</span><br><span class="line">         <span class="built_in">plugin</span>(<span class="type">const</span> string&amp; name) : _name(name)&#123;&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span>:</span><br><span class="line">         state _state = abstract_plugin::registered;</span><br><span class="line">         std::string _name;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
<p>首先可以看到plugin的初始化函数，由于plugin是一个模板类，在初始化过程中，传入的模板类的名称赋值给了plugin的protected变量_name，里面唯一不太理解的是，为什么这个_name是protected的类型而不是private类型。typeid在头文件typeindex中，主要是获得某个类的名称。</p>
<p>此外，plugin中实现了插件的startup()、initialized()和shutdown()三个功能。在initialize()函数中，首先判断当前状态是否是registered状态，随后更改状态为initialized状态，然后查询当前插件依赖的其他插件并且将其他插件初始化，随后初始化插件自身。注意到插件启动完成后有如下一句代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">app</span>().<span class="built_in">plugin_initialized</span>(*<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>app()函数返回客户端的引用，随后客户端将当前初始化的插件变量放入到当前客户端中已初始化插件的vector中。</p>
<p>在startup()之前，可以看到，插件启动之前，其状态必须是已经初始化的状态，这表明插件启动之前必须初始化。随后设置状态为启动状态。然后查询当前插件启动需要的其他插件并启动这些插件，随后再启动插件自身，随后客户端将当前已启动的插件变量放入到当前客户端中已启动插件的vector中。</p>
<p>在shutdown()函数中，特别厉害的一个设计就是关闭插件的调用，因为不同的插件，可能关闭方式不一样，但是在plugin中仍然也实现了这个方法，实在是太巧妙了。最精髓的就是这句代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_cast</span>&lt;Impl*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">plugin_shutdown</span>();</span><br></pre></td></tr></table></figure><br>将当前指针转换成模板类初始化时传进的类，然后调用这个类的plugin_shutdown()函数。好像很牛批，可是我仔细一想，最后不还是调用每个类自己的plugin_shutdown()函数了吗，每个类中自己实现这个功能好像也可以，这样设计就是看起来很牛批，但是没什么卵用，奇技淫巧而已~</p>
<p>现在介绍下EOS具体的插件，producer_plugin，这个插件主要负责超级节点的区块生产、同步以及新区快的校验工作，是4个插件里面最重要的一个插件。</p>
<h2 id="producer-plugin"><a href="#producer-plugin" class="headerlink" title="producer_plugin"></a>producer_plugin</h2><h3 id="（1）-producer-plugin-hpp"><a href="#（1）-producer-plugin-hpp" class="headerlink" title="（1）. producer_plugin.hpp"></a>（1）. producer_plugin.hpp</h3><p>producer_plugin插件的实现位于plugins\producer_plugin下。producer_plugin类的定义，就很头铁，定义方式如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">producer_plugin</span> : <span class="keyword">public</span> appbase::plugin&lt;producer_plugin&gt;&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在定义的过程中就传入了producer_plugin的类名，这个名称会传给plugin中的_name变量。<br>为什么会有appbase这个玩意儿呢，因为这是一个命名空间，plugin就定义在appbase命名空间中。</p>
<p>接下来我们看看producer_plugin的头文件，由于头文件比较长，口味略重，非战斗人员请迅速撤离。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">producer_plugin</span> : <span class="keyword">public</span> appbase::plugin&lt;producer_plugin&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">APPBASE_PLUGIN_REQUIRES</span>((chain_plugin)(http_client_plugin))</span><br><span class="line"></span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">runtime_options</span> &#123;</span><br><span class="line">      fc::optional&lt;<span class="type">int32_t</span>&gt; max_transaction_time;</span><br><span class="line">      fc::optional&lt;<span class="type">int32_t</span>&gt; max_irreversible_block_age;</span><br><span class="line">      fc::optional&lt;<span class="type">int32_t</span>&gt; produce_time_offset_us;</span><br><span class="line">      fc::optional&lt;<span class="type">int32_t</span>&gt; last_block_time_offset_us;</span><br><span class="line">      fc::optional&lt;<span class="type">int32_t</span>&gt; max_scheduled_transaction_time_per_block_ms;</span><br><span class="line">      fc::optional&lt;<span class="type">int32_t</span>&gt; subjective_cpu_leeway_us;</span><br><span class="line">      fc::optional&lt;<span class="type">double</span>&gt;  incoming_defer_ratio;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">whitelist_blacklist</span> &#123;</span><br><span class="line">      fc::optional&lt; flat_set&lt;account_name&gt; &gt; actor_whitelist;</span><br><span class="line">      fc::optional&lt; flat_set&lt;account_name&gt; &gt; actor_blacklist;</span><br><span class="line">      fc::optional&lt; flat_set&lt;account_name&gt; &gt; contract_whitelist;</span><br><span class="line">      fc::optional&lt; flat_set&lt;account_name&gt; &gt; contract_blacklist;</span><br><span class="line">      fc::optional&lt; flat_set&lt; std::pair&lt;account_name, action_name&gt; &gt; &gt; action_blacklist;</span><br><span class="line">      fc::optional&lt; flat_set&lt;public_key_type&gt; &gt; key_blacklist;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">greylist_params</span> &#123;</span><br><span class="line">      std::vector&lt;account_name&gt; accounts;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">integrity_hash_information</span> &#123;</span><br><span class="line">      chain::block_id_type head_block_id;</span><br><span class="line">      chain::digest_type   integrity_hash;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">snapshot_information</span> &#123;</span><br><span class="line">      chain::block_id_type head_block_id;</span><br><span class="line">      std::string          snapshot_name;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">producer_plugin</span>();</span><br><span class="line">   <span class="keyword">virtual</span> ~<span class="built_in">producer_plugin</span>();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">set_program_options</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      boost::program_options::options_description &amp;command_line_options,</span></span></span><br><span class="line"><span class="params"><span class="function">      boost::program_options::options_description &amp;config_file_options</span></span></span><br><span class="line"><span class="params"><span class="function">      )</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 判断一个公钥是否是当前区块生产者的公钥</span></span><br><span class="line">   <span class="function"><span class="type">bool</span>                   <span class="title">is_producer_key</span><span class="params">(<span class="type">const</span> chain::public_key_type&amp; key)</span> <span class="type">const</span></span>; </span><br><span class="line">   <span class="comment">// 应该是对摘要进行签名，这里面的key应该是私钥。        </span></span><br><span class="line">   <span class="function">chain::signature_type  <span class="title">sign_compact</span><span class="params">(<span class="type">const</span> chain::public_key_type&amp; key, <span class="type">const</span> fc::sha256&amp; digest)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 对插件进行初始化</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">plugin_initialize</span><span class="params">(<span class="type">const</span> boost::program_options::variables_map&amp; options)</span></span>;</span><br><span class="line">   <span class="comment">// 插件启动函数</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">plugin_startup</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="comment">// 插件关闭函数</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">plugin_shutdown</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="comment">// 暂停运行和继续运行</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">pause</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="comment">// 返回插件是否被暂停的状态</span></span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">paused</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 更新运行的相关参数</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">update_runtime_options</span><span class="params">(<span class="type">const</span> runtime_options&amp; options)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取运行时的相关参数</span></span><br><span class="line">   <span class="function">runtime_options <span class="title">get_runtime_options</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 增加grey_list</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">add_greylist_accounts</span><span class="params">(<span class="type">const</span> greylist_params&amp; params)</span></span>;</span><br><span class="line">   <span class="comment">// 删除grey_list</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">remove_greylist_accounts</span><span class="params">(<span class="type">const</span> greylist_params&amp; params)</span></span>;</span><br><span class="line">   <span class="comment">// 获取greylist</span></span><br><span class="line">   <span class="function">greylist_params <span class="title">get_greylist</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取whitelist和设置whitelist</span></span><br><span class="line">   <span class="function">whitelist_blacklist <span class="title">get_whitelist_blacklist</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">set_whitelist_blacklist</span><span class="params">(<span class="type">const</span> whitelist_blacklist&amp; params)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取integrity_hash_information</span></span><br><span class="line">   <span class="function">integrity_hash_information <span class="title">get_integrity_hash</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 创建一个快照，snapshot中文意思是快照</span></span><br><span class="line">   <span class="function">snapshot_information <span class="title">create_snapshot</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 定义一个返回值为空，传入变量为const chain::producer_confirmation&amp;的signal</span></span><br><span class="line">   <span class="comment">// 这个信号用于区块的确认。</span></span><br><span class="line">   signal&lt;<span class="built_in">void</span>(<span class="type">const</span> chain::producer_confirmation&amp;)&gt; confirmed_block;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// producer_plugin_impl的指针,负责所有任务的执行</span></span><br><span class="line">    <span class="comment">// producer_plugin_impl类的定义在producer_plugin.cpp中</span></span><br><span class="line">   std::shared_ptr&lt;<span class="keyword">class</span> <span class="title class_">producer_plugin_impl</span>&gt; my; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>producer_plugin定义完毕之后第一个public函数就很恶心咯，这是什么鬼!!!仔细看看这些大写字母的定义，转换成小写字母，即appbase_plugin_requires,还记得前面说每个插件初始化或者启动的时候都要初始化或者启动它依赖的插件这个过程吗？这感觉应该是说producer_plugin类启动的时候依赖chain_plugin和http_client_plugin两个插件。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">APPBASE_PLUGIN_REQUIRES</span>((chain_plugin)(http_client_plugin))</span><br></pre></td></tr></table></figure></p>
<p>大写的显示，应该是说明这一个宏定义，果然，我们翻了一下，宏定义在plugin.hpp文件中，具体定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> APPBASE_PLUGIN_REQUIRES( PLUGINS )                               \</span></span><br><span class="line"><span class="meta">   template<span class="string">&lt;typename Lambda&gt;</span>                                           \</span></span><br><span class="line"><span class="meta">   void plugin_requires( Lambda&amp;&amp; l ) &#123;                                \</span></span><br><span class="line"><span class="meta">      BOOST_PP_SEQ_FOR_EACH( APPBASE_PLUGIN_REQUIRES_VISIT, l, PLUGINS ) \</span></span><br><span class="line"><span class="meta">   &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APPBASE_PLUGIN_REQUIRES_VISIT( r, visitor, elem ) \</span></span><br><span class="line"><span class="meta">  visitor( appbase::app().register_plugin<span class="string">&lt;elem&gt;</span>() ) </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>哇~~~，越来越恶心了,这个宏定义，指向一个模板函数，这个模板函数的参数是一个函数，里面用到了BOOST_PP_SEQ_FOR_EACH，这个一般如下用法：</p>
<ul>
<li>BOOST_PP_SEQ_FOR_EACH(macro, r, data)</li>
<li>macro，一个以格式macro(r, data, elem)定义的三元宏。该宏被BOOST_PP_SEQ_FOR_EACH按照seq中每个元素进行展开。展开该宏，需要用到下一个BOOST_PP_FOR的重复项、备用数据data和当前元素。</li>
<li>data，备用数据，用于传给macro。</li>
<li>seq，用于供macro按照哪个序列进行展开。</li>
</ul>
<p>具体的细节尚未弄清楚，但是明确的是，这个hpp文件可以看出producer_plugin插件依赖两个插件，即chain_plugin和http_client_plugin。</p>
<p>随后再producer_plugin中定义了一系列结构体。这些结构体都用到了一个optional的类。简单地来说，这个类类似于boost::optional的概念，主要用于实现未初始化的概念。函数并不能总是返回有意义的结果，有时候函数可能返回“无意义”的值，一般来说我们通常使用一个不再正常解空间的一个哨兵来表示无意义的概念，如NULL，-1，end()或者EOF.然后对于不同的应用场合，这些哨兵并不是通用的，而且有时候可能不存在这种解空间之外的哨兵。optional很像一个仅能存放一个元素的容器，它实现了”未初始化”的概念：如果元素未初始化，那么容器就是空的，否则，容器内就是有效的，已经初始化的值。optional的真实接口很复杂，因为它要能包装任何的类型。</p>
<p>定义的这些结构体，我想应该是producer_plugin运行时配置的一些参数，大致知道这个概念即可。随后是producer_plugin的构造函数、析构函数以及设置参数的函数。更加详细的内容，我已经写在注释中，可以参看，至于producer_plugin中一些方法的具体实现，暂时不予理会，知道其作用就可以了。</p>
<h3 id="（2）-plugin-startup"><a href="#（2）-plugin-startup" class="headerlink" title="（2）. plugin_startup"></a>（2）. plugin_startup</h3><p>producer_plugin.cpp中插件的plugin_shutdown, pause, resume等函数不是很重要，因此这里不再介绍。但是中最重要的一个函数是plugin_startup函数，nodeos节点启动之后，启动producer_plugin插件的接口就是这个函数，这里需对这个函数进行详细的解析，但是我们仍然会跳过一些细枝末节的东西，重点看其主要脉络。由于源码中这个函数内容比较多，这里不再展示源码，直接从主要流程开始。</p>
<p>在函数里面首先获取一个变量：chain<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chain::controller &amp;chain = my-&gt;chain-&gt;chain_plug-&gt;<span class="built_in">chain</span>()</span><br></pre></td></tr></table></figure><br>my是一个produer_plugin_impl类的智能指针，这个指针具体负责交易的打包、区块的生产和检查等工作。通过chain可以访问到区块链上的一些信息。</p>
<p>随后chain连接两个信号量，分别执行的函数是on_block()和on_irreversible_block。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my-&gt;_accepted_block_connection.<span class="built_in">emplace</span>(chain.accepted_block.<span class="built_in">connect</span>([<span class="keyword">this</span>](<span class="type">const</span> <span class="keyword">auto</span> &amp;bsp) &#123; my-&gt;<span class="built_in">on_block</span>(bsp); &#125;));</span><br><span class="line">      my-&gt;_irreversible_block_connection.<span class="built_in">emplace</span>(chain.irreversible_block.<span class="built_in">connect</span>([<span class="keyword">this</span>](<span class="type">const</span> <span class="keyword">auto</span> &amp;bsp) &#123; my-&gt;<span class="built_in">on_irreversible_block</span>(bsp-&gt;block); &#125;));</span><br></pre></td></tr></table></figure><br>在boost中，进行connect之后返回一个connection的对象，my将返回的两个对象放入自己的connection容器中。</p>
<p>随后获得了区块链上最近的一个不可逆区块的块号和其指针<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span> lib_num = chain.<span class="built_in">last_irreversible_block_num</span>();<span class="comment">// 返回块号</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> lib = chain.<span class="built_in">fetch_block_by_number</span>(lib_num); <span class="comment">// 返回指针</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>如果当前区块指针不为空，则进入my-&gt;on_irreversible_block(lib)函数。my-&gt;on_irreversible_block函数就是将不可逆区块的时间设置为lib指向的区块的时间。<br>如果lib指针为空，设置不可逆区块的时间为当前时间的最大值，即设置为0xffffffff秒，时间大致为139年，那时候BM应该早就跪了~</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lib)&#123;</span><br><span class="line">   my-&gt;<span class="built_in">on_irreversible_block</span>(lib);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="comment">// maximum 大致是136年</span></span><br><span class="line">   my-&gt;_irreversible_block_time = fc::time_point::<span class="built_in">maximum</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，判断my中的区块生产者列表是否为空，若当前节点可以生产区块，如果是第一次接入的超节点，则展示new_chain_banner标志。随后开始进入区块生产的大循环中，区块生产的函是由my控制的。看起来my这个插件无法避免的需要介绍了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (my-&gt;_production_enabled)&#123;</span><br><span class="line">   <span class="keyword">if</span> (chain.<span class="built_in">head_block_num</span>() == <span class="number">0</span>)</span><br><span class="line">   &#123; <span class="comment">// 如果是创世块，展示新区块的标语</span></span><br><span class="line">      <span class="built_in">new_chain_banner</span>(chain);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//_production_skip_flags |= eosio::chain::skip_undo_history_check;</span></span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">// 开始进入区块生产循环中,持续不断的开始生产区块</span></span><br><span class="line">   my-&gt;<span class="built_in">schedule_production_loop</span>();</span><br></pre></td></tr></table></figure><br>至此，plugin_startup函数的主要情况已经介绍完毕，my-&gt;schedule_produetion_loop函数的介绍，将在produer_plugin_impl类的介绍中进行。</p>
<h2 id="producer-plugin-impl"><a href="#producer-plugin-impl" class="headerlink" title="producer_plugin_impl"></a>producer_plugin_impl</h2><h3 id="producer-plugin-impl类中的变量"><a href="#producer-plugin-impl类中的变量" class="headerlink" title="producer_plugin_impl类中的变量"></a>producer_plugin_impl类中的变量</h3><p>produer_plugin_impl类的定义，上来我就懵逼了，这是什么！！！enable_shared_from_this也是一个类，但是这种继承的形式到底是怎么肥四？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">producer_plugin_impl</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;producer_plugin_impl&gt;</span><br></pre></td></tr></table></figure>
<p>查了一下网上的解释，enable_shared_from_this是c++ 11的新特性，使用这个特性就可以获得一个对象的多个shared_ptr指针，但是又不会造成对象的多次释放问题。具体的解释可以参看下面两个链接：</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/712279/what-is-the-usefulness-of-enable-shared-from-this">stack overflow</a></p>
<p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/memory/enable_shared_from_this">cpp reference</a></p>
<p>其初始化函数只有1个，里面_timer完成io操作，_transaction_ack_channel主要接收交易，具体形式如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">producer_plugin_impl</span>(boost::asio::io_service &amp;io)</span><br><span class="line">      : _timer(io), _transaction_ack_channel(<span class="built_in">app</span>().<span class="built_in">get_channel</span>&lt;compat::channels::transaction_ack&gt;())&#123;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>老实说，produer_plugin_impl中定义的变量很多，这些变量都是public属性。因为这个类具体负责区块生产，因此涉及到的事务非常繁杂，所以变量比较多也算正常。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">optional&lt;fc::time_point&gt; <span class="title">calculate_next_block_time</span><span class="params">(<span class="type">const</span> account_name &amp;producer_name, <span class="type">const</span> block_timestamp_type &amp;current_block_time)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">schedule_production_loop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">produce_block</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">maybe_produce_block</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">boost::program_options::variables_map _options;  <span class="comment">// 程序启动的一些选项</span></span><br><span class="line"><span class="type">bool</span> _production_enabled = <span class="literal">false</span>;   <span class="comment">//能够生产区块</span></span><br><span class="line"><span class="type">bool</span> _pause_production = <span class="literal">false</span>;     <span class="comment">// 是否暂停生产</span></span><br><span class="line"><span class="type">uint32_t</span> _production_skip_flags = <span class="number">0</span>; <span class="comment">//eosio::chain::skip_nothing;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是啥玩意，我不明白</span></span><br><span class="line"><span class="keyword">using</span> signature_provider_type = std::function&lt;chain::<span class="built_in">signature_type</span>(chain::digest_type)&gt;; </span><br><span class="line"><span class="comment">// 映射公钥和签名</span></span><br><span class="line">std::map&lt;chain::public_key_type, signature_provider_type&gt; _signature_providers;</span><br><span class="line">std::set&lt;chain::account_name&gt; _producers; <span class="comment">// BP名单</span></span><br><span class="line">boost::asio::deadline_timer _timer;       <span class="comment">// 负责io的_timer</span></span><br><span class="line">std::map&lt;chain::account_name, <span class="type">uint32_t</span>&gt; _producer_watermarks;  <span class="comment">// BP的水印</span></span><br><span class="line">pending_block_mode _pending_block_mode;                        <span class="comment">// 添加区块的模式，producing和speculate两个模式</span></span><br><span class="line">transaction_id_with_expiry_index _persistent_transactions;     <span class="comment">// 过期的交易</span></span><br><span class="line">fc::optional&lt;boost::asio::thread_pool&gt; _thread_pool;           <span class="comment">// 线程池</span></span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> _max_transaction_time_ms;                              <span class="comment">// 交易的延迟时间</span></span><br><span class="line">fc::microseconds _max_irreversible_block_age_us;</span><br><span class="line"><span class="comment">// 非最后一个区块产生时间的偏移量，按微秒计算。负值会导致块更早出去，正值会导致块更晚出去。</span></span><br><span class="line"><span class="type">int32_t</span> _produce_time_offset_us = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 最后一个区块产生时间的偏移量，按微秒计算。负值会导致块更早出去，正值会导致块更晚出去。</span></span><br><span class="line"><span class="type">int32_t</span> _last_block_time_offset_us = <span class="number">0</span>;</span><br><span class="line"><span class="type">int32_t</span> _max_scheduled_transaction_time_per_block_ms;          <span class="comment">// 一个区块全部交易打包完毕的最大时间耗费</span></span><br><span class="line"></span><br><span class="line">fc::time_point _irreversible_block_time;                       <span class="comment">// 不可逆区块的时间</span></span><br><span class="line">fc::microseconds _keosd_provider_timeout_us;                   <span class="comment">// 钱包客户端超时时间 us为单位</span></span><br><span class="line"></span><br><span class="line">time_point _last_signed_block_time;                            <span class="comment">// 最近一个签名区块的时间</span></span><br><span class="line">time_point _start_time = fc::time_point::<span class="built_in">now</span>();                <span class="comment">// 启动时间，当前时间</span></span><br><span class="line"><span class="type">uint32_t</span> _last_signed_block_num = <span class="number">0</span>;                           <span class="comment">// 最近一个签名区块的块号</span></span><br><span class="line"></span><br><span class="line">producer_plugin *_self = <span class="literal">nullptr</span>;                              <span class="comment">// 指向producer_plugin的指针</span></span><br><span class="line">chain_plugin *chain_plug = <span class="literal">nullptr</span>;                            <span class="comment">// 指向chain_plugin的指针</span></span><br><span class="line"></span><br><span class="line">incoming::channels::block::channel_type::handle _incoming_block_subscription; <span class="comment">// 订阅收到的区块？</span></span><br><span class="line">incoming::channels::transaction::channel_type::handle _incoming_transaction_subscription; <span class="comment">// 订阅收到交易？</span></span><br><span class="line"></span><br><span class="line">compat::channels::transaction_ack::channel_type &amp;_transaction_ack_channel;    <span class="comment">// 接收交易的通道</span></span><br><span class="line"></span><br><span class="line">incoming::methods::block_sync::method_type::handle _incoming_block_sync_provider;   <span class="comment">// 同步区块的数据提供方</span></span><br><span class="line">incoming::methods::transaction_async::method_type::handle _incoming_transaction_async_provider; <span class="comment">// 同步交易的数据提供方</span></span><br><span class="line"></span><br><span class="line">transaction_id_with_expiry_index _blacklisted_transactions;       <span class="comment">// 超时交易的id</span></span><br><span class="line"></span><br><span class="line">fc::optional&lt;scoped_connection&gt; _accepted_block_connection;       <span class="comment">// 存储已经接收区块的connection</span></span><br><span class="line">fc::optional&lt;scoped_connection&gt; _irreversible_block_connection;   <span class="comment">// 存储不可逆区块的connection</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      * HACK ALERT</span></span><br><span class="line"><span class="comment">      * Boost timers can be in a state where a handler has not yet executed but is not abortable.</span></span><br><span class="line"><span class="comment">      * As this method needs to mutate state handlers depend on for proper functioning to maintain</span></span><br><span class="line"><span class="comment">      * invariants for other code (namely accepting incoming transactions in a nearly full block)</span></span><br><span class="line"><span class="comment">      * the handlers capture a corelation ID at the time they are set.  When they are executed</span></span><br><span class="line"><span class="comment">      * they must check that correlation_id against the global ordinal.  If it does not match that</span></span><br><span class="line"><span class="comment">      * implies that this method has been called with the handler in the state where it should be</span></span><br><span class="line"><span class="comment">      * cancelled but wasn&#x27;t able to be.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"><span class="type">uint32_t</span> _timer_corelation_id = <span class="number">0</span>;                        </span><br><span class="line"></span><br><span class="line"><span class="comment">// keep a expected ratio between defer txn and incoming txn</span></span><br><span class="line"><span class="type">double</span> _incoming_trx_weight = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">double</span> _incoming_defer_ratio = <span class="number">1.0</span>; <span class="comment">// 1:1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// path to write the snapshots to</span></span><br><span class="line">bfs::path _snapshots_dir;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可能会奇怪，为什么my指针中的变量，在其初始化函数中都没有看到初始化的工作，例如其中的chain_plugin和producer_plugin指针。实际上，my中这些变量的初始化工作已经在producer_plugin的initialized函数中初始化完毕了。</p>
<h3 id="schedule-production-loop-函数"><a href="#schedule-production-loop-函数" class="headerlink" title="schedule_production_loop 函数"></a>schedule_production_loop 函数</h3><p>producer_plugin的startup函数中就是调用了producer_plugin_impl中的shcedule_production_loop函数开始生产区块。因此，我们首先从这个函数入手，开始分析producer_plugin_impl是如何生产区块的。</p>
<p>函数首先获得了chain的引用和指向producer_plugin_impl的一个weak_ptr指针，关闭了_timer的io操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chain::controller &amp;chain = chain_plug-&gt;<span class="built_in">chain</span>();</span><br><span class="line">_timer.<span class="built_in">cancel</span>(); <span class="comment">// _timer 是boost库中asio的一个定时器,关闭所有异步等待</span></span><br><span class="line">std::weak_ptr&lt;producer_plugin_impl&gt; weak_this = <span class="built_in">shared_from_this</span>();</span><br><span class="line"><span class="keyword">auto</span> result = <span class="built_in">start_block</span>()</span><br></pre></td></tr></table></figure>
<p>随后尝试生产区块，调用了start_block函数，start_block函数返回结果有succeed,failed,waiting,exhausted4种，针对4中情况分别执行不用的流程。</p>
<ol>
<li><p>failed， 获取各种调度信息异常，则重新获取数据进行调度；</p>
</li>
<li><p>waitting，其它节点正在出块，则进行等待；</p>
</li>
<li><p>producing，轮到本节点出块，则进行出块操作；</p>
</li>
<li><p>succeed，生产区块成功，计算下一个生产者出块的时间。</p>
</li>
</ol>
<p>当start_block()返回结果为failed的时，进入异步等待状态，稍后再尝试生产区块。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (result == start_block_result::failed)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">elog</span>(<span class="string">&quot;Failed to start a pending block, will try again later&quot;</span>);</span><br><span class="line">  </span><br><span class="line">   _timer.<span class="built_in">expires_from_now</span>(boost::posix_time::<span class="built_in">microseconds</span>(config::block_interval_us / <span class="number">10</span>)); <span class="comment">// 0.05秒后定时器失效</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 稍后继续尝试schedule_production_loop()函数</span></span><br><span class="line">   _timer.<span class="built_in">async_wait</span>([weak_this, cid = ++_timer_corelation_id](<span class="type">const</span> boost::system::error_code &amp;ec) &#123;</span><br><span class="line">      <span class="comment">// 获得this的shared_ptr指针以判断是否被销毁，销毁返回空的shared_ptr</span></span><br><span class="line">      <span class="keyword">auto</span> self = weak_this.<span class="built_in">lock</span>();</span><br><span class="line">      <span class="keyword">if</span> (self &amp;&amp; ec != boost::asio::error::operation_aborted &amp;&amp; cid == self-&gt;_timer_corelation_id)</span><br><span class="line">      &#123;</span><br><span class="line">         self-&gt;<span class="built_in">schedule_production_loop</span>();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 如果返回结果是waiting，表示本地的区块链还在从eos网络中下载区块已进行信息同步过程中，这个过程中还无法生产区块。随后查看当前是否还能继续生产区块，如果可以，则待会儿生产区块，即调用函数schedule_delayed_production_loop，这个函数这里不再进行仔细分析，主要就是过一段时间后这个函数中还会调用schedule_production_loop函数进行区块生产。<br> 返回结果时waiting的情况下，对应代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (result == start_block_result::waiting)</span><br><span class="line">&#123; <span class="comment">// 当前还在同步区块信息,等待中...</span></span><br><span class="line">    <span class="comment">// waiting的状态有两种情况,要么生产区块的BP名单为空,或者是生产区块受外部命令而停止</span></span><br><span class="line">   <span class="keyword">if</span> (!_producers.<span class="built_in">empty</span>() &amp;&amp; !<span class="built_in">production_disabled_by_policy</span>())</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">fc_dlog</span>(_log, <span class="string">&quot;Waiting till another block is received and scheduling Speculative/Production Change&quot;</span>);</span><br><span class="line">      <span class="comment">// 过会儿再进行区块生产</span></span><br><span class="line">      <span class="built_in">schedule_delayed_production_loop</span>(weak_this, <span class="built_in">calculate_pending_block_time</span>());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">fc_dlog</span>(_log, <span class="string">&quot;Waiting till another block is received&quot;</span>);</span><br><span class="line">      <span class="comment">// 其他区块还没有同步完毕,因此急需等待同步完成才能生产区块</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果返回结果是speculateing模式，并且还可以继续进行区块生产，但是生产者不确定这个区块是否合法，所以小心翼翼的过一会儿继续生产区块，过程如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_pending_block_mode == pending_block_mode::speculating &amp;&amp; !_producers.<span class="built_in">empty</span>() &amp;&amp; !<span class="built_in">production_disabled_by_policy</span>())</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">fc_dlog</span>(_log, <span class="string">&quot;Specualtive Block Created; Scheduling Speculative/Production Change&quot;</span>);</span><br><span class="line">   <span class="built_in">EOS_ASSERT</span>(chain.<span class="built_in">pending_block_state</span>(), missing_pending_block_state, <span class="string">&quot;speculating without pending_block_state&quot;</span>);</span><br><span class="line">   <span class="type">const</span> <span class="keyword">auto</span> &amp;pbs = chain.<span class="built_in">pending_block_state</span>();</span><br><span class="line">   <span class="built_in">schedule_delayed_production_loop</span>(weak_this, pbs-&gt;header.timestamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果返回结果是producing模式，表示已经成功的生产了一个区块，但是还需要其他一些验证工作。这里有个问题就是，为什么speculating模式下没有验证，非得在producing模式下验证生产的区块呢？</p>
<p>首先验证区块截止时间是否大于当前时间，如果大于当前时间，表明生产区块成功在截止日期内，是合法的区块，然后记录日志。如果截止日期超过现在，表明生产的区块已经过期了，此时将生产区块的时间减小0.5s，看是否超时并记录日志，这一步完成之后进行区块的同步操作。<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_pending_block_mode == pending_block_mode::producing)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 成功打包了一个区块,但是得看看打包的区块是否超时</span></span><br><span class="line">   <span class="type">static</span> <span class="type">const</span> boost::posix_time::ptime <span class="built_in">epoch</span>(boost::gregorian::<span class="built_in">date</span>(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">   <span class="comment">// pending_block_time 返回最后一个区块的时间戳(是刚刚生产的区块的时间戳还是之前有效区块的时间戳,暂时还不清楚)</span></span><br><span class="line">   <span class="keyword">auto</span> deadline = <span class="built_in">calculate_block_deadline</span>(chain.<span class="built_in">pending_block_time</span>());</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (deadline &gt; fc::time_point::<span class="built_in">now</span>())</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">// ship this block off no later than its deadline</span></span><br><span class="line">      <span class="built_in">EOS_ASSERT</span>(chain.<span class="built_in">pending_block_state</span>(), missing_pending_block_state, <span class="string">&quot;producing without pending_block_state, start_block succeeded&quot;</span>);</span><br><span class="line">      _timer.<span class="built_in">expires_at</span>(epoch + boost::posix_time::<span class="built_in">microseconds</span>(deadline.<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>()));</span><br><span class="line">      <span class="built_in">fc_dlog</span>(_log, <span class="string">&quot;Scheduling Block Production on Normal Block #$&#123;num&#125; for $&#123;time&#125;&quot;</span>, (<span class="string">&quot;num&quot;</span>, chain.<span class="built_in">pending_block_state</span>()-&gt;block_num)(<span class="string">&quot;time&quot;</span>, deadline));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">EOS_ASSERT</span>(chain.<span class="built_in">pending_block_state</span>(), missing_pending_block_state, <span class="string">&quot;producing without pending_block_state&quot;</span>);</span><br><span class="line">      <span class="keyword">auto</span> expect_time = chain.<span class="built_in">pending_block_time</span>() - fc::<span class="built_in">microseconds</span>(config::block_interval_us);</span><br><span class="line">      <span class="comment">// ship this block off up to 1 block time earlier or immediately</span></span><br><span class="line">      <span class="keyword">if</span> (fc::time_point::<span class="built_in">now</span>() &gt;= expect_time)</span><br><span class="line">      &#123;</span><br><span class="line">         _timer.<span class="built_in">expires_from_now</span>(boost::posix_time::<span class="built_in">microseconds</span>(<span class="number">0</span>));</span><br><span class="line">         <span class="built_in">fc_dlog</span>(_log, <span class="string">&quot;Scheduling Block Production on Exhausted Block #$&#123;num&#125; immediately&quot;</span>, (<span class="string">&quot;num&quot;</span>, chain.<span class="built_in">pending_block_state</span>()-&gt;block_num));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">         _timer.<span class="built_in">expires_at</span>(epoch + boost::posix_time::<span class="built_in">microseconds</span>(expect_time.<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>()));</span><br><span class="line">         <span class="built_in">fc_dlog</span>(_log, <span class="string">&quot;Scheduling Block Production on Exhausted Block #$&#123;num&#125; at $&#123;time&#125;&quot;</span>, (<span class="string">&quot;num&quot;</span>, chain.<span class="built_in">pending_block_state</span>()-&gt;block_num)(<span class="string">&quot;time&quot;</span>, expect_time));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   _timer.<span class="built_in">async_wait</span>([&amp;chain, weak_this, cid = ++_timer_corelation_id](<span class="type">const</span> boost::system::error_code &amp;ec) &#123;</span><br><span class="line">      <span class="keyword">auto</span> self = weak_this.<span class="built_in">lock</span>();</span><br><span class="line">      <span class="keyword">if</span> (self &amp;&amp; ec != boost::asio::error::operation_aborted &amp;&amp; cid == self-&gt;_timer_corelation_id)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">// pending_block_state expected, but can&#x27;t assert inside async_wait</span></span><br><span class="line">         <span class="keyword">auto</span> block_num = chain.<span class="built_in">pending_block_state</span>() ? chain.<span class="built_in">pending_block_state</span>()-&gt;block_num : <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">auto</span> res = self-&gt;<span class="built_in">maybe_produce_block</span>();</span><br><span class="line">         <span class="built_in">fc_dlog</span>(_log, <span class="string">&quot;Producing Block #$&#123;num&#125; returned: $&#123;res&#125;&quot;</span>, (<span class="string">&quot;num&quot;</span>, block_num)(<span class="string">&quot;res&quot;</span>, res));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果对其他一些细节的代码不太明白，也不必在意，因为我也不太清楚。但是我们注意到同步操作中的一段代码，如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_timer.async_wait(</span><br><span class="line">   [&amp;chain, weak_this, cid = ++_timer_corelation_id](const boost::system::error_code &amp;ec) &#123;</span><br><span class="line">   auto self = weak_this.lock();</span><br><span class="line">   if (self &amp;&amp; ec != boost::asio::error::operation_aborted &amp;&amp; cid == self-&gt;_timer_corelation_id)</span><br><span class="line">   &#123;</span><br><span class="line">      // pending_block_state expected, but can&#x27;t assert inside async_wait</span><br><span class="line">      auto block_num = chain.pending_block_state() ? chain.pending_block_state()-&gt;block_num : 0;</span><br><span class="line">      auto res = self-&gt;maybe_produce_block();</span><br><span class="line">      fc_dlog(_log, &quot;Producing Block #$&#123;num&#125; returned: $&#123;res&#125;&quot;, (&quot;num&quot;, block_num)(&quot;res&quot;, res));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>_timer.async_wait应该是将生产出来的在群里面广播。这个函数接受一个lambda函数，表示同步的方法，同步过程中有一个maybe_produce_block()函数，我想应该是某个block procuder(以后简称BP)生产了一个区块，但是还没有得到其他BP的确认，这是个进行同步请求确认的过程。因此，我们再仔细看看进行同步的细节（不过貌似很多细节我也看不懂哎…囧…）。</p>
<p>mayb_produce_block函数的主要内容如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">producer_plugin_impl::maybe_produce_block</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">auto</span> reschedule = fc::<span class="built_in">make_scoped_exit</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line">      <span class="built_in">schedule_production_loop</span>();</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">produce_block</span>();</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">catch</span> (<span class="type">const</span> guard_exception &amp;e)</span><br><span class="line">      &#123;</span><br><span class="line">         chain_plug-&gt;<span class="built_in">handle_guard_exception</span>(e);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">FC_LOG_AND_DROP</span>();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">catch</span> (boost::interprocess::bad_alloc &amp;)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">raise</span>(SIGUSR1);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">fc_dlog</span>(_log, <span class="string">&quot;Aborting block due to produce_block error&quot;</span>);</span><br><span class="line">   chain::controller &amp;chain = chain_plug-&gt;<span class="built_in">chain</span>();</span><br><span class="line">   chain.<span class="built_in">abort_block</span>();</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上来就是一句我不懂的函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> reschedule = fc::<span class="built_in">make_scoped_exit</span>(</span><br><span class="line">   [<span class="keyword">this</span>]&#123;</span><br><span class="line">   <span class="built_in">schedule_production_loop</span>();</span><br><span class="line">&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>也就是说，往里面传了一个lambda函数，函数就是重复生产区块的函数。但是fc::make_scope_exit又是什么意思呢？这里面大概介绍一下，make_scoped_exit函数中传入一个lambda函数，may_produe_block函数结束时reschedule函数只是定义了一下，reschedule隶属于scoped_exit类，这个类的析构函数中调用了schedule_production_loop();表明函数结束之后继续生产区块。<br>随后may_produce_block中有一个重要的函数，即produce_block()函数，我们继续追踪，这个函数代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer_plugin_impl::produce_block</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">//ilog(&quot;produce_block $&#123;t&#125;&quot;, (&quot;t&quot;, fc::time_point::now())); // for testing _produce_time_offset_us</span></span><br><span class="line">   <span class="built_in">EOS_ASSERT</span>(_pending_block_mode == pending_block_mode::producing, producer_exception, <span class="string">&quot;called produce_block while not actually producing&quot;</span>);</span><br><span class="line">   </span><br><span class="line">   chain::controller &amp;chain = chain_plug-&gt;<span class="built_in">chain</span>();</span><br><span class="line">   <span class="comment">// 获取当前打包好的区块的指针</span></span><br><span class="line">   <span class="type">const</span> <span class="keyword">auto</span> &amp;pbs = chain.<span class="built_in">pending_block_state</span>();</span><br><span class="line">   <span class="comment">// 获取打包的区块的区块头</span></span><br><span class="line">   <span class="type">const</span> <span class="keyword">auto</span> &amp;hbs = chain.<span class="built_in">head_block_state</span>();</span><br><span class="line">   <span class="built_in">EOS_ASSERT</span>(pbs, missing_pending_block_state, <span class="string">&quot;pending_block_state does not exist but it should, another plugin may have corrupted it&quot;</span>);</span><br><span class="line">   <span class="comment">// 寻找BP的私钥</span></span><br><span class="line">   <span class="keyword">auto</span> signature_provider_itr = _signature_providers.<span class="built_in">find</span>(pbs-&gt;block_signing_key);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">EOS_ASSERT</span>(signature_provider_itr != _signature_providers.<span class="built_in">end</span>(), producer_priv_key_not_found, <span class="string">&quot;Attempting to produce a block for which we don&#x27;t have the private key&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//idump( (fc::time_point::now() - chain.pending_block_time()) );</span></span><br><span class="line">   <span class="comment">// 将区块内容写入数据库中，确定区块头中的merkel_root等内容</span></span><br><span class="line">   chain.<span class="built_in">finalize_block</span>();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 对区块进行签名</span></span><br><span class="line">   chain.<span class="built_in">sign_block</span>([&amp;](<span class="type">const</span> digest_type &amp;d) &#123;</span><br><span class="line">      <span class="keyword">auto</span> debug_logger = <span class="built_in">maybe_make_debug_time_logger</span>();</span><br><span class="line">      <span class="keyword">return</span> signature_provider_itr-&gt;<span class="built_in">second</span>(d);</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="comment">// 往本地的分叉的区块链数据库中提交区块，因为还没有确认</span></span><br><span class="line">   chain.<span class="built_in">commit_block</span>();</span><br><span class="line">   <span class="comment">// 获取区块时间戳</span></span><br><span class="line">   <span class="keyword">auto</span> hbt = chain.<span class="built_in">head_block_time</span>();</span><br><span class="line">   <span class="comment">//idump((fc::time_point::now() - hbt));</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取刚刚添加的最新的区块头状态</span></span><br><span class="line">   block_state_ptr new_bs = chain.<span class="built_in">head_block_state</span>();</span><br><span class="line">   <span class="comment">// 记录最新的区块生产者和其生产的区块号</span></span><br><span class="line">   _producer_watermarks[new_bs-&gt;header.producer] = chain.<span class="built_in">head_block_num</span>();</span><br><span class="line"></span><br><span class="line">   <span class="built_in">ilog</span>(<span class="string">&quot;Produced block $&#123;id&#125;... #$&#123;n&#125; @ $&#123;t&#125; signed by $&#123;p&#125; [trxs: $&#123;count&#125;, lib: $&#123;lib&#125;, confirmed: $&#123;confs&#125;]&quot;</span>,</span><br><span class="line">        (<span class="string">&quot;p&quot;</span>, new_bs-&gt;header.producer)(<span class="string">&quot;id&quot;</span>, fc::<span class="built_in">variant</span>(new_bs-&gt;id).<span class="built_in">as_string</span>().<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">16</span>))(<span class="string">&quot;n&quot;</span>, new_bs-&gt;block_num)(<span class="string">&quot;t&quot;</span>, new_bs-&gt;header.timestamp)(<span class="string">&quot;count&quot;</span>, new_bs-&gt;block-&gt;transactions.<span class="built_in">size</span>())(<span class="string">&quot;lib&quot;</span>, chain.<span class="built_in">last_irreversible_block_num</span>())(<span class="string">&quot;confs&quot;</span>, new_bs-&gt;header.confirmed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，大致对producer_plugin这个插件的内容以及主要功能有一个大致的了解。<br>这个插件主要负责区块的接收、检验、打包和本地写入功能。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hzxgoforward.github.io/2019/03/14/An%20Empirical%20Analysis%20of%20Anonymity%20in%20Zcash/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuZhenXing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/14/An%20Empirical%20Analysis%20of%20Anonymity%20in%20Zcash/" class="post-title-link" itemprop="https://hzxgoforward.github.io/page/2/index.html">An Empirical Analysis of Anonymity in Zcash</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建于：2019-03-14 18:02:14" itemprop="dateCreated datePublished" datetime="2019-03-14T18:02:14+08:00">2019-03-14</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="更新于：2023-03-05 20:02:11" itemprop="dateModified" datetime="2023-03-05T20:02:11+08:00">2023-03-05</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/" itemprop="url" rel="index"><span itemprop="name">区块链技术研究</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          


          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-Zcash的相关知识介绍"><a href="#1-Zcash的相关知识介绍" class="headerlink" title="1. Zcash的相关知识介绍"></a>1. Zcash的相关知识介绍</h1><h2 id="1-1-Zcash的工作原理"><a href="#1-1-Zcash的工作原理" class="headerlink" title="1.1 Zcash的工作原理"></a>1.1 Zcash的工作原理</h2><p>Zcash是一种从Bitcoin中分叉出来的代币, 其目的在于解决bitcoin中交易在执行过程中可以利用区块追踪交易记录的问题,进而使得交易难以追踪以提高匿名性.<br>Zcash中的地址有两种,一种叫做transparent address,简称t-address,这种地址以t开头. 另外一种地址叫做shielded address, 这种地址以z开头.Zcash中大概有如下4种交易类型,如下图所示:</p>
<center>

<img src = "https://img-blog.csdnimg.cn/20190313141202670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70"  >

</center>

<p>z-address 到z-address的转账称之为Private transactions, z-address 到t-address的转账称之为Deshielding transactions, t-address到z-address的转账叫做Shielded transactions, 而t-address到t-address的转账叫做transparent transactions. </p>
<ol>
<li><p><strong>t-to-t transaction</strong></p>
<p>两个t-address之间的交易, 和Bitcoin中的交易完全相同,交易双方的地址, 交易费, 交易金额都是公开并且可以追踪的.一个典型的示例如下:</p>
<p> &lt;/center&gt;<br> <img src="https://img-blog.csdnimg.cn/2019031314352632.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70" >&lt;/center&gt;<br> 这笔交易中, 有一个输入,2个输出,输入和输出的地址都是t开头.</p>
</li>
<li><p><strong>t-to-z transaction</strong></p>
<p> t-to-z transaction中,可以叫做shielded transaction, 只能看到输入地址, 即以t开头的地址,交易费等信息, 但是输出的具体地址以及地址个数是未知的.<br> &lt;/center&gt;<br> <img src="https://img-blog.csdnimg.cn/20190313144006733.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70" >&lt;/center&gt;</p>
<p> 这笔交易中,只有1个输入,输入代币总量以及交易费也是已知的,但是输出的地址以及输出地址的个数是未知的, 最终输入的其他ZEC流入了<strong>shielded pool</strong>中.</p>
</li>
<li><p><strong>z-to-t transaction</strong></p>
<p> z-to-t transaction,又叫做 deshielded transaction,即从shielded pool中的代币转出至某个特定的t-address中.<br> &lt;/center&gt;<br> <img src="https://img-blog.csdnimg.cn/20190313144615912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70" >&lt;/center&gt;</p>
<p> 上图中,交易的输入地址和输入地址的个数未知,但是知道输出地址的数量和具体信息,同时输出代币数和交易费用已知.</p>
</li>
<li><p><strong>z-to-z transaction</strong></p>
<p> z-address 到z-address的转账称之为Private transactions,从z-toz交易中只能得知交易费。但是交易地址、地址数量以及交易的ZEC数目都是未知的。<br> &lt;/center&gt;</p>
<pre><code> &lt;img src=&quot;https://img-blog.csdnimg.cn/20190313145010448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70&quot; &gt;&lt;/center&gt;
</code></pre><p> 这笔交易中，输入地址和输出地址的数量以及具体信息都是未知的，唯一能确定的是交易费用。z-to-z地址之间的转换，就相当于在shielded pool中进行持续转账。所有z-address中的ZEC就组成了shielded pool.</p>
</li>
</ol>
<h2 id="1-2-JoinSplits"><a href="#1-2-JoinSplits" class="headerlink" title="1.2 JoinSplits"></a>1.2 JoinSplits</h2><p>简单的理解, 从t-add 转入 z-addr的转账交易，即将ZEC转入到shielded pool中，因此叫做shielded交易，而从z-addr转到t-addr的交易， 即从shielded pool中转出ZEC, 因此叫做deshielded 交易, z-address之间的转账,则称之为private transaction.</p>
<p>从上述4中交易的介绍中, 可以观察发现,只有t-address和t-address之间的转账中没有JoinSplits, 而凡是涉及到z-addrress的交易,图中都会有一个JoinSplits的字段, JoinSplits字段中指定了交易中ZEC的来源和去向,以及其中的零知识证明,这个证明允许其他人在不揭露交易内容的前提下验证加密交易的真实性. 关于阅读本论文, 我们只需要知道这个就可以了. </p>
<p>更多关于零知识的证明,感兴趣可以点击<a target="_blank" rel="noopener" href="https://z.cash/technology/zksnarks">zk-SNARKs</a>以及如下几个链接.</p>
<ul>
<li><p>ZCash中的Transaction: <a target="_blank" rel="noopener" href="https://z.cash/technology/#viewing-keys">https://z.cash/technology/#viewing-keys</a> </p>
</li>
<li><p>ZCash中的Anatomy:  <a target="_blank" rel="noopener" href="https://z.cash/blog/anatomy-of-zcash/">https://z.cash/blog/anatomy-of-zcash/</a> * ZCash协议详解: <a target="_blank" rel="noopener" href="https://github.com/zcash/zips/blob/master/protocol/protocol.pdf">https://github.com/zcash/zips/blob/master/protocol/protocol.pdf</a> (交易细节可以参看3.4节)</p>
</li>
<li><p>ZCash零知识证明: <a target="_blank" rel="noopener" href="https://z.cash/zh/technology/zksnarks/">https://z.cash/zh/technology/zksnarks/</a> </p>
</li>
</ul>
<h2 id="1-3-Zcash的主要参与者"><a href="#1-3-Zcash的主要参与者" class="headerlink" title="1.3 Zcash的主要参与者"></a>1.3 Zcash的主要参与者</h2><p>Zcash中的参与人主要有4类, </p>
<ul>
<li><p><strong>创始人(Founders)</strong>, </p>
</li>
<li><p><strong>矿工(Miners)</strong>, </p>
</li>
<li><p><strong>服务提供商(Services)</strong></p>
</li>
<li><p><strong>用户(Users).</strong></p>
</li>
</ul>
<p>在Zcash刚开始挖矿的4年中,每次矿工挖出一个区块时,都需要将25%的出块奖励转发给创始人团队, 一个区块的出块奖励为12.5ZEC, 创始人拿到2.5ZEC, 矿工拿到10ZEC. </p>
<h2 id="2-论文主要内容简要介绍"><a href="#2-论文主要内容简要介绍" class="headerlink" title="2. 论文主要内容简要介绍"></a>2. 论文主要内容简要介绍</h2><h3 id="2-1-主要研究方法和内容介绍"><a href="#2-1-主要研究方法和内容介绍" class="headerlink" title="2.1 主要研究方法和内容介绍"></a>2.1 主要研究方法和内容介绍</h3><p>这篇文章发表于2018年第27届USENIX Security Symposium会议,本论文非常深入的分析了Zcash的匿名程度,文章首先对Zcash区块链中的区块链信息进行了统计说明, 统计结果表明Zcash区块链中, 85%的交易都是transparent 交易, 而匿名的交易仅仅占比25%左右.<br>随后对Zcash中的交易(t-to-t, z-to-t, t-to-z, z-to-z), 使用5种启发式方法进行分析并尝试对其中的地址所对应的用户进行标记.通过文章中的启发式方法的分析,分别发现了创始人和矿工在进行z-to-t和t-to-z交易时的一些明显的特征, 利用这些特征识别出了创始人和矿工的隐匿的地址,同时也对其他一些黑客组织的地址进行了识别. 文章的5个启发式分析方法主要介绍如下:</p>
<ul>
<li><p><strong>启发式方法1: Zcash一笔交易中的多个输入地址都由同一个实体控制.</strong></p>
<ul>
<li><p>将Zcash区块链中每一个地址当做1个顶点, 同一笔交易中的多个输入地址之间用无向边连接, 以此完成了对Zcash中所有t-address的聚类, 总共得到560319个簇.</p>
</li>
<li><p>Zcash中的铸币交易, 一个区块产生12.5个ZEC, 其中10个归属矿工, 2.5个归属创始人, 因此每个区块的铸币交易中可以确定并且准确的标记出创始和矿工t-address.</p>
</li>
<li><p>分别从Top10的交易所购买Zcash, 随后在交易所的地址和自己Zcash的地址之间多次转账, 根据转账记录标记出交易所的地址.</p>
</li>
</ul>
</li>
<li><p><strong>启发式方法3: 任何交易值是250.0001ZEC的z-to-t转账交易时由创世团队发起</strong></p>
<ul>
<li><p>这是因为在文章作者在研究t-to-z的交易时, 发现创始团队比较有规律的往shielded pool转账, 每次转账249.9999ZEC, 这些t-to-z转账交易的时间间隔是6~10个区块. z-to-t的交易中, 有很多转账交易是价值250.0001ZEC的交易,这些交易也前后时间间隔是 6~10个区块,作者认为这是一种创世团队提取ZEC的一种自动转账脚本. </p>
</li>
<li><p>基于上述假设, 发现了创始人团队z-to-t转账中额外的75个地址, 而前面启发式方法1中发现了48个地址, 于是总共发现了123个创始人团队的地址. </p>
</li>
<li>创世人以为执行了t-to-z交易之后将自己的ZEC转入shielded pool, 随后从shielded pool中发起z-to-t的交易将ZEC转出, 结果使用了脚本, 于是作者利用启发式方法3建立了t-to-z 和z-to-t交易之间的联系,这是其重大意义所在. </li>
</ul>
</li>
<li><p><strong>启发式方法4: 如果1个z-to-t的交易中,输出地址超过100个,并且其中一个输出地址是一个已知的矿池地址, 那么认为其他输出地址也是矿工地址</strong></p>
<ul>
<li>这个假设的前提是因为在Zcash中, 矿工挖矿成功之后铸币交易的ZEC,必须先转入shield pool, 即先执行一个t-to-z交易, 随后从shield pool 转出时矿池将每个矿工的收益分别发送给矿工,剩余ZEC退回到矿池的地址.</li>
<li>通过上述的方法,确定了110918个矿工的地址, 启发式方法4能够将矿工的t-to-z和z-to-t转账交易中的t-address联系起来.</li>
</ul>
</li>
<li><p><strong>启发式方法5: 如果一笔t-to-z的交易, 交易值是V, 随后的一段时间内, 出现了一笔转账交易值也是V的z-to-t的交易, 则认为这笔交易时相关的</strong></p>
<ul>
<li>这个假设听起来很容易造成false positive, 但是实际上 总共有12841笔t-to-z和对应的z-to-t交易, 这些对应的交易都有着完全不同的交易值, 其中的9487笔交易精确到小数点后8位, 超过98.9%的交易精确到小数点后3位, 基于这个事实,基本可以认为这些交易是相关的.</li>
</ul>
</li>
</ul>
<p>注意, 上文没有介绍启发式方法2, 这是因为论文中仅仅介绍了该方法,但是考虑到实际的可靠性,并没有采用该方法. </p>
<h3 id="2-2-文章结论"><a href="#2-2-文章结论" class="headerlink" title="2.2 文章结论"></a>2.2 文章结论</h3><ul>
<li>通过上述启发式的方法, 作者能将shielded pool 中转账交易中69.1%的地址进行标记,这严重的降低了ZCash的匿名性功能. 大多数的用户并没有很好地使用ZCash的匿名性, 或者说与shield pool 进行交互进行匿名的方式仍然留下了线索从而被识别出来, 这减少了ZCash 中的匿名集的范围, 也严重的损害了其他用户的匿名性. 论文更多资料会议网址及资料<a target="_blank" rel="noopener" href="https://www.usenix.org/conference/usenixsecurity18/presentation/kappos">点击这里.</a></li>
</ul>
<h1 id="3-匿名性方面的其他研究"><a href="#3-匿名性方面的其他研究" class="headerlink" title="3. 匿名性方面的其他研究"></a>3. 匿名性方面的其他研究</h1><p>匿名性方面的研究工作, 目前的研究方向是两种, 一种是建立一个更好的匿名性的机制, 以增强区块链中的匿名性, 例如目前的CoinJoin,Mix混币技术,或者是建立新的Dash, Monero以及Zcash等匿名性更强的币种. 另外一方面的研究工作, 则是通过分析方法,指出目前区块链匿名性技术方面的不足.</p>
<ul>
<li><p>有一些学者致力于研究  <strong>混币(mix)</strong>  服务或者是建立新的币种的方法以提高匿名性, 或者致力于创建一种新的加密货币, 例如Dash, CoinJoin技术已经Monero和Zcash. 参考文献如下:</p>
<ul>
<li>E. Heilman, L. Alshenibr, F. Baldimtsi, A. Scafuro, and S. Goldberg. TumbleBit: an untrusted Bitcoin-compatible anonymous payment hub. In Proceedings of NDSS 2017, 2017</li>
<li>A. E. Kosba, A. Miller, E. Shi, Z. Wen, and C. Papamanthou. Hawk: The blockchain model of cryptography and privacypreserving smart contracts. In 2016 IEEE Symposium on Security and Privacy, pages 839–858, San Jose, CA, USA, May 22–26, 2016. IEEE Computer Society Press</li>
<li>S. Meiklejohn and R. Mercer. Mobius: Trustless tumbling for  transaction privacy. Proceedings on Privacy Enhancing Technologies, 2018</li>
<li>T. Ruffing, P. Moreno-Sanchez, and A. Kate. CoinShuffle: Practical decentralized coin mixing for Bitcoin. In M. Kutylowski and J. Vaidya, editors, ESORICS 2014, Part II, volume 8713 of LNCS, pages 345–364, Wroclaw, Poland, Sept. 7–11, 2014. Springer, Heidelberg, Germany.</li>
<li>G. Maxwell. CoinJoin: Bitcoin privacy for the real world. bitcointalk.org/index.php?topic=279249, Aug. 2013.</li>
<li>Dash. <a target="_blank" rel="noopener" href="https://www.dash.org">https://www.dash.org</a>.</li>
<li>Monero. <a target="_blank" rel="noopener" href="https://getmonero.org">https://getmonero.org</a>.</li>
<li>Zcash. <a target="_blank" rel="noopener" href="https://z.cash">https://z.cash</a>.</li>
</ul>
</li>
<li><p>另外一些研究致力于通过一些方法检验加密货币的匿名性,指出其限制性.这些所有的研究都有共同的方案,就使用一些启发性的方法, 然后对所有的交易地址进行聚类, 再对聚类之后的地址进行标记以识别出这些地址的具体隶属信息. 目前已经有一些论文, 对Dash, Monero, CoinJoin以及Zcash的匿名性都进行了分析, 相关文献如下:</p>
</li>
</ul>
<ul>
<li><p>A. Kumar, C. Fischer, S. Tople, and P. Saxena. A traceability analysis of Monero’s blockchain. In Proceedings of ESORICS 2017, pages 153–173, 2017.</p>
</li>
<li><p>A. Miller, M. Moser, K. Lee, and A. Narayanan. An ¨ empirical analysis of linkability in the Monero blockchain. arXiv:1704.04299, 2017. <a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1704.04299.pdf">https://arxiv.org/pdf/1704.04299.pdf</a></p>
</li>
<li><p>P. Moreno-Sanchez, M. B. Zafar, and A. Kate. Listening to whispers of Ripple: Linking wallets and deanonymizing transactions in the Ripple network. Proceedings on Privacy Enhancing Technologies, 2016(4):436–453, 2016</p>
</li>
<li><p>P. Moreno-Sanchez, M. B. Zafar, and A. Kate. Listening to whispers of Ripple: Linking wallets and deanonymizing transactions in the Ripple network. Proceedings on Privacy Enhancing Technologies, 2016(4):436–453, 2016</p>
</li>
<li><p>J. Quesnelle. On the linkability of Zcash transactions. arXiv:1712.01210, 2017. <a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1712.01210.pdf">https://arxiv.org/pdf/1712.01210.pdf</a></p>
</li>
</ul>
<h1 id="4-思考"><a href="#4-思考" class="headerlink" title="4. 思考"></a>4. 思考</h1><ul>
<li><p>通过对这篇文章的阅读, 大概对区块链匿名性方面的研究有了一些初步的了解, “An Empirical Analysis of Anonymity in Zcash”这篇文章中的方法比较简单, 但是这些简单的方法应该是基于大量的研究分析工作得来的. 刚开始阅读完这篇文章的时候,我并没有认为这篇文章具有很大的贡献程度.</p>
</li>
<li><p>这篇文章能够发表在USENIX上,我觉得原因如下: </p>
<ol>
<li>文章的工作量很大, 对Zcash中所有的区块数据和交易都进行了大量的统计分析工作, 使得读者能对Zcash有一个非常直观的认知.</li>
<li>文章中使用了5种针对Zcash的启发式分析方法, 对t-address进行聚类, 随后进行标记, 然后建立tt-to-z和z-to-t这一匿名转账操作之间的联系, 找到了许多创始人和矿工的地址, 推理方法有理有据,分析比较到位.</li>
<li>该文章是第一个对Zcash的匿名性进行分析的文章, 指出了Zcash的弱点, 这就是对Zcash的匿名性的改进提供了方向.</li>
</ol>
</li>
</ul>
<ul>
<li>文章通过大量的分析和工作说明了一个问题, 即Zcash的匿名性并不仅仅是由零知识证明技术决定的, Zcash的用户在进行t-to-z交易和z-to-t交易中转换以隐藏自己身份的时候, 应该使用一种更加匿名的方式.一旦Zcash用户不能很好地隐匿自己, 其他用户的隐私性也会受到威胁.</li>
</ul>
<h1 id="5-对文章分析方法的详细阅读解析"><a href="#5-对文章分析方法的详细阅读解析" class="headerlink" title="5. 对文章分析方法的详细阅读解析"></a>5. 对文章分析方法的详细阅读解析</h1><h2 id="5-1-Zcash的统计信息"><a href="#5-1-Zcash的统计信息" class="headerlink" title="5.1 Zcash的统计信息"></a>5.1 Zcash的统计信息</h2><p>作者这里所说的所有区块统计信息,都是以2018年1月21日为止.</p>
<h3 id="5-1-1-区块生产信息"><a href="#5-1-1-区块生产信息" class="headerlink" title="5.1.1 区块生产信息"></a>5.1.1 区块生产信息</h3><p>作者使用zcashd客户端下载Zcash 区块链,将区块链载入Apache Spark中,随后使用pySpark包进行分析.截止2018年1月21日为止, 总共生产了258472个区块, 产生了31,06,043个ZEC, 其中矿工分得2,485,461, 创始人团队获得621,182 ZEC. 这里有个疑问是总共产生258472个区块,如果每个区块的reward为12.5, 那么总共应该产生3,230,900ZEC,但是实际上并没有这么多,这是因为最初的 20,000 个块的奖励很少，从第 1 个块开始到第 20,000 个块的奖励线性增加，在第 20,000 个块处奖励 12.5 个Zcash. 官方解释说这样做的目的是为防止早期的快速挖矿对 Zcash 系统造成伤害。 Zcash 系统每 2.5 分钟一个块，20,000 个块之后，每个块奖励 12.5 个Zcash。</p>
<h3 id="5-1-2-交易-Transactions"><a href="#5-1-2-交易-Transactions" class="headerlink" title="5.1.2 交易(Transactions)"></a>5.1.2 交易(Transactions)</h3><p>所有区块总共2,242,847笔交易, 交易具体分布信息如Table.1 所示.<br>    <center>
    <img src = "https://img-blog.csdnimg.cn/20190313152246158.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
    </center><br>Table.1 中transparent指的是t-to-t交易的数量, Coingen指的是铸币交易, Deshielded指的是z-to-t的交易, shielded 指的是t-to-z交易.Mixed指的是混合交易,即一笔交易的输入或者输出中都包含t和z地址的交易. Private指的是z-to-z交易.<br>从表中显然可以看出, t-to-t交易仍然占有很大的比例,它与铸币交易总共占全部交易的85%, 与shielded pool有关的交易仅仅有335,630笔,总共占有14.96%的比例.</p>
<p>在Fig.2中,展示了随着时间的增长, Zcash区块链中各种交易所占的比例变化趋势,图中可以看出, Coingen, shielded以及deshielded交易都呈现出线性增长的情况,将在后续分析中分析其成因.</p>
<center>

<img src = "https://img-blog.csdnimg.cn/20190313154343132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>
    Fig.3图揭示了随着时间增长,各种交易中涉及的ZEC比例变化趋势图. 从Fig.3 和Fig.2 的综合分析中, 可以看出与shielded pool的交易呈现出线性增长的趋势, 但是总ZEC的价值却呈现越来越小的比例, transparent交易的比例越来越高.

<center>
<img src = "https://img-blog.csdnimg.cn/20190313154215741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>

<h3 id="5-1-3-地址-Addresses-统计信息"><a href="#5-1-3-地址-Addresses-统计信息" class="headerlink" title="5.1.3 地址(Addresses)统计信息"></a>5.1.3 地址(Addresses)统计信息</h3><p>在所有的交易中, 有1,740,378个t-address, 其中8727笔交易时t-to-z trx, 另外330,780笔交易时z-to-t trx. 这两种交易不对称行的原因,是由于矿池的一些操作导致.矿池使用极少数量的地址收集block reward, 但是分配block reward时需要分别转给矿池中的每个矿工.由于shielded pool的存在, 无法探知到具体有多少z-address的存在.</p>
<p>Fig.4展示了shielded pool中ZEC随着时间增长的变化情况, 在图中有比较明显的震荡点, 而这是由于Zcash创始人的转账操作导致,后续会对这种情况给出更为具体的解释.截止到撰写本文的时间,<strong>shielded pool中总共有112, 235的ZEC.</strong></p>
<center>
    <img src = "https://img-blog.csdnimg.cn/20190313155805593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>

<p>分别对t-address中的地址拥有ZEC的数量进行排序, 可以发现其中只有25%的地址中的ZEC数量大于0, 而在这25%的地址中, 其中前1%的地址拥有78%的ZEC. <strong>拥有ZEC最多的账户拥有118,257.75个ZEC, 这比整个shielded pool中的ZEC还要多!</strong></p>
<p>截止目前为止,论文作者主要介绍了ZCash中一些统计信息,使读者对整个ZCash有一个大概的了解, 下文中,对ZCash进行一些启发式的分析方法.</p>
<h1 id="6-T-Address-Clustering"><a href="#6-T-Address-Clustering" class="headerlink" title="6. T-Address Clustering"></a>6. T-Address Clustering</h1><p>因为Zcash中从t-address地址发出的的交易与Bitcoin中的交易类似, Bitcoin中对同一笔交易中的多个输入聚类的方法同样可以用来对Zcash中同一笔交易的多个t-address进行聚类. 因此,论文提出Heuristic 1, 具体解释如下:</p>
<h5 id="Heuristic-1-如果有多个t-address作为输入出现在同一笔交易中-无论这笔交易是t-to-z或者t-to-t抑或是Mixed交易-我们都认为这些地址受同一个实体的控制"><a href="#Heuristic-1-如果有多个t-address作为输入出现在同一笔交易中-无论这笔交易是t-to-z或者t-to-t抑或是Mixed交易-我们都认为这些地址受同一个实体的控制" class="headerlink" title="Heuristic 1: 如果有多个t-address作为输入出现在同一笔交易中,无论这笔交易是t-to-z或者t-to-t抑或是Mixed交易, 我们都认为这些地址受同一个实体的控制."></a>Heuristic 1: 如果有多个t-address作为输入出现在同一笔交易中,无论这笔交易是t-to-z或者t-to-t抑或是Mixed交易, 我们都认为这些地址受同一个实体的控制.</h5><p>鉴于这种启发式的方法已经在Bitcoin中采用, 而Zcash又是Bitcoin的一个分叉,因此认为这个论断基本上是可信的.随后作者按照该方法对Zcash中的所有交易进行了聚类,假设交易中的每个t-address是一个节点, 则对同一笔交易中的多个输入用一条无向边链接, 随后得到聚类结果.经过聚类后得到560, 319个cluster, 其中97,539个cluster包含至少2个t-address.</p>
<p>这种启发式的方法可以发现由同一实体控制的多个地址,但是却不能有效的追踪常见的地址变换情况, 最常见的地址变换情况是一个sender使用地址Addr_A将ZEC发送给recipient,此外还有一部分的ZEC作为找零转到了自己的另外一个地址Addr_B上,随后如果sender仅仅将在一笔交易中心仅仅以Addr_B作为输入将剩余ZEC全部花出去时,上述启发式方法无法建立Addr_A和Addr_B之间实际上由同一实体控制的情况.</p>
<h5 id="Heuristic-2-如果在一笔交易的JoinSplit的input中有一个或者多个地址是t-address-代号t-addr-A-而第二个input地址-代号t-addr-B-同时又是唯一的一个output-t-address-那么-t-addr-B和t-addr-A隶属于同一实体控制"><a href="#Heuristic-2-如果在一笔交易的JoinSplit的input中有一个或者多个地址是t-address-代号t-addr-A-而第二个input地址-代号t-addr-B-同时又是唯一的一个output-t-address-那么-t-addr-B和t-addr-A隶属于同一实体控制" class="headerlink" title="Heuristic 2: 如果在一笔交易的JoinSplit的input中有一个或者多个地址是t-address(代号t_addr_A), 而第二个input地址(代号t_addr_B)同时又是唯一的一个output t-address,那么 t_addr_B和t_addr_A隶属于同一实体控制."></a>Heuristic 2: 如果在一笔交易的JoinSplit的input中有一个或者多个地址是t-address(代号t_addr_A), 而第二个input地址(代号t_addr_B)同时又是唯一的一个output t-address,那么 t_addr_B和t_addr_A隶属于同一实体控制.</h5><p>这个假设实在是,作者先到了这个假设,但是实际上由于Zcash的一个钱包—zcash4win的存在,有些用户会给钱包开发者一些费用,因此这个可能是个例外,于是作者并没有采用这个方法.</p>
<h2 id="6-1-Tagging-address-标记各种地址"><a href="#6-1-Tagging-address-标记各种地址" class="headerlink" title="6.1 Tagging address(标记各种地址)"></a>6.1 Tagging address(标记各种地址)</h2><h3 id="6-1-1-标记交易所的地址"><a href="#6-1-1-标记交易所的地址" class="headerlink" title="6.1.1 标记交易所的地址"></a>6.1.1 标记交易所的地址</h3><p>根据已有的clusters, 作者下一步目标是对这些cluster进行标记,以确定他们是Zcash的4类用户中的哪一类. 首先对交易所进行标记, 作者首先根据20家交易所的市场占有率,选出其中的top-10交易所, 随后分别从这些交易所中购入一些Zcash,然后在交易所的地址和自己注册的Zcash地址之间多次进行转账,每次转账的时候都对相应的交易所的地址进行标记.这样就可以确定相应交易所所在的cluster, 文章作者分别对每个cluster进行了标记,以每个簇中地址的个数从大到小排序,最大的簇标记为0, 与top-10交易所之间的交易次数,随后确定的交易所在的簇的编号, 具体结果如Table. 2所示.其中ShapShift是一家公司, 用户可以通过这个账户进行币种转换.</p>
<center>
<img src = "https://img-blog.csdnimg.cn/20190313185947149.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>

<h3 id="6-1-2-标记创始人和矿工的地址"><a href="#6-1-2-标记创始人和矿工的地址" class="headerlink" title="6.1.2  标记创始人和矿工的地址"></a>6.1.2  标记创始人和矿工的地址</h3><p>收集创始人已经公开的地址,同时从区块中标记矿工的地址, 验证矿工地址标记的正确性, 可以直接通过矿池网站查看矿池的为挖出区块的声明.</p>
<h3 id="6-1-3-结果"><a href="#6-1-3-结果" class="headerlink" title="6.1.3 结果"></a>6.1.3 结果</h3><h5 id="矿工和创始人"><a href="#矿工和创始人" class="headerlink" title="矿工和创始人"></a>矿工和创始人</h5><p>其中发现有一些矿工的地址是交易所的地址,这说明有些矿工直接将所属交易所的地址用来接收block reward, 这样为的是方便提现, 同时有一些创始人的地址也隶属于交易所.<br>Table2中可以看出ShapeShift的使用频率非常高,已经收到超过1.1M 的ZEC, 同时发送的ZEC几乎是等量的.与交易所不同，它的集群包含相对较少数量的矿工地址（54），这与其用作转移资金的方式相符，而不是将其存放在钱包中。<br>尽管矿池和创始人在Zcash中非常活跃,但是由于他们只使用少部分的地址, 因此他们的地址形成的簇不太大.</p>
<h5 id="公开的组织"><a href="#公开的组织" class="headerlink" title="公开的组织"></a>公开的组织</h5><p>另外,通过调查,发现了3个比较大的接收Zcash支付的组织:the Internet Archive, torservers.net以及Wikileaks. 其中torservers.net只通过z-address接收转账.因此无法识别出他们发起的交易. Wikileaks 也是只通过z-address接收转账.Internet Archive的31笔转账中总共转账17.3ZEC, 9笔交易是匿名的. Wikileaks的20笔转账交易全部是t-to-t交易,并且所有的地址单独成簇.</p>
<h1 id="7-与Shielded-Pool的交互"><a href="#7-与Shielded-Pool的交互" class="headerlink" title="7. 与Shielded Pool的交互"></a>7. 与Shielded Pool的交互</h1><p>这部分分析t-to-z和z-to-t交易.随着时间增长,总共有3,901,124的ZEC进入pool中,随后又有3,788,889的ZEC从pool中取出.Fig 5描述了这一情况, 基本上存储和取回的数量持平,并且呈现对称形式.这表明很多用户存入pool之后会很快的取回他们的ZEC.另外,图中有很明显的4处尖峰.第一处尖峰发生在2016年12月份,由1笔pool中取回7135ZEC的交易, 这笔ZEC分别转给15个t-address,这15个账户属于创始人. 第二处尖峰发生在2017年12月25日, 在242642个区块上,10,000ZECX分别转给10个t-address, 每个t-address收到了1,000ZEC, 目前这10个账户并没有进行任何交易.另外两次的t-to-z的尖峰是, 每个t-address都单独成一个簇,在后续中会说明与创始人有关.</p>
<center>
<img src = "https://img-blog.csdnimg.cn/20190313194509493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>

<p>利用标记好的创始人信息和矿工的地址信息,分析这些包含创始人地址或者包含矿工地址的t-to-z转账交易, 得到Figure 6. 根据Figure 6可知矿工和创始人是往shielded pool 转账最多的人, 实际上占比可达76.7%. 而矿工占比达到63.7%, 这表明创始人并没有将很多ZEC放入pool中,毕竟创始人的ZEC是矿工的20%.</p>
<center>
<img src = "https://img-blog.csdnimg.cn/20190313200026398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>

<p>转账最多的用户,往pool转入超过10,000ZEC, 转账情况如图Figure 7所示.从这图可以看出来, pool中存款的大户仍然是创始人和矿工.</p>
<center>
<img src = "https://img-blog.csdnimg.cn/20190313200534852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>

<h2 id="7-1-t-to-z和z-to-t交易之间建立联系"><a href="#7-1-t-to-z和z-to-t交易之间建立联系" class="headerlink" title="7.1 t-to-z和z-to-t交易之间建立联系"></a>7.1 t-to-z和z-to-t交易之间建立联系</h2><p>shield pool的最大作用是提供了一个匿名集, 用户通过t-to-z的转账之后再从z-to-t中提款,这样其他人就无法追踪提的款来自于哪里.但是如果把t-to-z和z-to-t这两种交易之间能够联系起来,这样在未来发生z-to-t的转账时可以把已确定名单的交易排除出去,这样就能够减小匿名集的大小.</p>
<p>最简单的方法是, 如果t-to-z中的t和z-to-t中的地址相同,那么就能排除一部分 shield pool 的匿名集合.于是实施这个想法的结果如图Figure 8a所示.实际上,通过这种方法,几乎没法将一些z-to-t交易和创始人的地址对应起来, 实际上,只能对应一部分矿工的地址.毕竟创始人不傻, 交易进入shield pool就是为了匿名,怎么可能再采用使用过的地址转出呢, 何况这个团队是以密码学为看家本领,所以不会犯这种错误,而只有对于矿工来说, 使用同样地址无所谓,因为对匿名性要求不高,能提款就好. 最终能与矿工地址对应起来的交易总共有49280笔,占所有z-to-t交易的13.3%.</p>
<center>
<img src = "https://img-blog.csdnimg.cn/20190313205049137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>

<h3 id="7-1-1-将z-to-t中创始人的t-address识别出来"><a href="#7-1-1-将z-to-t中创始人的t-address识别出来" class="headerlink" title="7.1.1 将z-to-t中创始人的t-address识别出来"></a>7.1.1 将z-to-t中创始人的t-address识别出来</h3><p>经过对创始人团队的地址分析,发现其中14个地址用于t-to-z的交易, 而其中每一笔t-to-z的交易每次转账都是249.9999ZEC, 这恰好是100个区块的奖励. 而另外只有5笔 249到251范围之间的t-to-z转账交易.基于这个特点,本来没法将t-to-z和z-to-t交易联系起来,但是这种模式给了作者灵感. 在所有的z-to-t交易中,没有发现249.9999的转账交易,但是发现了1953笔250.0001ZEC笔交易, 另外1969笔交易在249和251范围之间.于是作者检查了249.9999的t-to-z交易的频率,发现每笔交易之间间隔6~ 10个区块,再检查z-to-t的250.0001ZEC的交易时,发现1953中的1943笔交易的间隔大概是6~10个区块, t-to-z和z-to-t的交易,都像同一个模式, 这种模式的表现情况可以参看figure 9. </p>
<center><img src = "https://img-blog.csdnimg.cn/20190313204433761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>

<p>基于Figure 9 的这种情况,作者大胆做出一个启发式方法:</p>
<h5 id="Heuristic-3-任何z-to-t的交易中-如果转出250-0001ZEC-那么这笔交易是由创始人发起的"><a href="#Heuristic-3-任何z-to-t的交易中-如果转出250-0001ZEC-那么这笔交易是由创始人发起的" class="headerlink" title="Heuristic 3. 任何z-to-t的交易中,如果转出250.0001ZEC, 那么这笔交易是由创始人发起的."></a>Heuristic 3. 任何z-to-t的交易中,如果转出250.0001ZEC, 那么这笔交易是由创始人发起的.</h5><p>通过运行这个方法, 作者通过z-to-t交易, 额外发现了75个创始人的t-address, 这和之前的48个地址加起来,总共是123个地址.通过这一波操作, 可以找到创始人的z-to-t的交易, 对比之前的figure 8a, 此时得到的Fugire 8b.</p>
<h3 id="7-1-2-将z-to-t中矿工的t-address识别出来"><a href="#7-1-2-将z-to-t中矿工的t-address识别出来" class="headerlink" title="7.1.2 将z-to-t中矿工的t-address识别出来"></a>7.1.2 将z-to-t中矿工的t-address识别出来</h3><p>Zcash协议规定铸币交易产生的ZEC,必须先进入shield pool, 然后才能更使用, 正因为此, 很多矿池或者个人矿工在铸币交易之后还需要将地址中的ZEC转入shield pool, 使用的时候再从shield pool中取回. 由于每个矿池网站会公布自己挖出的区块信息, 这样每个铸币交易时转账的地址就可以和矿池对应起来. 于是可以统计出每个矿池随着时间增长的情况下转往poll的ZEC值得变化情况.</p>
<center><img src = "https://img-blog.csdnimg.cn/20190313210152616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>

<p>由于铸币交易存放在矿池的地址中, 矿池地址将ZEC转入pool之后把这些ZEC分发给自己的矿工, 每个矿池旗下都有很多个矿工,每个矿工都有自己的地址. 于是得出如下启发式方法.</p>
<h5 id="Heuristic-4-如果一个z-to-t的交易中有超过100个输出地址-只要其中1个地址属于已知的一个矿池地址-那么则认为这笔交易是矿池的withdrawl交易-同时对其他输出地址标记为矿工的地址"><a href="#Heuristic-4-如果一个z-to-t的交易中有超过100个输出地址-只要其中1个地址属于已知的一个矿池地址-那么则认为这笔交易是矿池的withdrawl交易-同时对其他输出地址标记为矿工的地址" class="headerlink" title="Heuristic 4. 如果一个z-to-t的交易中有超过100个输出地址,只要其中1个地址属于已知的一个矿池地址,那么则认为这笔交易是矿池的withdrawl交易, 同时对其他输出地址标记为矿工的地址."></a>Heuristic 4. 如果一个z-to-t的交易中有超过100个输出地址,只要其中1个地址属于已知的一个矿池地址,那么则认为这笔交易是矿池的withdrawl交易, 同时对其他输出地址标记为矿工的地址.</h5><p>启用该方法分析后, 最终得到在z-to-t标记中,将110918个地址标记为矿工地址, 最终得到的结果如图Fig.8c所示. top10矿池的t-to-z和z-to-t交易的信息如Table 4所示.</p>
<center><img src = "https://img-blog.csdnimg.cn/20190313213901501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>

<h3 id="7-1-3-识别其他实体交易"><a href="#7-1-3-识别其他实体交易" class="headerlink" title="7.1.3 识别其他实体交易"></a>7.1.3 识别其他实体交易</h3><h5 id="Heuristic-5-如果一个z-to-t的交易中包含价值v的转账-随后若干个区块时间间隔内的z-to-t的交易中的价值也是v-则认为这笔交易时round-trip-transaction"><a href="#Heuristic-5-如果一个z-to-t的交易中包含价值v的转账-随后若干个区块时间间隔内的z-to-t的交易中的价值也是v-则认为这笔交易时round-trip-transaction" class="headerlink" title="Heuristic 5. 如果一个z-to-t的交易中包含价值v的转账, 随后若干个区块时间间隔内的z-to-t的交易中的价值也是v, 则认为这笔交易时round-trip transaction."></a>Heuristic 5. 如果一个z-to-t的交易中包含价值v的转账, 随后若干个区块时间间隔内的z-to-t的交易中的价值也是v, 则认为这笔交易时round-trip transaction.</h5><p>这个假设看起来不那么靠谱,因为在若干个区块内t-to-z和z-to-t的两笔交易中的价值v相等的情况可能会很多,这种情况下没办法准确的将这些交易对应起来. 但是实际上经过分析发现,12,841笔不同面值的交易中, 其中9487笔交易的ZEC精确到了小数点后8位,其中的98.9%的交易,每笔交易的ZEC都精确到了小数点后3位.这些数据的特点,使得上述方法的实现成为了可能.</p>
<p>使用上述分析方法,最后识别出12841笔不同ZEC值的z-to-t和t-to-z的交易,转账总价值为 1,094,513.23684 ZEC, 其中97%的ZEC来自于矿工和创始人. 执行Heuristic 5中, 区块间隔分别设置为1~100,运行结果如图Figure 11所示. 当设置为10个区块间隔时, 可以关联到70%的z-to-t和t-to-z转账交易.</p>
<center><img src = "https://img-blog.csdnimg.cn/2019031321532617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>

<h2 id="8-Shielded-Pool内部的交互"><a href="#8-Shielded-Pool内部的交互" class="headerlink" title="8.Shielded Pool内部的交互"></a>8.Shielded Pool内部的交互</h2><p>文中作者分析了6,934笔z-to-z的交易, 其中包括8,444个JoinSplits.  其中93%的z-to-z交易仅仅使用1个JoinSplit作为输入. 1个JoinSplit中最多包括2个shield output作为input,  这表明大部分的z-to-z交易时以最多2个shielded output作为input. 作者不太确定 是不是一小部分用户进行了多次的交易,或者是很多用户仅仅做一次交易.这样的根本问题在于, shielded pool中z-address的个数有多少个, 并且控制他们的实体到底有多少. 实际上发现Bitclub Pool中t-to-z交易总共有196笔, 但是z-to-z交易有1516笔,这说明要么Bitclub Pool 在t-to-z之后进行了很多z-to-z的交易, 要么说明t-to-z之后还有返回的找零. 然而实际上BitClub总共只有200个z-to-t交易, 所以前者的概率更大.</p>
<h2 id="9-案例分析-The-Shadow-Brokers"><a href="#9-案例分析-The-Shadow-Brokers" class="headerlink" title="9.案例分析:The Shadow Brokers"></a>9.案例分析:The Shadow Brokers</h2><p>The Shadow Brokers(TSB), 是一个2016年兴起的黑客组织, 主要贩售美国国家安全局(NSA)制作的软件, TSB起先值接收Bitcoin的转账, 随后开始接收Zcash的转账.</p>
<p>作者首先翻看了TSB的博客(目前该博客的网址貌似打不开了), 在2017年5月, 该组织宣称他们开始接收Zcash作为他们的服务费, 2017年6月~8月收取Zcash和Monero, 但是9月份以后只收Zcash. Table 5展示了该组织从5月份开始到10月份,总共收到的ZEC.</p>
<center><img src = "https://img-blog.csdnimg.cn/20190313221915254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>

<p>为了识别出有关该组织的t-to-z交易, 首先排除矿工和创始人存储的有关100, 200, 400, 500的t-to-z的交易, 所以对于TSB的客户,有下述两个假设:</p>
<ul>
<li>他们的ZEC不是来自于z-to-t交易, 并应该是来自t-to-t交易,因为可以从交易所购买币种.</li>
<li>他们不是经常使用ZEC的人,因此假设这个账户的交易次数在250以内.(250这个参数估计作者根据数据定的阈值)</li>
<li>改地址所属的较大的群在1个月以内存入pool不超过1 ZEC(老实说,这个假设我没看明白是啥意思)<br>最终得到24个疑似客户,结果如下Table 6所示.<center><img src = "https://img-blog.csdnimg.cn/20190313225054124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>

</li>
</ul>
<h2 id="10-结论"><a href="#10-结论" class="headerlink" title="10 结论"></a>10 结论</h2><p>该论文对Zcash的交易情况作了深入的分析, 尤其是对其匿名性保证进行了检验, 为了检验Zcash的匿名性,作者利用了众多启发式的方法以及之前对其他加密货币用过的经验分析方法. 论文研究结果表明大多数的用户并没有很好地使用ZCash的匿名性,或者说大多数的用户并没有很好地使用ZCash的匿名性, 与shield pool 进行交互进行匿名的方式仍然留下了线索从而被识别出来, 这减少了ZCash 中的匿名集的范围, 也严重的损害了其他用户的匿名性.</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hzxgoforward.github.io/2019/02/22/%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C%E7%A7%91%E6%99%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuZhenXing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/22/%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C%E7%A7%91%E6%99%AE/" class="post-title-link" itemprop="https://hzxgoforward.github.io/page/2/index.html">闪电网络科普</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建于：2019-02-22 21:16:44" itemprop="dateCreated datePublished" datetime="2019-02-22T21:16:44+08:00">2019-02-22</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="更新于：2023-03-05 20:03:09" itemprop="dateModified" datetime="2023-03-05T20:03:09+08:00">2023-03-05</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/" itemprop="url" rel="index"><span itemprop="name">区块链技术研究</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          


          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="闪电网络"><a href="#闪电网络" class="headerlink" title="闪电网络"></a>闪电网络</h2><p><img src="https://img-blog.csdnimg.cn/20190505213250545.jpg" alt="在这里插入图片描述"><br>很多人说闪电网络是比特币的未来，是趋势。但笔者始终觉得，如果不能理解底层的技术原理，就无以言对上层应用的深刻理解，更不足以谈对未来趋势的判断。接下来，我将在Aaron van Wirdum 编写的《闪电网络三部曲》的基础上，用更加通俗的语言介绍闪电网络。感谢Aaron van Wirdum绘制的交易结构图，这对我们理解闪电网络将会起到莫大的帮助。</p>
<p>理解闪电网络主要分为两步，一是理解双向支付通道，二是诸多通道扩展成闪电网络。</p>
<p>闪电网络想要解决的是比特币扩容、交易即时确认和手续费高的问题。举个例子来说明闪电网络整体思路，设想我们的老朋友Alice要给Bob转1个比特币，她该怎么做呢？</p>
<p>传统做法是Alice可以挑选出其未花费的输出用对应私钥签名，并向比特币网络广播，矿工验证打包，一般来说6个区块之后即可确认交易。这个过程很慢，需要等待一个小时左右，并且还要支付给矿工的手续费。于是呢，天才的程序员们碰撞出了闪电网络的解决方案。</p>
<p>操作过程是这样的，Alice和Bob先各自把5个BTC转给一个由两人共同控制的多重签名地址。这笔交易和比特币网络上其他普通交易没什么太大区别，只是转出的地址是一个多签地址。这个过程称为开启通道。</p>
<p>多重签名技术（multisig）是多个用户同时对一个数字资产进行签名。可以简单地理解为，一个账户多个人拥有签名权和支付权。如果一个地址只能由一个私钥签名和支付，表现形式就是1/1；而多重签名的表现形式是m/n，也就是说一共n个私钥可以给一个账户签名，而当m个地址签名时，就可以支付一笔交易。例如，多重签名2/3，表示3个人拥有签名权，而两个人签名就可以支付这个账户里的比特币；多重签名1/2，表示2个人拥有签名权，谁都可以单独来支配这笔资金。</p>
<p>开启通道后，这个多签地址里面就拥有10个比特币，这是被区块链记录了的，全网承认。接下来就是Alice和Bob私底下的交易了，不广播，不记在链上，正因如此，交易确认速度快，几乎零手续费（其实可能还有较低的路由费，后文会讲），这个过程称为链外交易，在交易通道（channel）中进行。（注意：有很多人问为什么闪电网络很快，我想说，没有第三方记账当然快啊。）</p>
<ol>
<li><strong>构建双向支付通道</strong></li>
</ol>
<p>什么是通道？怎么在通道进行交易呢？它安全吗？</p>
<p>简单来说，Alice和Bob都会在各自的小本本上记账，他们都知道对方怎么记的，且有密码学设计保证谁也不能多记耍赖。这当然也是由闪电协议精巧的设计保证的，后文再讲技术细节。</p>
<p>那么我们就可以想象出这样一个通道：在这个通道中，一开始Alice和Bob各有有5个，如果第一笔记“Alice有4个，Bob有6个”，这就相当于Alice给Bob转了1个比特币。如果，过了几天，Alice又要向Bob支付2个比特币，那么他俩会再记一次账，这次记“Alice有2个，Bob有8个”，同时上次记的“Alice有4个，Bob有6个”在两人共同确认后作废，也就是说，本次记账后，Alice只有2个比特币，她不能再拿出旧账单说“Alice有4个，Bob有6个”。</p>
<p>注意，在通道关闭之前，这10个比特币只能在Alice和Bob之间使用。也就是说，在不关闭通道的情况下，主网只知道多签地址有10个比特币，并不知道Bob已经拥有了其中的8个比特币，这就是所谓“双向支付通道”。</p>
<p>关于这个记账过程，EthFans翻译的《用算盘了解闪电网络》可以说很形象了。<br><img src="https://img-blog.csdnimg.cn/20190505213121133.png" alt="在这里插入图片描述"></p>
<p>之后Alice和Bob就可以在通道里过上你来我往的相互转账的愉快生活，远离主链的拥堵与高费用。这就好比俩人结婚了，夫妻们想要私下结算，只要俩人同意，想怎么算就怎么算。</p>
<p>天有不测风云，突然有一天，Alice不想和Bob这么转来转去了，想取出自己在通道里的钱去外面的花花世界潇洒快活。那么就需要关闭通道了，常有两种方式，一是协议离婚，如下图，这种方式很和平，双方共同从最开始的多签地址签名发起一笔交易分别转到两人各自控制的地址对应数额的比特币，同时将之前记在小本本上的所有旧账一笔勾销。<br><img src="https://img-blog.csdnimg.cn/20190505213501880.jpg" alt="在这里插入图片描述"><br>二是起诉离婚，Alice想离而Bob不想离，这时Alice可以单方面强制关闭通道，将小本本最后一笔交易广播出去，只要矿工验证并打包进区块，这婚也算离了，代价是Alice并不能立马得到比特币，需要等待一定时间。本着劝和不劝分的原则，闪电协议设置了哈希时间锁定合约，单方面强制离婚（关闭交易通道）会受到延迟收到退款的惩罚，这是为了保证双方交易的稳定。</p>
<p>以上最后一个过程是通道关闭。注意，不管是协议离婚还是起诉离婚，这都是要法院受理登记的。关闭通道一定要发起交易并广播到主网，最后矿工记录，所以还是要忍耐一定确认时间和支付手续费的，这与闪电网络无关。</p>
<p>至此我们已经知道了Alice和Bob链下互相转账的那点事儿了，这就是所谓“双向支付通道”。开启通道需要在主链交易，这是锁定资金，关闭通道也需要在主链交易，这是释放资金。中间可以进行任意多次转账支付，是0确认0手续费的。</p>
<ol>
<li><strong>将双向支付通道扩展成闪电网络</strong></li>
</ol>
<p>新问题来了，世界上除了这两位，还有Carol、Eric、Diana等等。设想Alice想转给Carol 1个BTC,她该怎么办呢？自然地，她俩可以再重复上述操作建立一个双向通道。但是，如果我们为了应用闪电网络，需要世界上每两个人之间都建立一条通道，这将是非常大的工作量且不切实际的。为了解决这一问题，我们需要将<strong>双向支付通道扩展成闪电网络</strong>。</p>
<p>假如Bob和Carol之间已经建立了支付通道，而Alice和Bob之间也有支付通道，那么Alice可以先把钱转给Bob再由他转给Carol，即Bob充当了支付的中间人，在网络里他就是一个<strong>路由节点</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/20190505213723692.png" alt="在这里插入图片描述"><br>如上图，B和C，A和B之间有通道， A和C就通过B来达成交易。更一般地，A和F可以经过B、D来交易。</p>
<p>当很多的节点相互建立通道，最后就会形成闪电网络。<br><img src="https://img-blog.csdnimg.cn/20190505213812781.png" alt="在这里插入图片描述"></p>
<h2 id="闪电网络原理技术细节版"><a href="#闪电网络原理技术细节版" class="headerlink" title="闪电网络原理技术细节版"></a>闪电网络原理技术细节版</h2><p>通过上文，我们差不多了解了闪电网路是如何形成的。但是看完大家一定会觉得有哪里不对劲。哪里不对劲呢？</p>
<p>我们来回顾一下历史。</p>
<p>如果Alice和Bob完成了一笔交易，他们手头各自都有账本，在没有第三方见证的情况下，他们都可能把账本按照对自己有利的方向进行篡改。银行是怎么解决这个问题的呢？在传统的银行业中，由于Alice和Bob都信任银行，因此银行充当了双方都信任的第三方来进行记账，并且以第三方的账目为准，因此双方不管怎么篡改账本都没用。区块链是怎么解决这个问题的呢？区块链同样引入了第三方来充当记账者，虽然Alice和Bob都不信任记账者，但系统会想尽办法来保证记账者的诚实性。</p>
<p><strong>但是到了闪电网络，请注意，这里再也没有一个第三方记账者了！Alice和Bob又重新拿回了他们的小本子，各自记起了各自的账本。问题在于怎么保证他们都诚实记账！</strong></p>
<p>1.<strong>双方支付通道：如何使记账的双方保持诚实？</strong></p>
<p>这是一个非常有意思的问题，使得我们的第一步——建立“双向支付通道”,变得难以维持了。那么，Alice和Bob这样两个完全不信任对方的陌生人，究竟该如何在没有主链矿工记录的情况下，相互转账交易？</p>
<p>作为铺垫，我们需要讲解两个概念，哈希时间锁定和哈希密钥锁定。首先是哈希时间锁定，这是在交易脚本里面设置时钟，必须要等设定时间之后，才能用地址的私钥签名解锁地址里的比特币。例如Alice收到了一笔2 BTC转账，但是对方设定了1000个区块之后才能解锁，所以Alice必须等待1000个区块之后才能用自己的私钥签署交易,花费其中的BTC转给Bob。</p>
<p><img src="https://fs.bitcoinmagazine.com/img/articles/understanding-the-lightning-network-part-building-a-bidirectional-payment-channel-74.jpg" alt=""></p>
<p>其次是哈希密钥锁定。哈希函数可以把一串输入转换成256位固定长度的输出，计算过程称为一次哈希运算，其中输入称为密文，输出称为密文的哈希值。哈希函数具有单向性，即从密文可以算出哈希值，但是从哈希值反向算出密文几乎是不可行的。计算的办法是暴力破解，逐一输入密文进行哈希运算，验证运算结果是否为要求的哈希值。基于这种特性，可以把一个密文的哈希值放入交易的输出当中充当哈希密文锁，也就是必须得输入该哈希值对应的密文才能解锁脚本中的比特币。例如，例如Alice收到了一笔2BTC转账，但是对方设定了哈希值锁定，所以Alice必须得到交易方的密文，同时配合自己的密钥签名才能签署交易，花费其中的BTC转给Bob。</p>
<p><img src="https://img-blog.csdnimg.cn/20190505213917413.jpg" alt="在这里插入图片描述"></p>
<p>有了这两个工具，让我们看看那群程序员天才们是如何构想出一个程序，使得互不相识的双方能够诚实记账的。</p>
<p>在原理的白话版我们已经讲过了关于通道的三个步骤：开启通道，通道内交易，关闭通道。</p>
<p>开启通道较为简单，Alice和Bob分别向多签地址1转入5个BTC。这是一个2/2地址，也就是必须两人都签名，此地址的比特币才可以转出去。</p>
<p><img src="https://img-blog.csdnimg.cn/20190505214529422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>接下来是通道内交易，我们需要讲解Alice和Bob之间的两次交易才能完全明白双向支付通道的巧妙之处。第一次Alice需要向Bob支付1个BTC，第二次Bob需要向Alice支付1个比特币。</p>
<p>第一次交易的流程是，Bob首先在自己电脑的闪电网络软件上构建交易，如下左图所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20190505214228653.png" alt="在这里插入图片描述"></p>
<p>Bob在构建交易时需要通过闪电网络软件的通信模块和Alice建立联系，获得Alice创建的密文的哈希值，然后把这个哈希值作为哈希锁放在自己构建的交易里。这笔交易Bob把10个比特币分别转给Bob控制的普通地址6个和另一个“多签地址2”4个BTC。（<strong>通俗来讲，就是A和B的财产放在一起，但是B主动从A那里要了一把锁把A的财产锁住了，没有A的钥匙B也无法打开。</strong>）</p>
<p>多签地址2是一个1/2地址，也就是两个条件有一个满足即可解锁。具体来说，需要Bob用自己的私钥和Alice的密文（此时Bob只有密文的哈希值，并不知道密文，所以Bob是不可能获得这4个比特币的）同时来解锁；或者Alice等待1000个区块后用私钥来解锁。如下图，这两个条件是双向支付通道的精髓所在，请先记住它，稍后分析中会讲设计的原因。</p>
<p><img src="https://img-blog.csdnimg.cn/20190505214414640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>Bob构建完交易后会签名，然后把这笔未完成的交易以点对点方式发送给Alice，而不是广播到全网。显然，上述交易是对Bob有利的，一旦Alice签名并广播，Bob可以立即获得6个比特币，而Alice需要等到1000个区块之后才能拥有4个比特币。<strong>这也就是上文提到的单方面“起诉离婚”会受到延时惩罚的技术实现细节。然而，这笔对Bob有利的交易的主动控制权却掌握在Alice手里，因为Alice不签名并广播的话，这笔交易暂时不会生效的。</strong></p>
<p>在Bob创建这笔对自己有利的交易同时，Alice也创建了类似的一笔对自己有利的交易，两者是一种镜像。这个过程相当于是Alice帮Bob在他的小本本上记了一笔账，这10个比特币Bob占6个，Alice占4个，同理Bob也帮Alice记账了。具体来说，就是Alice电脑里保存着Bob创建并签名的未完成交易，Bob保存着Alice创建并签名的未完成交易。两者合在一起，就完成了他们之间第一笔交易的记账过程，完整过程如下图。</p>
<p><img src="https://fs.bitcoinmagazine.com/img/articles/understanding-the-lightning-network-part-building-a-bidirectional-payment-channel-76.jpg" alt=""></p>
<p>这个过程并不需要互相信任，只需双方同时在线，建立联系并交换哈希值，再在各自的电脑里创建交易最后发送给对方。整个过程不需要经主链由矿工打包确认，所以非常快速并且没有手续费。也可以看到，任何一方都可以随时强制关闭通道，将自己占主动权的交易签名并广播全网，代价是1000区块延时,如何理解1000区块的延迟呢,Bob写的交易此时在Alice手中,Alice写的交易在Bob手中,假若Bob单方面对Alice写的交易进行签名后广播,这个交易Alice可以立马拿到4BTC,但是Bob需要等待1000个区块之后才能拿到6个BTC,这就是单方面撕毁合约的惩罚.</p>
<p>但是这里仍然有一个问题，就是外界无法知道通道内的交易次序，因此无法鉴别通道关闭后广播出去的交易，是否为最终交易。例如，如果双方在这个通道里不断发生交易，最后导致Alice手中有9个，Bob手里有1个，但假设最后Bob强制关闭交易通道，并广播出去Alice有5个，Bob有5个，Bob便能凭空赚得4个。（虽然这4个要等到1000个区块后才能获得，但这是值得的。）该怎么解决这个问题呢？</p>
<p>这次我们就要再次用到上文提到的哈希密钥锁了。</p>
<p>现在我们考虑过了两天，Bob要向Alice转1个BTC，即双方发生第二笔交易B。类似他们仿照上述第一笔交易操作进行第二次记账，此时应当是Alice 5个，Bob 5个。</p>
<p><img src="https://fs.bitcoinmagazine.com/img/articles/understanding-the-lightning-network-part-building-a-bidirectional-payment-channel-77.jpg" alt=""></p>
<p><strong>一个最大的区别是建立第二笔交易B之前，两人会相互交换第一笔交易中的密文，即对方第一把锁的钥匙。</strong>这么做的目的在于作废第一笔交易记录A，使得两人都只能承认最新的交易记录B有效。</p>
<p>设想Bob在第一笔记录中拥有6个比特币，而第二笔记录变成了5个，那么如果他想作弊去签名并广播第一条记录呢？</p>
<p><strong>结果是他将失去通道内所有的比特币！</strong></p>
<p>因为Bob签名并广播了下图交易之后，Alice立马会获得4个BTC，同时Bob则必须等待1000个区块之后才能解锁6个BTC。然而，由于此时Alice已经获得了密文即钥匙1，所以Alice可以赶在Bob之前解锁这6个BTC。综合来看，只要Bob想要广播旧交易记录，他就会一无所有。</p>
<p><img src="https://img-blog.csdnimg.cn/201905052147117.png" alt="在这里插入图片描述"></p>
<p>有了能作废旧账的保证，双方就可以在通道内反复任意多次交易，每次交易之后的状态都是资金池资金的划分比例的最新确认状态。</p>
<p>最后，关闭通道。如本文第二部分所讲，有两种方式关闭通道，一是单方面强制关闭，即某一方将自己控制的最新交易签名后广播出去即可。二是商议后关闭，此时双方再从最开始的多签地址构建一笔交易。</p>
<p>至此，我们明白了如何在无信任的条件下如何建立双向支付通道。</p>
<p>2.<strong>闪电网络：如何使路由节点保持诚实？</strong></p>
<p>同样的，在建立闪电网络的时候，我们同样会遇到信任问题：Alice想转给Carol 1个BTC，需要经过Bob，但Bob会担心自己给Carol转1BTC后，Alice耍赖；同样Alice会担心如果先给Bob转了1BTC，Bob也耍赖不转给Alice。在传统的金融系统中，是由大型知名金融中介机构的信用提供保证的。但闪电网络中，并没有这样一个独立于交易者的第三方去提供信用担保。</p>
<p>闪电网络采用了一种HTLC(哈希时间锁定合约)完美解决了这个问题。</p>
<p><img src="https://img-blog.csdnimg.cn/20190505214818498.jpg" alt="在这里插入图片描述"></p>
<p>过程是这样的，第一，Carol会选择一个随机密文并运算得到其哈希值，再将此哈希值交给Alice。第二，Alice拿到哈希值后，会构建一笔转账给Bob的交易。这笔交易需要Bob拿到Carol的密文才能解锁，如果Bob在限定的时间内没有解锁成功，这笔钱则退回给Alice。第三，Bob从Alice处拿到哈希值，他也构建一笔转账给Carol的交易，Carol必须拿密文来解锁。第四，当Carol提供密文从Bob处获得1个BTC，Bob立马会拿密文从Alice处获得1个BTC，这就完成了从Alice给Carol转账的任务。</p>
<p><strong>上述过程可以看作一个智能合约。故事类似于这样：A想经过B转账给C，那么C先给A一把锁，C有钥匙A有钱。A跟B说，你从C那里拿到了钥匙，我的钱就是你的了。B就拿着锁去找C，用钱跟C换钥匙，然后拿钥匙去换A的钱。如此一来，就实现了钱和锁从A到B再到C，钥匙从C到B再到A的一个流转。</strong></p>
<p>当然，在实际操作过程中，Alice给Bob转账金额需要大于1个BTC，支付必要的路由费以激励Bob充当路由节点。<strong>其次，要注意两笔交易之间的哈希时间长度设置，第二步时间必须长于第三步时间。如果Bob在Alice关闭交易之后拿到Carol的钥匙，他将无法找Alice拿回1个BTC。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190505214923254.jpg" alt="在这里插入图片描述"></p>
<p>到这里，我们已经明白了闪电网络中通过路由节点达成交易的技巧，最后一步只需把之前两步整合进交易即可，就不再赘述了。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/0KeSq2w8VBoeMYALAoVc9g">原文链接</a><br><a target="_blank" rel="noopener" href="https://bitcoinmagazine.com/articles/understanding-the-lightning-network-part-building-a-bidirectional-payment-channel-1464710791/">Understanding the Lightning Network, Part 1</a><br><a target="_blank" rel="noopener" href="https://bitcoinmagazine.com/articles/understanding-the-lightning-network-part-creating-the-network-1465326903/">Understanding the Lightning Network, Part 2</a><br><a target="_blank" rel="noopener" href="https://bitcoinmagazine.com/articles/understanding-the-lightning-network-part-completing-the-puzzle-and-closing-the-channel-1466178980/">Understanding the Lightning Network, Part 3</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hzxgoforward.github.io/2019/02/21/EOS%E4%B8%AD%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuZhenXing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/21/EOS%E4%B8%AD%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="https://hzxgoforward.github.io/page/2/index.html">EOS中基本的数据结构解析</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建于：2019-02-21 18:48:14" itemprop="dateCreated datePublished" datetime="2019-02-21T18:48:14+08:00">2019-02-21</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="更新于：2023-03-05 20:02:33" itemprop="dateModified" datetime="2023-03-05T20:02:33+08:00">2023-03-05</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/" itemprop="url" rel="index"><span itemprop="name">区块链技术研究</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          


          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <span id="more"></span>
<p>本文用于记录对EOS源代码的阅读记录,对其相关内容从源代码中追踪问迹,希望从源代码入手,对其设计原理有一个深入的认识,也用于本人学习研究之用.<br>如果对EOS不太了解, 还需要对EOS顶层的内容有一些了解.这里推荐<a target="_blank" rel="noopener" href="https://github.com/EOSIO/Documentation">EOS的白皮书</a>进行了解学习. </p>
<p>对任何区块链相关技术的学习,首先应该从其区块的结构开始学起,因此,本文首先从区块源代码入手开始了解.</p>
<h1 id="EOS区块链相关数据结构"><a href="#EOS区块链相关数据结构" class="headerlink" title="EOS区块链相关数据结构"></a>EOS区块链相关数据结构</h1><h2 id="block-header"><a href="#block-header" class="headerlink" title="block header"></a><strong>block header</strong></h2><p>block header的定义,来自于”chain\webassembly\block_header.hpp”文件中,其主要结构如下:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">字段</th>
<th style="text-align:left">名称</th>
<th style="text-align:center">大小(Byte)</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">timestamp</td>
<td style="text-align:left">时间戳</td>
<td style="text-align:center">4</td>
<td style="text-align:center">生产区块的时间</td>
</tr>
<tr>
<td style="text-align:left">producer</td>
<td style="text-align:left">生产者</td>
<td style="text-align:center">8</td>
<td style="text-align:center">生产区块的超级节点</td>
</tr>
<tr>
<td style="text-align:left">confirmed</td>
<td style="text-align:left">确认数</td>
<td style="text-align:center">2</td>
<td style="text-align:center">区块的确认数</td>
</tr>
<tr>
<td style="text-align:left">transaction_mroot</td>
<td style="text-align:left">交易的Merkle Root</td>
<td style="text-align:center">32</td>
<td style="text-align:center">区块中全部交易的默克尔数的哈希值</td>
</tr>
<tr>
<td style="text-align:left">action_mroot</td>
<td style="text-align:left">action的Merkle Root</td>
<td style="text-align:center">32</td>
<td style="text-align:center">区块中全部action的默克尔数的哈希值</td>
</tr>
<tr>
<td style="text-align:left">schedule_version</td>
<td style="text-align:left">版本号</td>
<td style="text-align:center">4</td>
<td style="text-align:center">见证人排序版本号</td>
</tr>
<tr>
<td style="text-align:left">new_producers</td>
<td style="text-align:left">下一个见证人</td>
<td style="text-align:center">-</td>
<td style="text-align:center">区块的下一个见证人,可以为空</td>
</tr>
<tr>
<td style="text-align:left">header_extensions</td>
<td style="text-align:left">扩展类型</td>
<td style="text-align:center">-</td>
<td style="text-align:center">vector<std::pair<uint16_t,vector<char>&gt;&gt;</td>
</tr>
<tr>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
</div>
<p>具体对于block_header的结构代码，可以参看下述代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">block_header</span></span><br><span class="line">&#123;</span><br><span class="line">    block_timestamp_type             timestamp;</span><br><span class="line">    account_name                     producer;</span><br><span class="line">    <span class="type">uint16_t</span>                         confirmed = <span class="number">1</span>;  </span><br><span class="line">    block_id_type                    previous;</span><br><span class="line">    checksum256_type                 transaction_mroot; <span class="comment">/// mroot of cycles_summary</span></span><br><span class="line">    checksum256_type                 action_mroot; <span class="comment">/// mroot of all delivered action receipts</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span>                          schedule_version = <span class="number">0</span>;</span><br><span class="line">    optional&lt;producer_schedule_type&gt;  new_producers;</span><br><span class="line">    extensions_type                   header_extensions;</span><br><span class="line">    <span class="function">digest_type       <span class="title">digest</span><span class="params">()</span><span class="type">const</span></span>;   <span class="comment">// 求区块的摘要</span></span><br><span class="line">    <span class="function">block_id_type     <span class="title">id</span><span class="params">()</span> <span class="type">const</span></span>;      <span class="comment">// 获取区块id</span></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span>          <span class="title">block_num</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">num_from_id</span>(previous) + <span class="number">1</span>; &#125;     <span class="comment">//当前区块号 = 前一个区块号+1</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">uint32_t</span>   <span class="title">num_from_id</span><span class="params">(<span class="type">const</span> block_id_type&amp; id)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述区块是没有对区块进行签名的区块，对区块进行签名之后，区块数据结构是signed_block_header，具体代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">signed_block_header</span> : <span class="keyword">public</span> block_header</span><br><span class="line">&#123;</span><br><span class="line">   signature_type    producer_signature;<span class="comment">// 区块生产者的签名</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="block数据结构"><a href="#block数据结构" class="headerlink" title="block数据结构"></a>block数据结构</h2><p>EOS中block的数据结构如下,里面只有两个数据结构，即保存交易的vector和block_extensions。<br>block不能进行引用，只能进行复制。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">signed_block</span> : <span class="keyword">public</span> signed_block_header</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">   <span class="built_in">signed_block</span>(<span class="type">const</span> signed_block &amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">signed_block</span>() = <span class="keyword">default</span>;</span><br><span class="line">   <span class="function"><span class="keyword">explicit</span> <span class="title">signed_block</span><span class="params">(<span class="type">const</span> signed_block_header &amp;h)</span> : signed_block_header(h) &#123;</span>&#125;</span><br><span class="line">   <span class="built_in">signed_block</span>(signed_block &amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">   signed_block &amp;<span class="keyword">operator</span>=(<span class="type">const</span> signed_block &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">   <span class="function">signed_block <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">   vector&lt;transaction_receipt&gt; transactions; <span class="comment">/// new or generated transactions</span></span><br><span class="line">   extensions_type block_extensions;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Transaction-header数据结构"><a href="#Transaction-header数据结构" class="headerlink" title="Transaction_header数据结构"></a>Transaction_header数据结构</h2><p>transaction_header包含了固定大小的与每一笔交易都相关的一些数据，与transaction_body独立开来，这样在解析交易的时候不需要进行动态内存分配，这就加快了交易的解析过程。</p>
<p>所有的transaction都有一个截止时间，超过这个截止时间之后不会记录在链上，一旦某个区块的时间戳大于某个交易的截止时间，那么这个交易就永远不会包含在区块中。</p>
<p>其数据结构如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">transaction_header</span> &#123;</span><br><span class="line">   time_point_sec         expiration;   <span class="comment">///&lt; the time at which a transaction expires</span></span><br><span class="line">   <span class="type">uint16_t</span>               ref_block_num       = <span class="number">0U</span>; <span class="comment">///&lt; specifies a block num in the last 2^16 blocks. 2bytes</span></span><br><span class="line">   <span class="type">uint32_t</span>               ref_block_prefix    = <span class="number">0UL</span>; <span class="comment">///&lt; specifies the lower 32 bits of the blockid at get_ref_blocknum 区块号低4位的前缀 4bytes</span></span><br><span class="line">   fc::unsigned_int       max_net_usage_words = <span class="number">0UL</span>; <span class="comment">/// upper limit on total network bandwidth (in 8 byte words) billed for this transaction 4bytes</span></span><br><span class="line">   <span class="type">uint8_t</span>                max_cpu_usage_ms    = <span class="number">0</span>; <span class="comment">/// upper limit on the total CPU time billed for this transaction 1bytes</span></span><br><span class="line">   fc::unsigned_int       delay_sec           = <span class="number">0UL</span>; <span class="comment">/// number of seconds to delay this transaction for during which it may be canceled.4bytes</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="transaction"><a href="#transaction" class="headerlink" title="transaction"></a>transaction</h2><p>每一个transaction都包括了一系列的action，action中要么全部被执行，要么全部不执行，一个transaction的结构如下。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">transaction</span> : <span class="keyword">public</span> transaction_header &#123;</span><br><span class="line">   vector&lt;action&gt;         context_free_actions;</span><br><span class="line">   vector&lt;action&gt;         actions;</span><br><span class="line">   extensions_type        transaction_extensions;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="signed-transaction"><a href="#signed-transaction" class="headerlink" title="signed_transaction"></a>signed_transaction</h2><p>每一个signed_transaction继承于transaction，多了签名和一些其他数据，其数据结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">signed_transaction</span> : <span class="keyword">public</span> transaction</span><br><span class="line">&#123;</span><br><span class="line">   vector&lt;signature_type&gt;    signatures;<span class="comment">// 一笔交易可能需要多个签名</span></span><br><span class="line">   vector&lt;bytes&gt;             context_free_data; <span class="comment">///&lt; for each context-free action, there is an entry here</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="EOS中的操作-action"><a href="#EOS中的操作-action" class="headerlink" title="EOS中的操作(action)"></a>EOS中的操作(action)</h2><p>EOS区块链中的<strong>交易</strong>是由一个个<strong>操作</strong>组成的，操作可以理解成一个能够更改区块链全局状态的方法，操作的顺序是确定的，一个交易内的操作要么全部执行成功，要么都不执行，这与交易的本意(transaction)是一致的。操作是区块链的最底层逻辑，相当于区块链这个大脑的神经元，区块链的智能最终也是通过一个个操作的组合来实现的。</p>
<h2 id="操作的设计思路"><a href="#操作的设计思路" class="headerlink" title="操作的设计思路"></a>操作的设计思路</h2><h3 id="操作的来源"><a href="#操作的来源" class="headerlink" title="操作的来源"></a>操作的来源</h3><p>一个操作可以通过两种途径产生：</p>
<ul>
<li>由一个账号产生，通过签名来授权，即显性方式。</li>
<li>由代码生成，即隐形方式。</li>
</ul>
<h3 id="操作的底层逻辑"><a href="#操作的底层逻辑" class="headerlink" title="操作的底层逻辑"></a>操作的底层逻辑</h3><p>操作的设计遵循<a target="_blank" rel="noopener" href="https://github.com/facebook/flux/tree/master/examples/flux-concepts">React Flux设计模式</a>，简单的说就是每一个操作将会被赋予一个名称，然后被分发给一个或者多个handler。在EOS环境中，每个操作对应的handler是通过scope和name来定义的，默认的handler也可以再次将操作分发给下一级的多个handler。所以，每个EOS应用可以实现自己的handler，当操作被分发到这个应用时，相应的handler的代码就会被执行。</p>
<p>操作的设计思路中另一重要概念是授权。每一个操作的执行都必须确保具备了指定账户的授权。授权通过许可(permission)的方式声明，对于一个授权动作，账户可以要求任意数量的许可，许可的验证是独立于代码执行的，只有所有规定的许可被成功验证之后，对应的代码才能够被执行。</p>
<h3 id="操作的数据结构"><a href="#操作的数据结构" class="headerlink" title="操作的数据结构"></a>操作的数据结构</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">action</span> &#123;</span><br><span class="line">   account_name               account;<span class="comment">// 操作的来源</span></span><br><span class="line">   action_name                name;  <span class="comment">// 操作的名称</span></span><br><span class="line">   vector&lt;permission_level&gt;   authorization;<span class="comment">// 执行操作的许可列表</span></span><br><span class="line">   bytes                      data;<span class="comment">// 执行action需要用到的数据</span></span><br><span class="line">   ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>action中有一个permission_level，指的是权限级别一个账户可以将权限授予任意多个账户，同时每个账户可以有不同的权限名。权限级别的数据结构如下。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">permission_level</span> &#123;</span><br><span class="line">   account_name    actor;   <span class="comment">// 授予的账户名称</span></span><br><span class="line">   permission_name permission; <span class="comment">// 授予账户的权限</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>关于许可的相关内容,可以参看<a target="_blank" rel="noopener" href="https://github.com/BlockchainTranslator/EOS/blob/master/wiki/Accounts-%26-Permissions.md">账户和权限</a></p>
<h2 id="链控制器"><a href="#链控制器" class="headerlink" title="链控制器"></a>链控制器</h2><p>上述内容是内核的基本组成部分，如同一个机器的零部件，然而，要让机器运转起来，还需要把这些零部件串起来的控制中心，而链控制器(chain_controller)就是这个控制中心。下面我们来详细介绍EOS的链控制器。</p>
<h2 id="链控制器的基本功能"><a href="#链控制器的基本功能" class="headerlink" title="链控制器的基本功能"></a>链控制器的基本功能</h2><p>首先，我们需要理解链控制器存在的主要目的是作为外部世界与区块链内核之间的交互界面，所以它有着承上启下的作用，承上为支撑区块链与外部的交互，启下为管理区块链内部的状态变更。所以，从理解的不同角度，链控制器可以被理解为以下两个概念：</p>
<ul>
<li><p>从外部视角，链控制器是一个<strong>数据库</strong>，这与链外对区块链的理解是一致的，从狭义的角度看，区块链就像一个不可更改的数据库，而链控制器可以看做这个数据库的管家，外部世界不用直接与区块链底层通信，而是通过这个管家来与区块链交互。</p>
</li>
<li><p>从内部视角，链控制器是一个<strong>协调者</strong>，区块链内部各个部件均独立运作，这与上述的设计原则是一致的，这样的话，各个部件之间如何调度与协调，就需要一个有全局视角的角色来统一管理，这就是链控制器的第二个作用.<br>用作者的原话来说，链控制器的目的是以一种可以扩展的方式来<strong>跟踪区块链的状态变化</strong>。</p>
</li>
</ul>
<h2 id="链控制器的基本要素"><a href="#链控制器的基本要素" class="headerlink" title="链控制器的基本要素"></a>链控制器的基本要素</h2><p>为了维护可靠的区块链状态，链控制器管理着两个不用类型的数据库：</p>
<ol>
<li>区块日志。它的作用是存储已经经过验证的不可逆转的区块链主干。</li>
<li>块数据库 这是一个带索引的可以增删改查的数据库。它的作用是维护和管理未经验证的区块链主干与分支两个子数据库，主干数据库存储的是当前长度最长的一条链，而分支存储的是因为不同分叉而造成的分支链，随着时间的推移，主链是有可能被分支替代的，每当一个新的区块要写入时，EOS都会重新计算各分支和主干的长度，并且决定要不要切换主干。最后，执行错误或者验证不通过的区块最终会被抛弃，并从数据库中清理出去。</li>
</ol>
<p>除了存储部分，链控制器还需精确维护一个消息机制，以保证对区块链中的其他成员广播最新的区块状态变更，这个消息机制是区块链网络能够正常和自主运行的基础。</p>
<h2 id="事务处理机制"><a href="#事务处理机制" class="headerlink" title="事务处理机制"></a>事务处理机制</h2><p>熟悉数据库的读者一定知道，对于数据库的写入操作，维持一个事务的原子性是很关键的，也就是说，对于一批写入操作，要么全都成功执行，要么都不执行，一定不能出现只执行了其中一部分的情况，因为这样将导致数据的不一致性，这样的错误是致命的。EOS中对于块数据库的写操作采用同样的设计原则，事务的使用主要体现在两个层面：</p>
<ol>
<li><strong>区块</strong>. 整个区块的内容是一个整体，要么全都写入，要么都不写入</li>
<li><strong>交易</strong>. 一个交易是一个整体，其中的操作要么都执行，要么都不执行<br>当事务中的某个步骤出现错误时，整个事务就会启动回滚机制，整个区块链将会恢复到这个事务发生之前的状态。</li>
</ol>
<h2 id="链控制器的主要过程"><a href="#链控制器的主要过程" class="headerlink" title="链控制器的主要过程"></a>链控制器的主要过程</h2><ul>
<li>链控制器的初始化<br>链控制器的初始化是区块的起点,它的核心过程如下所示:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">   <span class="built_in">controller_impl</span>( <span class="type">const</span> controller::config&amp; cfg, controller&amp; s  )</span><br><span class="line">   :<span class="built_in">self</span>(s),</span><br><span class="line">    <span class="built_in">db</span>( cfg.state_dir,</span><br><span class="line">        cfg.read_only ? database::read_only : database::read_write,</span><br><span class="line">        cfg.state_size ),</span><br><span class="line">    <span class="built_in">reversible_blocks</span>( cfg.blocks_dir/config::reversible_blocks_dir_name,</span><br><span class="line">        cfg.read_only ? database::read_only : database::read_write,</span><br><span class="line">        cfg.reversible_cache_size ),</span><br><span class="line">    <span class="built_in">blog</span>( cfg.blocks_dir ),</span><br><span class="line">    fork_db( cfg.state_dir ),</span><br><span class="line">    <span class="built_in">wasmif</span>( cfg.wasm_runtime ),</span><br><span class="line">    <span class="built_in">resource_limits</span>( db ),</span><br><span class="line">    <span class="built_in">authorization</span>( s, db ),</span><br><span class="line">    <span class="built_in">conf</span>( cfg ),</span><br><span class="line">    <span class="built_in">chain_id</span>( cfg.genesis.<span class="built_in">compute_chain_id</span>() ),</span><br><span class="line">    <span class="built_in">read_mode</span>( cfg.read_mode ),</span><br><span class="line">    <span class="built_in">thread_pool</span>( cfg.thread_pool_size )</span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SET_APP_HANDLER( receiver, contract, action) \</span></span><br><span class="line"><span class="meta">   set_apply_handler( #receiver, #contract, #action, &amp;BOOST_PP_CAT(apply_, BOOST_PP_CAT(contract, BOOST_PP_CAT(_,action) ) ) )</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">SET_APP_HANDLER</span>( eosio, eosio, newaccount );</span><br><span class="line">   <span class="built_in">SET_APP_HANDLER</span>( eosio, eosio, setcode );</span><br><span class="line">   <span class="built_in">SET_APP_HANDLER</span>( eosio, eosio, setabi );</span><br><span class="line">   <span class="built_in">SET_APP_HANDLER</span>( eosio, eosio, updateauth );</span><br><span class="line">   <span class="built_in">SET_APP_HANDLER</span>( eosio, eosio, deleteauth );</span><br><span class="line">   <span class="built_in">SET_APP_HANDLER</span>( eosio, eosio, linkauth );</span><br><span class="line">   <span class="built_in">SET_APP_HANDLER</span>( eosio, eosio, unlinkauth );</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   SET_APP_HANDLER( eosio, eosio, postrecovery );</span></span><br><span class="line"><span class="comment">   SET_APP_HANDLER( eosio, eosio, passrecovery );</span></span><br><span class="line"><span class="comment">   SET_APP_HANDLER( eosio, eosio, vetorecovery );</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">SET_APP_HANDLER</span>( eosio, eosio, canceldelay );</span><br><span class="line"></span><br><span class="line">   fork_db.irreversible.<span class="built_in">connect</span>( [&amp;]( <span class="keyword">auto</span> b ) &#123;</span><br><span class="line">                                 <span class="built_in">on_irreversible</span>(b);</span><br><span class="line">                                 &#125;);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hzxgoforward.github.io/2019/01/21/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuZhenXing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/21/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="https://hzxgoforward.github.io/page/2/index.html">算法设计模板总结</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建于：2019-01-21 09:48:18" itemprop="dateCreated datePublished" datetime="2019-01-21T09:48:18+08:00">2019-01-21</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="更新于：2023-03-05 20:01:42" itemprop="dateModified" datetime="2023-03-05T20:01:42+08:00">2023-03-05</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">算法设计与分析</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          


          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a>链表反转</h1><p>链表反转, 假设链表为a-&gt;b-&gt;…-&gt;n, 需要用反转a-&gt;b之前需要记录b的next指针,因此需要三个指针即可.</p>
<p>反转指针的写法有两种,递归法和循环法.</p>
<h2 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverseList</span>(<span class="literal">nullptr</span>, head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// tail是head的前一个节点,反转head</span></span><br><span class="line">    <span class="comment">// 最后返回反转后的头指针</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* tail, ListNode* head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> tail;</span><br><span class="line">        ListNode* next = head-&gt;next;	<span class="comment">// 记录head的下一个节点</span></span><br><span class="line">        head-&gt;next = tail;				<span class="comment">// head 指向tail</span></span><br><span class="line">        tail = head;					<span class="comment">// tail 作为head继续递归</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverseList</span>(tail, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="循环写法"><a href="#循环写法" class="headerlink" title="循环写法"></a>循环写法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;        <span class="comment">// 初始时head的前一个节点为空</span></span><br><span class="line">        ListNode* mid = head;</span><br><span class="line">        <span class="keyword">while</span>(mid&amp;&amp;mid-&gt;next)&#123;</span><br><span class="line">            ListNode* tail = mid-&gt;next;     <span class="comment">// 记录mid的下一个节点</span></span><br><span class="line">            mid-&gt;next = pre;</span><br><span class="line">            pre = mid;</span><br><span class="line">            mid = tail;</span><br><span class="line">        &#125;</span><br><span class="line">        mid-&gt;next = pre;				<span class="comment">// pre始终是mid的前一个节点,循环结束后mid指向pre</span></span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="回文链表判断"><a href="#回文链表判断" class="headerlink" title="回文链表判断"></a>回文链表判断</h2><ul>
<li>第一步,找到链表的中间节点</li>
<li>第二步,反转起始节点到中间节点的这部分链表</li>
<li>从中间节点向两边扩散,检查是否为回文链表</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        ListNode *tail = head-&gt;next;</span><br><span class="line">        ListNode *mid = head;</span><br><span class="line">        <span class="type">bool</span> odd = <span class="literal">false</span>;		<span class="comment">// odd 判断链表长度是否为奇数</span></span><br><span class="line">        <span class="keyword">while</span> (tail &amp;&amp; tail-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">            mid = mid-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (tail &amp;&amp; tail-&gt;next)</span><br><span class="line">            &#123;</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">                odd = <span class="literal">false</span>;		<span class="comment">// tail一次能走两步,是偶数长度的链表</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                odd = <span class="literal">true</span>;			<span class="comment">// 链表这一次走一步就到了尾部,是奇数长度的链表</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *right = mid-&gt;next;	<span class="comment">// 记录mid中间节点的下一个节点</span></span><br><span class="line">        ListNode *left = <span class="built_in">reverse</span>(head, mid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (odd)</span><br><span class="line">            left = left-&gt;next;			<span class="comment">// 如果是奇数链表,左边链表左边走一位</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 中间到两边开始判断,是否为回文链表</span></span><br><span class="line">        <span class="keyword">while</span> (right &amp;&amp; left)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (right-&gt;val != left-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            right = right-&gt;next;</span><br><span class="line">            left = left-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (!left &amp;&amp; !right)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转head到tail部分的链表</span></span><br><span class="line">    <span class="function">ListNode *<span class="title">reverse</span><span class="params">(ListNode *head, ListNode *till)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *mid = head;</span><br><span class="line">        <span class="keyword">while</span> (mid != till &amp;&amp; mid-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *tail = mid-&gt;next;</span><br><span class="line">            mid-&gt;next = pre;</span><br><span class="line">            pre = mid;</span><br><span class="line">            mid = tail;</span><br><span class="line">        &#125;</span><br><span class="line">        mid-&gt;next = pre;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="快速排序-分治法"><a href="#快速排序-分治法" class="headerlink" title="快速排序(分治法)"></a>快速排序(分治法)</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> base = nums[left];</span><br><span class="line">	<span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">		<span class="keyword">while</span>(left&lt;right&amp;&amp;nums[right]&gt;base)</span><br><span class="line">			right--;</span><br><span class="line">		nums[left] = nums[right];</span><br><span class="line">		<span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left]&lt;=base)</span><br><span class="line">			++left;</span><br><span class="line">		nums[right] = nums[left];</span><br><span class="line">	&#125;</span><br><span class="line">	nums[left] = base;</span><br><span class="line">	<span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums,<span class="type">const</span> <span class="type">int</span> left, <span class="type">const</span> <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">		<span class="type">int</span> index = <span class="built_in">partition</span>(nums, left, right);</span><br><span class="line">		<span class="built_in">quickSort</span>(nums, left, index);</span><br><span class="line">		<span class="built_in">quickSort</span>(nums, index+<span class="number">1</span>, right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="归并排序-分治法"><a href="#归并排序-分治法" class="headerlink" title="归并排序(分治法)"></a>归并排序(分治法)</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">mergeSort</span><span class="params">(VI&amp; nums, <span class="type">const</span> <span class="type">int</span> low, <span class="type">const</span> <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">	LL ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (high &lt;= low)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (high - low == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nums[low] &gt; nums[high]) &#123;</span><br><span class="line">			<span class="built_in">swap</span>(nums[low], nums[high]);</span><br><span class="line">			ans++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">	LL left = <span class="built_in">mergeSort</span>(nums, low, mid);</span><br><span class="line">	LL right = <span class="built_in">mergeSort</span>(nums, mid + <span class="number">1</span>, high);</span><br><span class="line">	ans = left + right;</span><br><span class="line">	</span><br><span class="line">	<span class="function">VI <span class="title">leftNums</span><span class="params">(nums.begin() + low, nums.begin() + mid + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="function">VI <span class="title">rightNums</span><span class="params">(nums.begin() + mid + <span class="number">1</span>, nums.begin() + high + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, index = low;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; leftNums.<span class="built_in">size</span>() &amp;&amp; j &lt; rightNums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (leftNums[i] &lt;= rightNums[j])</span><br><span class="line">			nums[index++] = leftNums[i++];</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			nums[index++] = rightNums[j++];</span><br><span class="line">			ans += leftNums.<span class="built_in">size</span>() - i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; leftNums.<span class="built_in">size</span>())</span><br><span class="line">		nums[index++] = leftNums[i++];</span><br><span class="line">	<span class="keyword">while</span> (j &lt; rightNums.<span class="built_in">size</span>())</span><br><span class="line">		nums[index++] = rightNums[j++];</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="数组中逆序对个数-分治法"><a href="#数组中逆序对个数-分治法" class="headerlink" title="数组中逆序对个数(分治法)"></a>数组中逆序对个数(分治法)</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int64_t</span> <span class="title">reverseNum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> low, <span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">	<span class="type">uint64_t</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(low&gt;=high)</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(high - low == <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(nums[low]&gt;nums[high])&#123;</span><br><span class="line">			<span class="built_in">swap</span>(nums[low], nums[high]);</span><br><span class="line">			++ans;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = low + (high-low)/<span class="number">2</span>;</span><br><span class="line">	<span class="type">int64_t</span> left = <span class="built_in">reverseNum</span>(nums, low, mid);</span><br><span class="line">	<span class="type">int64_t</span> right = <span class="built_in">reverseNum</span>(nums, mid+<span class="number">1</span>, high);</span><br><span class="line">	ans += left + right;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftNums</span><span class="params">(nums.begin()+low, nums.begin()+mid+<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightNums</span><span class="params">(nums.begin()+mid+<span class="number">1</span>, nums.begin()+high+<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, index = low;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>( i&lt;leftNums.<span class="built_in">size</span>() &amp;&amp; j&lt; rightNums.<span class="built_in">size</span>() )&#123;</span><br><span class="line">		<span class="keyword">if</span>(leftNums[i]&lt;=rightNums[j])</span><br><span class="line">			nums[index++] = leftNums[i++];</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			nums[index++] = rightNums[j++];</span><br><span class="line">			ans += leftNums.<span class="built_in">size</span>()-i;	<span class="comment">// </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;leftNums.<span class="built_in">size</span>())</span><br><span class="line">		nums[index++] = leftNums[i++];</span><br><span class="line">	<span class="keyword">while</span>(j&lt;rightNums.<span class="built_in">size</span>())</span><br><span class="line">		nums[index++] = rightNums[j++];</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="平面最近点对-分治法"><a href="#平面最近点对-分治法" class="headerlink" title="平面最近点对(分治法)"></a>平面最近点对(分治法)</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">minDistance</span><span class="params">(vector&lt;Point&gt;&amp; points, CI low, CI high)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (low &gt;= high)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (low == high - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">double</span> dis = <span class="built_in">distance</span>(points[low], points[high]);</span><br><span class="line">		<span class="keyword">if</span> (points[low].y &gt; points[high].y)</span><br><span class="line">			<span class="built_in">swap</span>(points[low], points[high]);</span><br><span class="line">		<span class="keyword">return</span> dis;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> middle = points[mid].x;</span><br><span class="line">	<span class="type">double</span> left = <span class="built_in">minDistance</span>(points, low, mid);</span><br><span class="line">	<span class="type">double</span> right = <span class="built_in">minDistance</span>(points, mid, high);</span><br><span class="line">	<span class="type">double</span> ans = <span class="built_in">min</span>(left, right);</span><br><span class="line">	<span class="keyword">auto</span> f = [](<span class="type">const</span> Point&amp; p1, <span class="type">const</span> Point&amp; p2)-&gt;<span class="type">bool</span> &#123;<span class="keyword">return</span> p1.y &lt; p2.y; &#125;;</span><br><span class="line">	<span class="built_in">sort</span>(points.<span class="built_in">begin</span>() + low, points.<span class="built_in">begin</span>() + high + <span class="number">1</span>, f);</span><br><span class="line">	vector&lt;Point&gt; tmp;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = low; i &lt; high; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">abs</span>(points[i].x - middle) &lt;= ans)</span><br><span class="line">			tmp.<span class="built_in">emplace_back</span>(points[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tmp.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; <span class="built_in">min</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(tmp.<span class="built_in">size</span>()), i + <span class="number">12</span>); ++j)</span><br><span class="line">			ans = <span class="built_in">min</span>(ans, <span class="built_in">distance</span>(tmp[i], tmp[j]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; sz; <span class="comment">// 表示每个集合的大小</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; parent; <span class="comment">// 表示每个顶点最终的父节点</span></span><br><span class="line">                        <span class="comment">// 初始化每个顶点父节点是其自身</span></span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">const</span> <span class="type">int</span> n)&#123;</span><br><span class="line">        sz.<span class="built_in">assign</span>(n, <span class="number">1</span>);</span><br><span class="line">        cnt = n;</span><br><span class="line">        parent.<span class="built_in">resize</span>(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找某个节点的父亲节点,注意返回值不能是 bool类型，必须是整数类型</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x!=parent[x])</span><br><span class="line">            parent[x] = <span class="built_in">find</span>(parent[x]);</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个节点</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">merge</span><span class="params">(<span class="type">const</span> <span class="type">int</span> x, <span class="type">const</span> <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> px = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="type">int</span> py = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(px==py)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(sz[px]&gt;=sz[py])&#123;</span><br><span class="line">            sz[px]+=sz[py];</span><br><span class="line">            parent[py] = px;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sz[py]+=sz[px];</span><br><span class="line">            parent[px] = py;</span><br><span class="line">        &#125;</span><br><span class="line">        --cnt;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCnt</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> cnt;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="prime-算法"><a href="#prime-算法" class="headerlink" title="prime 算法"></a>prime 算法</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;VI&gt; VVI;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">double</span>&gt; VD;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;VD&gt; VVD;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边的定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">	<span class="type">int</span> from, to;</span><br><span class="line">	<span class="type">double</span> dis;</span><br><span class="line">	<span class="built_in">Edge</span>(CI f, CI t, CD d) :<span class="built_in">from</span>(f), <span class="built_in">to</span>(t), <span class="built_in">dis</span>(d) &#123;&#125;;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Edge&amp; e)<span class="type">const</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;dis &gt; e.dis; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图用邻接矩阵存储的Prime算法</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">MST</span><span class="params">(<span class="type">const</span> VVD&amp; graph)</span> </span>&#123;</span><br><span class="line">	<span class="type">double</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="function">VI <span class="title">visit</span><span class="params">(graph.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">	priority_queue&lt;Edge&gt; myQueue;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		myQueue.<span class="built_in">emplace</span>(<span class="number">0</span>, i, graph[<span class="number">0</span>][i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">VD <span class="title">dis</span><span class="params">(graph[<span class="number">0</span>])</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (!myQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		Edge e = myQueue.<span class="built_in">top</span>();</span><br><span class="line">		myQueue.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span> (visit[e.to] == <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		visit[e.to] = <span class="number">1</span>;</span><br><span class="line">		ans += e.dis;</span><br><span class="line">		dis[e.to] = e.dis;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph.<span class="built_in">size</span>(); ++i)</span><br><span class="line">			<span class="keyword">if</span> (visit[i] == <span class="number">0</span> &amp;&amp; graph[e.to][i] &lt; dis[i])</span><br><span class="line">				myQueue.<span class="built_in">emplace</span>(e.to, i, graph[e.to][i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="kruskal算法-贪心法"><a href="#kruskal算法-贪心法" class="headerlink" title="kruskal算法(贪心法)"></a>kruskal算法(贪心法)</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 边的定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">	<span class="type">int</span> from, to;</span><br><span class="line">	<span class="type">double</span> dis;</span><br><span class="line">	<span class="built_in">Edge</span>(CI f, CI t, CD d) :<span class="built_in">from</span>(f), <span class="built_in">to</span>(t), <span class="built_in">dis</span>(d) &#123;&#125;;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Edge&amp; e)<span class="type">const</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;dis &lt; e.dis; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kruskal算法,需要用到并查集</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">MST</span><span class="params">(<span class="type">const</span> vector&lt;Edge&gt; edgeVec,<span class="type">const</span> <span class="type">int</span> vertex)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">sort</span>(edgeVec.<span class="built_in">begin</span>(), edgeVec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="function">QuickUnion <span class="title">qu</span><span class="params">(vertex)</span></span>;</span><br><span class="line">    <span class="type">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> edgCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;e :edgeVec)&#123;</span><br><span class="line">        <span class="keyword">if</span>(qu.<span class="built_in">merge</span>(e.from, e.to))&#123;</span><br><span class="line">            ans += e.dis;</span><br><span class="line">            edgCnt++;</span><br><span class="line">            <span class="keyword">if</span>(edgCnt==vertex<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="dijkstra算法-贪心法"><a href="#dijkstra算法-贪心法" class="headerlink" title="dijkstra算法(贪心法)"></a>dijkstra算法(贪心法)</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;VI&gt; VVI;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边的定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">	<span class="type">int</span> from, to;</span><br><span class="line">	<span class="type">int</span> dis;</span><br><span class="line">	<span class="built_in">Edge</span>(CI f, CI t, CD d) :<span class="built_in">from</span>(f), <span class="built_in">to</span>(t), <span class="built_in">dis</span>(d) &#123;&#125;;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Edge&amp; e)<span class="type">const</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;dis &gt; e.dis; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图用邻接矩阵存储的, 优先级队列实现,,计算start到target的最近距离</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">(<span class="type">const</span> VVI&amp; graph, <span class="type">const</span> <span class="type">int</span> start, <span class="type">const</span> <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="function">VI <span class="title">dis</span><span class="params">(graph.size(), INT_MAX)</span></span>;</span><br><span class="line">	dis[start] = <span class="number">0</span>;</span><br><span class="line">	<span class="function">VI <span class="title">visit</span><span class="params">(graph.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">	priority_queue&lt;Edge&gt; myQueue;</span><br><span class="line">	myQueue.<span class="built_in">emplace</span>(start, start, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">while</span>(!myQueue.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		Edge e = myQueue.<span class="built_in">top</span>();</span><br><span class="line">		myQueue.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(visit[e.to]==<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		visit[e.to] = <span class="number">1</span>;</span><br><span class="line">		dis[e.to]= e.dis;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;graph.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">			<span class="keyword">if</span>( visit[i]==<span class="number">0</span> &amp;&amp; dis[i]- graph[e.to][i]&gt; dis[e.to])</span><br><span class="line">				myQueue.<span class="built_in">emplace</span>(e.to, i, dis[e.to]+ graph[e.to][i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dis[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="spfa-动态规划"><a href="#spfa-动态规划" class="headerlink" title="spfa(动态规划)"></a>spfa(动态规划)</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;VI&gt; VVI;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图用邻接矩阵存储, 队列实现的spfa算法,计算start到target的最近距离</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">(<span class="type">const</span> VVI&amp; graph, <span class="type">const</span> <span class="type">int</span> start, <span class="type">const</span> <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dis</span><span class="params">(graph.size(), INT_MAX)</span></span>;</span><br><span class="line">	dis[start] = <span class="number">0</span>;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; myQueue;</span><br><span class="line">	<span class="function">VI <span class="title">enqueue</span><span class="params">(graph.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">	myQueue.<span class="built_in">push</span>(start);</span><br><span class="line">	enqueue[start] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!myQueue.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> topNode = myQueue.<span class="built_in">front</span>();</span><br><span class="line">		myQueue.<span class="built_in">pop</span>();</span><br><span class="line">		enqueue[topNode] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;graph.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(dis[i]- graph[topNode][i]&gt; dis[topNode])&#123;</span><br><span class="line">				dis[i] = dis[topNode]+graph[topNode][i];</span><br><span class="line">				<span class="keyword">if</span>(enqueue[i]==<span class="number">0</span>)&#123;</span><br><span class="line">					myQueue.<span class="built_in">emplace</span>(i);</span><br><span class="line">					enqueue[i] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dis[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hzxgoforward.github.io/2019/01/14/POJ%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuZhenXing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/14/POJ%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB/" class="post-title-link" itemprop="https://hzxgoforward.github.io/page/2/index.html">POJ算法题目分类</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建于：2019-01-14 00:47:00" itemprop="dateCreated datePublished" datetime="2019-01-14T00:47:00+08:00">2019-01-14</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="更新于：2023-03-05 20:05:48" itemprop="dateModified" datetime="2023-03-05T20:05:48+08:00">2023-03-05</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">算法设计与分析</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          


          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1><ul>
<li><p><a target="_blank" rel="noopener" href="http://bailian.openjudge.cn/practice/2255/">重建二叉树</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/2016finalex/C/">由中根序列和后根序列重建二叉树</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://bailian.openjudge.cn/practice/2388/">寻找中位数</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://bailian.openjudge.cn/practice/2299/">Ultra-QuickSort</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/betaexam/D/">逆序对数</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/2016final/E/">重要逆序对</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/2018test3/A/">平面最近点对</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/algorithmc/B/">Raid</a></p>
</li>
</ul>
<h1 id="贪心法"><a href="#贪心法" class="headerlink" title="贪心法"></a>贪心法</h1><ul>
<li><p><a target="_blank" rel="noopener" href="http://bailian.openjudge.cn/practice/4080/">Huffman编码树</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://bailian.openjudge.cn/practice/1042/">Gone Fishing</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/2016final/D/">Agri-Net</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://bailian.openjudge.cn/practice/1328/">Radar Installation</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/exfinalsim/6/">Stripies</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/exfinalsim/7/">Arctic Network</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/algorithma/C/">Til the Cows Come Home</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/algorithmb/C/">Yogurt Factory</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/algorithmb/D/">The Unique MST</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/algorithmb/E/">Subway</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/2017mock/G/">昂贵的聘礼</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/final2017/E/">Building an Space Station</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/final2017/D/">Checking An Alibi</a></p>
</li>
</ul>
<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><ul>
<li><a target="_blank" rel="noopener" href="http://bailian.openjudge.cn/practice/1321/">棋盘问题</a></li>
</ul>
<h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><ul>
<li><p><a target="_blank" rel="noopener" href="http://bailian.openjudge.cn/practice/1094/">Sorting It All Out</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/algorithmb/F/">All Discs Considered</a></p>
</li>
</ul>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><ul>
<li><p><a target="_blank" rel="noopener" href="http://bailian.openjudge.cn/practice/1163/">The Trangle</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://bailian.openjudge.cn/practice/1088/">滑雪</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://bailian.openjudge.cn/practice/1050/">To the Max</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://bailian.openjudge.cn/practice/1952/">BUY LOW,BUY LOWER</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://bailian.openjudge.cn/practice/2479/">Maximum sum</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://bailian.openjudge.cn/practice/1384/">Piggy-Bank</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://bailian.openjudge.cn/practice/1797/">Heavy Transportation</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://bailian.openjudge.cn/practice/4121/">股票买卖</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://bailian.openjudge.cn/practice/1860/">Currency Exchange</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/2018test3/B/">合唱队形</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/2018test3/C/">公共子序列</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://bailian.openjudge.cn/practice/1191/">棋盘分割</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/201804/D/">Multiplication Puzzle</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/exfinalsim/5/">Arbitrage</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/algorithmc/C/">Longest Ordered Subsequence</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/algorithmc/D/">Common Subsequence</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/algorithmc/F/">LITTLE SHOP OF FLOWERS</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/2017mock/A/">To Europe！To Europe!</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/2017mock/D/">Palindrome</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/final2017/C/">怪盗基德的滑翔翼</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/final2017/F/">Charm Bracelet</a></p>
</li>
</ul>
<h1 id="深搜、广搜"><a href="#深搜、广搜" class="headerlink" title="深搜、广搜"></a>深搜、广搜</h1><ul>
<li><p><a target="_blank" rel="noopener" href="http://bailian.openjudge.cn/practice/1979/">Red and Black</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://bailian.openjudge.cn/practice/2251/">Dungeon Master</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/algorithma/D/">仙岛求药</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/final2017/B/">抓住那头牛</a></p>
</li>
</ul>
<h1 id="二分匹配"><a href="#二分匹配" class="headerlink" title="二分匹配"></a>二分匹配</h1><ul>
<li><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/betaexam/B/">Butterfly</a></li>
</ul>
<h1 id="堆考察"><a href="#堆考察" class="headerlink" title="堆考察"></a>堆考察</h1><ul>
<li><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/betaexam/C/">Dynamic Median</a></li>
</ul>
<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><ul>
<li><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/201802/C/">Percolation</a></li>
</ul>
<h1 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h1><ul>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/201804/A/">Drainage Ditches</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/201804/B/">Dining</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/201804/C/">Dual Core CPU</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/201804/F/">Destroying the bus stations</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/exfinalsim/8/">Firing</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/algorithmd/D/">The Perfect Stall</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/2017mock/F/">Jamie’s Contact Groups</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/2017mock/H/">最小路径覆盖</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/final2017/G/">Gopher II</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/final2017/H/">Secret Milking Machine</a></p>
</li>
</ul>
<h1 id="最大值最小问题"><a href="#最大值最小问题" class="headerlink" title="最大值最小问题"></a>最大值最小问题</h1><ul>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/exfinalsim/3/">月度开销</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/2017mock/F/">Jamie’s Contact Groups</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://algorithm.openjudge.cn/final2017/H/">Secret Milking Machine</a></p>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hzxgoforward.github.io/2019/01/10/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E7%9A%84%E7%90%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuZhenXing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/10/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E7%9A%84%E7%90%86%E8%A7%A3/" class="post-title-link" itemprop="https://hzxgoforward.github.io/page/2/index.html">逻辑回归的理解</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建于：2019-01-10 15:11:03" itemprop="dateCreated datePublished" datetime="2019-01-10T15:11:03+08:00">2019-01-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="更新于：2023-03-05 20:01:10" itemprop="dateModified" datetime="2023-03-05T20:01:10+08:00">2023-03-05</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          


          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="逻辑回归-Logistic-Regression"><a href="#逻辑回归-Logistic-Regression" class="headerlink" title="逻辑回归(Logistic Regression)"></a>逻辑回归(Logistic Regression)</h2><h3 id="1-回归-Regression"><a href="#1-回归-Regression" class="headerlink" title="1. 回归(Regression)"></a>1. 回归(Regression)</h3><ul>
<li><p>回归，我的理解来说，其直观的理解就是拟合的意思。我们以线性回归为例子，在二维平面上有一系列红色的点，我们想用一条直线来尽量拟合这些红色的点，这就是线性回归。回归的本质就是我们的预测结果尽量贴近实际观测的结果，或者说我们的求得一些参数，经过计算之后的预测结果尽可能接近真实值。<br><center> <image src="https://i.imgur.com/la7bDLS.jpg" width = 50% ></image></center></p>
<h3 id="2-逻辑回归的由来"><a href="#2-逻辑回归的由来" class="headerlink" title="2. 逻辑回归的由来"></a>2. 逻辑回归的由来</h3></li>
<li><p>对于二类线性可分的数据集，使用线性感知器就可以很好的分类。如下图中红色和蓝色的点，我们使用一条直线$x_1 +x_2 = 3$就可以区分两种数据集，在直线上方的属于红色类，直线下方的属于蓝色类。</p>
<center> <image src="https://i.imgur.com/uPQ0xxk.jpg"></image></center></li>
<li>但是如果二类线性不可分的数据集，我们无法找到一条直线能够将两种类别很好的区分，即线性回归的分类法对于线性不可分的数据无法有效分类。例如下图中的红色点和蓝色点，我们无法使用一条直线很好的区分这两类，但是我们可以使用非线性分类器，如果我们使用${x_1}^2+{x_2}^2 = 1$，在圆外面的为红色类，在圆里面的一类为蓝色类。</li>
</ul>
<center> <image src="https://i.imgur.com/TdJn8NO.jpg" ></image></center>
- 诚然，数据线性可分可以使用线性分类器，如果数据线性不可分，可以使用非线性分类器，这里似乎没有逻辑回归什么事情。但是如果我们想知道对于一个二类分类问题，对于具体的一个样例，我们不仅想知道该类属于某一类，而且还想知道该类属于某一类的概率多大,有什么办法呢？

- 线性回归和非线性回归的分类问题都不能给予解答，因为线性回归和非线性回归的问题，假设其分类函数如下：
                              $$ y = wx+b $$   

- y的阈值处于$（-\infty，+\infty）$，此时不能很好的给出属于某一类的概率，因为概率的范围是[0,1],我们需要一个更好的映射函数，能够将分类的结果很好的映射成为[0,1]之间的概率，并且这个函数能够具有很好的可微分性。在这种需求下，人们找到了这个映射函数，即逻辑斯谛函数，也就是我们常说的sigmoid函数，其形式如下：


   $$\frac{1}{1+e^{-z} }$$   

- sigmoid函数图像如下图所示

<center> <image src="https://i.imgur.com/T53inQT.png" width = 50% ></image></center>

<ul>
<li>sigmoid函数完美的解决了上述需求，而且sigmoid函数连续可微分。</li>
<li>假设数据离散二类可分，分为0类和1类,如果概率值大于1/2，我们就将该类划分为1类，如果概率值低于1/2,我们就将该类划分为0类。当z取值为0的时候，概率值为1/2，这时候需要人为规定划分为哪一类。</li>
</ul>
<p><h3>3. 逻辑回归的损失函数(Loss Function)和成本函数(Cost Function)<h3></p>
<ul>
<li><p>在二类分类中，我们假定sigmoid输出结果表示属于1类的概率值，我们很容易想到用平方损失函数，即</p>
<center>
<image src="https://i.imgur.com/3C1RzcD.jpg " widh = 50% height=80></image>
</center>
</li>
<li><p>在这种情况下，我们φ(z(i))表示sigmoid对第i个值的预测结果，我们将sigmoid函数带入上述成本函数中，绘制其图像，发现这个成本函数的函数图像是一个非凸函数，如下图所示，这个函数里面有很多极小值，如果采用梯度下降法，则会导致陷入局部最优解中,有没有一个凸函数的成本函数呢？</p>
<center>
<image src = "https://i.imgur.com/R5r6LvC.jpg " width = 50%></image>
</center>
</li>
<li><p>假设sigmoid函数φ(z)表示属于1类的概率，于是做出如下的定义：</p>
<center><image src=" https://i.imgur.com/IBlS1zQ.jpg"></image></center>
</li>
<li><p>将两个式子综合来，可以改写为下式：</p>
<center>
<image src="https://i.imgur.com/KdpNVpf.jpg"></image></center>
</li>
<li><p>上式将分类为0和分类和1的概率计算公式合二为一。假设分类器分类足够准确，此时对于一个样本，如果它是属于1类，分类器求出的属于1类的概率应该尽可能大，即p(y=1lx)尽可能接近1；如果它是0类，分类器求出的属于0类的概率应该尽可能大，即p(y=0lx)尽可能接近1。</p>
</li>
<li><p>通过上述公式对二类分类的情况分析，可知我们的目的是求取参数w和b，使得p(ylx)对0类和1类的分类结果尽可能取最大值，然而实际上我们定义的损失函数的是求最小值，于是，很自然的，我们想到对p(ylx)式子加一个负号，就变成了求最小值的问题，这就得到了逻辑回归中的损失函数。</p>
</li>
<li><p>不过，为了计算方便，我们通常对上述式子取log，因而得到下式：</p>
</li>
</ul>
<center>
<image src="https://i.imgur.com/Swgjn66.jpg " width =50%></image></center>

<ul>
<li>公式(1)是对概率公式取log，公式(2)是对公式(1)取相反数。上述公式的函数图像如下图所示。这是一个凸函数（斜率是非单调递减的函数即凸函数），因此可以用梯度下降法求其最小值。</li>
</ul>
<p><image src="https://i.imgur.com/CAHBRdg.jpg "></image>&lt;/center&gt;</p>
<ul>
<li>根据损失函数是单个样本的预测值和实际值的误差，而成本函数是全部样本的预测值和实际值之间的误差，于是对所有样本的损失值取平均数，得到我们的成本函数：</li>
</ul>
<p><image src="https://i.imgur.com/cNXT1Ev.jpg"></image> &lt;/center&gt;</p>
<ul>
<li>损失函数是凸函数，m个损失函数的和仍然是凸函数，因而可以用梯度下降法求最小值。</li>
</ul>
<h3 id="4-极大似然法求解逻辑回归"><a href="#4-极大似然法求解逻辑回归" class="headerlink" title="4.极大似然法求解逻辑回归"></a>4.极大似然法求解逻辑回归</h3><ul>
<li>还可以用我们熟知的统计学知识——极大似然法估计逻辑回归中的参数w和b，上述得到的logp(y|w,x),假设目前有m组样本，分别为$(x_1,y_1),(x_2,y_2)…(x_m,y_m)$，其中xi表示第i个样本的特征，yi表示第i个样本的类别，yi = 0或者1，利用极大似然法的原则，假设所有训练样本独立同分布，则联合概率为所有样本概率的乘积，即：</li>
</ul>
<p><center><image src="https://i.imgur.com/kaGRRZc.jpg"></image></center></p>
<ul>
<li>对上述公式两边取对数，得到下述公式，是不是对这个公式优点熟悉呢？这个公式就是我们的成本函数的和，对于这个公式和成本函数来说，取平均值和不取平均值没有影响。</li>
</ul>
<p><center><image src="https://i.imgur.com/zHLnJJc.jpg"></image></center></p>
<ul>
<li>按照极大似然法求极值的方法，分别对w的每个参数求偏导数使其为0，得到对数似然方程组，求解该方程，便可以到的w的参数。只是如果参数很多，求解方程组就会很复杂，此时可以考虑梯度下降法来求解。</li>
</ul>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><ul>
<li><p>逻辑回归最大的优势在于它的输出结果不仅可以用于分类，还可以表征某个样本属于某类别的概率。</p>
</li>
<li><p>逻辑斯谛函数将原本输出结果从范围$（-\infty，+\infty）$ 映射到(0,1)，从而完成概率的估测。</p>
</li>
<li><p>逻辑回归得判定的阈值能够映射为平面的一条判定边界，随着特征的复杂化，判定边界可能是多种多样的样貌，但是它能够较好地把两类样本点分隔开，解决分类问题。</p>
</li>
<li><p>求解逻辑回归参数的传统方法是梯度下降，构造为凸函数的代价函数后，每次沿着偏导方向(下降速度最快方向)迈进一小部分，直至N次迭代后到达最低点。</p>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/han_xiaoyang/article/details/49123419">http://blog.csdn.net/han_xiaoyang/article/details/49123419</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/zjuPeco/article/details/77165974">http://blog.csdn.net/zjuPeco/article/details/77165974</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/star_liux/article/details/39666737">http://blog.csdn.net/star_liux/article/details/39666737</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hzxgoforward.github.io/2019/01/10/%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuZhenXing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/10/%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96/" class="post-title-link" itemprop="https://hzxgoforward.github.io/page/2/index.html">股票买卖</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建于：2019-01-10 14:16:27" itemprop="dateCreated datePublished" datetime="2019-01-10T14:16:27+08:00">2019-01-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="更新于：2023-03-05 20:03:09" itemprop="dateModified" datetime="2023-03-05T20:03:09+08:00">2023-03-05</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">算法设计与分析</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          


          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目来源：http-bailian-openjudge-cn-practice-4121"><a href="#题目来源：http-bailian-openjudge-cn-practice-4121" class="headerlink" title="题目来源：http://bailian.openjudge.cn/practice/4121/"></a>题目来源：<a target="_blank" rel="noopener" href="http://bailian.openjudge.cn/practice/4121/">http://bailian.openjudge.cn/practice/4121/</a></h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul>
<li>假设股票数组为prices</li>
<li>设F[k][i]表示到第i天总共买卖k次时的最大利润，可以将其分为两种情况，即第i天卖出股票和未卖出股票。</li>
<li>假如第i天没有卖出股票，F[k][i] = F[k][i-1]</li>
<li>假如第i天卖出了股票，那么F[k][i] = max{prices[i] - prices[t]+F[k-1][t]},为什么是这个推导公式，因为假如F[k][i]的最优解是，第x天是k-1次的卖出，随后的第y天又买入，第i天卖出，于是F[k][i] = F[k-1][x]+prices[i]- prices<a href="x&lt;= y &lt;=i">y</a>,此时必然有F[k-1][x] =F[k-1][y],证明如下：<ul>
<li>很显然，F[k-1][y]&gt;=F[k-1][x],假设F[k-1][y]&gt;F[k-1][x],此时必然有F[k-1][y]+prices[i]-prices[y]&gt;F[k][i] = F[k-1][x]+prices[i]- prices[y],这与最优解矛盾，因此必然有F[k-1][x] =F[k-1][y]，因此F[k][i]的推导公式可以写成max{prices[i] - prices[t]+F[k-1][t]}。</li>
</ul>
</li>
<li>对上述进行优化，max{prices[i] - prices[t]+F[k-1][t]} = prices[i] +max{F[k-1][t]-prices[t]}; (0&lt;=t&lt;=i-1), 对于确定的i和k，每次求max{F[k-1][t]-prices[t]}都需要对t从1到i进行遍历，于是可以在循环中，求解时用一个临时变量tmp记录max{F[k-1][t]-prices[t]},t属于[0,i-1]，每次i增量时比较tmp和F[k-1][i]-prices[i]和tmp的较大值赋给tmp,再进行求解。</li>
</ul>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><p>代码中nums即为解题思路中的prices<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;VI&gt; VVI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">int</span> CI;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solution</span><span class="params">(<span class="type">const</span> VI&amp; nums, CI K)</span> </span>&#123;</span><br><span class="line">	<span class="function">VVI <span class="title">F</span><span class="params">(K + <span class="number">1</span>, VI(nums.size(), <span class="number">0</span>))</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= K; ++k) &#123;</span><br><span class="line">		<span class="type">int</span> tmp = F[k - <span class="number">1</span>][<span class="number">0</span>] - nums[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			tmp = <span class="built_in">max</span>(F[k<span class="number">-1</span>][i] - nums[i], tmp);</span><br><span class="line">			F[k][i] = <span class="built_in">max</span>(F[k][i - <span class="number">1</span>], nums[i] + tmp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> F[K][nums.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> castCount; cin &gt;&gt; castCount;</span><br><span class="line">	<span class="keyword">while</span> (castCount--) &#123;</span><br><span class="line">		<span class="type">int</span> N;</span><br><span class="line">		cin &gt;&gt; N;</span><br><span class="line">		<span class="function">VI <span class="title">nums</span><span class="params">(N, <span class="number">0</span>)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span>&amp;e : nums)</span><br><span class="line">			cin &gt;&gt; e;</span><br><span class="line">		<span class="type">int</span> ans = <span class="built_in">solution</span>(nums,<span class="number">2</span>);</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&lt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">&gt;</a>
  </nav>


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar1.jpg"
                alt="博主" />
            
              <p class="site-author-name" itemprop="name">博主</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://github.com/hzxGoForward" title="github &rarr; https://github.com/hzxGoForward" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://www.zhihu.com/people/wen-ge-hua-49/activities" title="zhihu &rarr; https://www.zhihu.com/people/wen-ge-hua-49/activities" rel="noopener" target="_blank"><i class="fa fa-fw fa-zhihu"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="/hzx@pku.edu.cn" title="email &rarr; hzx@pku.edu.cn"><i class="fa fa-fw fa-envelope"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://me.csdn.net/t46414704152abc/" title="csdn &rarr; https://me.csdn.net/t46414704152abc/" rel="noopener" target="_blank"><i class="fa fa-fw fa-csdn"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://leetcode.cn/u/hzxforward/" title="leetcode &rarr; https://leetcode.cn/u/hzxforward/" rel="noopener" target="_blank"><i class="fa fa-fw fa-leetcode"></i></a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </section>

      

      

<!--背景音乐-->
<!--iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=86 src="//music.163.com/outchain/player?type=2&id=37856454&auto=1&height=66"></iframe> --> 
<!--<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=556319523&auto=1&height=66"></iframe> -->
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=86 src="//music.163.com/outchain/player?type=2&id=4341314&auto=1&height=66"></iframe>

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

<div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">博主</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v6.3.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.6.0</div>


<div>
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!--注释本行<span id="busuanzi_container_site_pv" style='display:none'>-->
    本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    <span class="post-meta-divider">|</span>
</span>
<span id="busuanzi_container_site_uv" style='display:none'>
    本站访问<span id="busuanzi_value_site_uv"></span>人次
</span>
</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="Total Visitors">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="Total Views">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
      
  
  <script type="text/javascript" color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.6.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.6.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  










  





  

  

  

  



  
  

  
  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        
      
    
      
    
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<style>
.MathJax_Display {
    overflow: auto hidden;
}
</style>

    
  


  
  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('Copy').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('Copy')
        }, 300)
      }).append(e)
    })
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->


  

</body>
</html>
